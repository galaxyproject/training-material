{"version":3,"file":"1278.58412d2.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/algorithm/src/array.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/application/node_modules/tslib/tslib.es6.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/algorithm/src/iter.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/algorithm/src/range.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/algorithm/src/string.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/application/src/index.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/algorithm/src/sort.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/algorithm/src/find.ts"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n\n/**\n * The namespace for array-specific algorithms.\n */\nexport namespace ArrayExt {\n  /**\n   * Find the index of the first occurrence of a value in an array.\n   *\n   * @param array - The array-like object to search.\n   *\n   * @param value - The value to locate in the array. Values are\n   *   compared using strict `===` equality.\n   *\n   * @param start - The index of the first element in the range to be\n   *   searched, inclusive. The default value is `0`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @param stop - The index of the last element in the range to be\n   *   searched, inclusive. The default value is `-1`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @returns The index of the first occurrence of the value, or `-1`\n   *   if the value is not found.\n   *\n   * #### Notes\n   * If `stop < start` the search will wrap at the end of the array.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Undefined Behavior\n   * A `start` or `stop` which is non-integral.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * let data = ['one', 'two', 'three', 'four', 'one'];\n   * ArrayExt.firstIndexOf(data, 'red');        // -1\n   * ArrayExt.firstIndexOf(data, 'one');        // 0\n   * ArrayExt.firstIndexOf(data, 'one', 1);     // 4\n   * ArrayExt.firstIndexOf(data, 'two', 2);     // -1\n   * ArrayExt.firstIndexOf(data, 'two', 2, 1);  // 1\n   * ```\n   */\n  export function firstIndexOf<T>(\n    array: ArrayLike<T>,\n    value: T,\n    start = 0,\n    stop = -1\n  ): number {\n    let n = array.length;\n    if (n === 0) {\n      return -1;\n    }\n    if (start < 0) {\n      start = Math.max(0, start + n);\n    } else {\n      start = Math.min(start, n - 1);\n    }\n    if (stop < 0) {\n      stop = Math.max(0, stop + n);\n    } else {\n      stop = Math.min(stop, n - 1);\n    }\n    let span: number;\n    if (stop < start) {\n      span = stop + 1 + (n - start);\n    } else {\n      span = stop - start + 1;\n    }\n    for (let i = 0; i < span; ++i) {\n      let j = (start + i) % n;\n      if (array[j] === value) {\n        return j;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Find the index of the last occurrence of a value in an array.\n   *\n   * @param array - The array-like object to search.\n   *\n   * @param value - The value to locate in the array. Values are\n   *   compared using strict `===` equality.\n   *\n   * @param start - The index of the first element in the range to be\n   *   searched, inclusive. The default value is `-1`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @param stop - The index of the last element in the range to be\n   *   searched, inclusive. The default value is `0`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @returns The index of the last occurrence of the value, or `-1`\n   *   if the value is not found.\n   *\n   * #### Notes\n   * If `start < stop` the search will wrap at the front of the array.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Undefined Behavior\n   * A `start` or `stop` which is non-integral.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * let data = ['one', 'two', 'three', 'four', 'one'];\n   * ArrayExt.lastIndexOf(data, 'red');        // -1\n   * ArrayExt.lastIndexOf(data, 'one');        // 4\n   * ArrayExt.lastIndexOf(data, 'one', 1);     // 0\n   * ArrayExt.lastIndexOf(data, 'two', 0);     // -1\n   * ArrayExt.lastIndexOf(data, 'two', 0, 1);  // 1\n   * ```\n   */\n  export function lastIndexOf<T>(\n    array: ArrayLike<T>,\n    value: T,\n    start = -1,\n    stop = 0\n  ): number {\n    let n = array.length;\n    if (n === 0) {\n      return -1;\n    }\n    if (start < 0) {\n      start = Math.max(0, start + n);\n    } else {\n      start = Math.min(start, n - 1);\n    }\n    if (stop < 0) {\n      stop = Math.max(0, stop + n);\n    } else {\n      stop = Math.min(stop, n - 1);\n    }\n    let span: number;\n    if (start < stop) {\n      span = start + 1 + (n - stop);\n    } else {\n      span = start - stop + 1;\n    }\n    for (let i = 0; i < span; ++i) {\n      let j = (start - i + n) % n;\n      if (array[j] === value) {\n        return j;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Find the index of the first value which matches a predicate.\n   *\n   * @param array - The array-like object to search.\n   *\n   * @param fn - The predicate function to apply to the values.\n   *\n   * @param start - The index of the first element in the range to be\n   *   searched, inclusive. The default value is `0`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @param stop - The index of the last element in the range to be\n   *   searched, inclusive. The default value is `-1`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @returns The index of the first matching value, or `-1` if no\n   *   matching value is found.\n   *\n   * #### Notes\n   * If `stop < start` the search will wrap at the end of the array.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Undefined Behavior\n   * A `start` or `stop` which is non-integral.\n   *\n   * Modifying the length of the array while searching.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * function isEven(value: number): boolean {\n   *   return value % 2 === 0;\n   * }\n   *\n   * let data = [1, 2, 3, 4, 3, 2, 1];\n   * ArrayExt.findFirstIndex(data, isEven);       // 1\n   * ArrayExt.findFirstIndex(data, isEven, 4);    // 5\n   * ArrayExt.findFirstIndex(data, isEven, 6);    // -1\n   * ArrayExt.findFirstIndex(data, isEven, 6, 5); // 1\n   * ```\n   */\n  export function findFirstIndex<T>(\n    array: ArrayLike<T>,\n    fn: (value: T, index: number) => boolean,\n    start = 0,\n    stop = -1\n  ): number {\n    let n = array.length;\n    if (n === 0) {\n      return -1;\n    }\n    if (start < 0) {\n      start = Math.max(0, start + n);\n    } else {\n      start = Math.min(start, n - 1);\n    }\n    if (stop < 0) {\n      stop = Math.max(0, stop + n);\n    } else {\n      stop = Math.min(stop, n - 1);\n    }\n    let span: number;\n    if (stop < start) {\n      span = stop + 1 + (n - start);\n    } else {\n      span = stop - start + 1;\n    }\n    for (let i = 0; i < span; ++i) {\n      let j = (start + i) % n;\n      if (fn(array[j], j)) {\n        return j;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Find the index of the last value which matches a predicate.\n   *\n   * @param object - The array-like object to search.\n   *\n   * @param fn - The predicate function to apply to the values.\n   *\n   * @param start - The index of the first element in the range to be\n   *   searched, inclusive. The default value is `-1`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @param stop - The index of the last element in the range to be\n   *   searched, inclusive. The default value is `0`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @returns The index of the last matching value, or `-1` if no\n   *   matching value is found.\n   *\n   * #### Notes\n   * If `start < stop` the search will wrap at the front of the array.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Undefined Behavior\n   * A `start` or `stop` which is non-integral.\n   *\n   * Modifying the length of the array while searching.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * function isEven(value: number): boolean {\n   *   return value % 2 === 0;\n   * }\n   *\n   * let data = [1, 2, 3, 4, 3, 2, 1];\n   * ArrayExt.findLastIndex(data, isEven);        // 5\n   * ArrayExt.findLastIndex(data, isEven, 4);     // 3\n   * ArrayExt.findLastIndex(data, isEven, 0);     // -1\n   * ArrayExt.findLastIndex(data, isEven, 0, 1);  // 5\n   * ```\n   */\n  export function findLastIndex<T>(\n    array: ArrayLike<T>,\n    fn: (value: T, index: number) => boolean,\n    start = -1,\n    stop = 0\n  ): number {\n    let n = array.length;\n    if (n === 0) {\n      return -1;\n    }\n    if (start < 0) {\n      start = Math.max(0, start + n);\n    } else {\n      start = Math.min(start, n - 1);\n    }\n    if (stop < 0) {\n      stop = Math.max(0, stop + n);\n    } else {\n      stop = Math.min(stop, n - 1);\n    }\n    let d: number;\n    if (start < stop) {\n      d = start + 1 + (n - stop);\n    } else {\n      d = start - stop + 1;\n    }\n    for (let i = 0; i < d; ++i) {\n      let j = (start - i + n) % n;\n      if (fn(array[j], j)) {\n        return j;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Find the first value which matches a predicate.\n   *\n   * @param array - The array-like object to search.\n   *\n   * @param fn - The predicate function to apply to the values.\n   *\n   * @param start - The index of the first element in the range to be\n   *   searched, inclusive. The default value is `0`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @param stop - The index of the last element in the range to be\n   *   searched, inclusive. The default value is `-1`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @returns The first matching value, or `undefined` if no matching\n   *   value is found.\n   *\n   * #### Notes\n   * If `stop < start` the search will wrap at the end of the array.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Undefined Behavior\n   * A `start` or `stop` which is non-integral.\n   *\n   * Modifying the length of the array while searching.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * function isEven(value: number): boolean {\n   *   return value % 2 === 0;\n   * }\n   *\n   * let data = [1, 2, 3, 4, 3, 2, 1];\n   * ArrayExt.findFirstValue(data, isEven);       // 2\n   * ArrayExt.findFirstValue(data, isEven, 2);    // 4\n   * ArrayExt.findFirstValue(data, isEven, 6);    // undefined\n   * ArrayExt.findFirstValue(data, isEven, 6, 5); // 2\n   * ```\n   */\n  export function findFirstValue<T>(\n    array: ArrayLike<T>,\n    fn: (value: T, index: number) => boolean,\n    start = 0,\n    stop = -1\n  ): T | undefined {\n    let index = findFirstIndex(array, fn, start, stop);\n    return index !== -1 ? array[index] : undefined;\n  }\n\n  /**\n   * Find the last value which matches a predicate.\n   *\n   * @param object - The array-like object to search.\n   *\n   * @param fn - The predicate function to apply to the values.\n   *\n   * @param start - The index of the first element in the range to be\n   *   searched, inclusive. The default value is `-1`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @param stop - The index of the last element in the range to be\n   *   searched, inclusive. The default value is `0`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @returns The last matching value, or `undefined` if no matching\n   *   value is found.\n   *\n   * #### Notes\n   * If `start < stop` the search will wrap at the front of the array.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Undefined Behavior\n   * A `start` or `stop` which is non-integral.\n   *\n   * Modifying the length of the array while searching.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * function isEven(value: number): boolean {\n   *   return value % 2 === 0;\n   * }\n   *\n   * let data = [1, 2, 3, 4, 3, 2, 1];\n   * ArrayExt.findLastValue(data, isEven);        // 2\n   * ArrayExt.findLastValue(data, isEven, 4);     // 4\n   * ArrayExt.findLastValue(data, isEven, 0);     // undefined\n   * ArrayExt.findLastValue(data, isEven, 0, 1);  // 2\n   * ```\n   */\n  export function findLastValue<T>(\n    array: ArrayLike<T>,\n    fn: (value: T, index: number) => boolean,\n    start = -1,\n    stop = 0\n  ): T | undefined {\n    let index = findLastIndex(array, fn, start, stop);\n    return index !== -1 ? array[index] : undefined;\n  }\n\n  /**\n   * Find the index of the first element which compares `>=` to a value.\n   *\n   * @param array - The sorted array-like object to search.\n   *\n   * @param value - The value to locate in the array.\n   *\n   * @param fn - The 3-way comparison function to apply to the values.\n   *   It should return `< 0` if an element is less than a value, `0` if\n   *   an element is equal to a value, or `> 0` if an element is greater\n   *   than a value.\n   *\n   * @param start - The index of the first element in the range to be\n   *   searched, inclusive. The default value is `0`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @param stop - The index of the last element in the range to be\n   *   searched, inclusive. The default value is `-1`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @returns The index of the first element which compares `>=` to the\n   *   value, or `length` if there is no such element. If the computed\n   *   index for `stop` is less than `start`, then the computed index\n   *   for `start` is returned.\n   *\n   * #### Notes\n   * The array must already be sorted in ascending order according to\n   * the comparison function.\n   *\n   * #### Complexity\n   * Logarithmic.\n   *\n   * #### Undefined Behavior\n   * Searching a range which is not sorted in ascending order.\n   *\n   * A `start` or `stop` which is non-integral.\n   *\n   * Modifying the length of the array while searching.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * function numberCmp(a: number, b: number): number {\n   *   return a - b;\n   * }\n   *\n   * let data = [0, 3, 4, 7, 7, 9];\n   * ArrayExt.lowerBound(data, 0, numberCmp);   // 0\n   * ArrayExt.lowerBound(data, 6, numberCmp);   // 3\n   * ArrayExt.lowerBound(data, 7, numberCmp);   // 3\n   * ArrayExt.lowerBound(data, -1, numberCmp);  // 0\n   * ArrayExt.lowerBound(data, 10, numberCmp);  // 6\n   * ```\n   */\n  export function lowerBound<T, U>(\n    array: ArrayLike<T>,\n    value: U,\n    fn: (element: T, value: U) => number,\n    start = 0,\n    stop = -1\n  ): number {\n    let n = array.length;\n    if (n === 0) {\n      return 0;\n    }\n    if (start < 0) {\n      start = Math.max(0, start + n);\n    } else {\n      start = Math.min(start, n - 1);\n    }\n    if (stop < 0) {\n      stop = Math.max(0, stop + n);\n    } else {\n      stop = Math.min(stop, n - 1);\n    }\n    let begin = start;\n    let span = stop - start + 1;\n    while (span > 0) {\n      let half = span >> 1;\n      let middle = begin + half;\n      if (fn(array[middle], value) < 0) {\n        begin = middle + 1;\n        span -= half + 1;\n      } else {\n        span = half;\n      }\n    }\n    return begin;\n  }\n\n  /**\n   * Find the index of the first element which compares `>` than a value.\n   *\n   * @param array - The sorted array-like object to search.\n   *\n   * @param value - The value to locate in the array.\n   *\n   * @param fn - The 3-way comparison function to apply to the values.\n   *   It should return `< 0` if an element is less than a value, `0` if\n   *   an element is equal to a value, or `> 0` if an element is greater\n   *   than a value.\n   *\n   * @param start - The index of the first element in the range to be\n   *   searched, inclusive. The default value is `0`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @param stop - The index of the last element in the range to be\n   *   searched, inclusive. The default value is `-1`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @returns The index of the first element which compares `>` than the\n   *   value, or `length` if there is no such element. If the computed\n   *   index for `stop` is less than `start`, then the computed index\n   *   for `start` is returned.\n   *\n   * #### Notes\n   * The array must already be sorted in ascending order according to\n   * the comparison function.\n   *\n   * #### Complexity\n   * Logarithmic.\n   *\n   * #### Undefined Behavior\n   * Searching a range which is not sorted in ascending order.\n   *\n   * A `start` or `stop` which is non-integral.\n   *\n   * Modifying the length of the array while searching.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * function numberCmp(a: number, b: number): number {\n   *   return a - b;\n   * }\n   *\n   * let data = [0, 3, 4, 7, 7, 9];\n   * ArrayExt.upperBound(data, 0, numberCmp);   // 1\n   * ArrayExt.upperBound(data, 6, numberCmp);   // 3\n   * ArrayExt.upperBound(data, 7, numberCmp);   // 5\n   * ArrayExt.upperBound(data, -1, numberCmp);  // 0\n   * ArrayExt.upperBound(data, 10, numberCmp);  // 6\n   * ```\n   */\n  export function upperBound<T, U>(\n    array: ArrayLike<T>,\n    value: U,\n    fn: (element: T, value: U) => number,\n    start = 0,\n    stop = -1\n  ): number {\n    let n = array.length;\n    if (n === 0) {\n      return 0;\n    }\n    if (start < 0) {\n      start = Math.max(0, start + n);\n    } else {\n      start = Math.min(start, n - 1);\n    }\n    if (stop < 0) {\n      stop = Math.max(0, stop + n);\n    } else {\n      stop = Math.min(stop, n - 1);\n    }\n    let begin = start;\n    let span = stop - start + 1;\n    while (span > 0) {\n      let half = span >> 1;\n      let middle = begin + half;\n      if (fn(array[middle], value) > 0) {\n        span = half;\n      } else {\n        begin = middle + 1;\n        span -= half + 1;\n      }\n    }\n    return begin;\n  }\n\n  /**\n   * Test whether two arrays are shallowly equal.\n   *\n   * @param a - The first array-like object to compare.\n   *\n   * @param b - The second array-like object to compare.\n   *\n   * @param fn - The comparison function to apply to the elements. It\n   *   should return `true` if the elements are \"equal\". The default\n   *   compares elements using strict `===` equality.\n   *\n   * @returns Whether the two arrays are shallowly equal.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Undefined Behavior\n   * Modifying the length of the arrays while comparing.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * let d1 = [0, 3, 4, 7, 7, 9];\n   * let d2 = [0, 3, 4, 7, 7, 9];\n   * let d3 = [42];\n   * ArrayExt.shallowEqual(d1, d2);  // true\n   * ArrayExt.shallowEqual(d2, d3);  // false\n   * ```\n   */\n  export function shallowEqual<T>(\n    a: ArrayLike<T>,\n    b: ArrayLike<T>,\n    fn?: (a: T, b: T) => boolean\n  ): boolean {\n    // Check for object identity first.\n    if (a === b) {\n      return true;\n    }\n\n    // Bail early if the lengths are different.\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    // Compare each element for equality.\n    for (let i = 0, n = a.length; i < n; ++i) {\n      if (fn ? !fn(a[i], b[i]) : a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    // The array are shallowly equal.\n    return true;\n  }\n\n  /**\n   * Create a slice of an array subject to an optional step.\n   *\n   * @param array - The array-like object of interest.\n   *\n   * @param options - The options for configuring the slice.\n   *\n   * @returns A new array with the specified values.\n   *\n   * @throws An exception if the slice `step` is `0`.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Undefined Behavior\n   * A `start`, `stop`, or `step` which is non-integral.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * let data = [0, 3, 4, 7, 7, 9];\n   * ArrayExt.slice(data);                         // [0, 3, 4, 7, 7, 9]\n   * ArrayExt.slice(data, { start: 2 });           // [4, 7, 7, 9]\n   * ArrayExt.slice(data, { start: 0, stop: 4 });  // [0, 3, 4, 7]\n   * ArrayExt.slice(data, { step: 2 });            // [0, 4, 7]\n   * ArrayExt.slice(data, { step: -1 });           // [9, 7, 7, 4, 3, 0]\n   * ```\n   */\n  export function slice<T>(\n    array: ArrayLike<T>,\n    options: slice.IOptions = {}\n  ): T[] {\n    // Extract the options.\n    let { start, stop, step } = options;\n\n    // Set up the `step` value.\n    if (step === undefined) {\n      step = 1;\n    }\n\n    // Validate the step size.\n    if (step === 0) {\n      throw new Error('Slice `step` cannot be zero.');\n    }\n\n    // Look up the length of the array.\n    let n = array.length;\n\n    // Set up the `start` value.\n    if (start === undefined) {\n      start = step < 0 ? n - 1 : 0;\n    } else if (start < 0) {\n      start = Math.max(start + n, step < 0 ? -1 : 0);\n    } else if (start >= n) {\n      start = step < 0 ? n - 1 : n;\n    }\n\n    // Set up the `stop` value.\n    if (stop === undefined) {\n      stop = step < 0 ? -1 : n;\n    } else if (stop < 0) {\n      stop = Math.max(stop + n, step < 0 ? -1 : 0);\n    } else if (stop >= n) {\n      stop = step < 0 ? n - 1 : n;\n    }\n\n    // Compute the slice length.\n    let length;\n    if ((step < 0 && stop >= start) || (step > 0 && start >= stop)) {\n      length = 0;\n    } else if (step < 0) {\n      length = Math.floor((stop - start + 1) / step + 1);\n    } else {\n      length = Math.floor((stop - start - 1) / step + 1);\n    }\n\n    // Compute the sliced result.\n    let result: T[] = [];\n    for (let i = 0; i < length; ++i) {\n      result[i] = array[start + i * step];\n    }\n\n    // Return the result.\n    return result;\n  }\n\n  /**\n   * The namespace for the `slice` function statics.\n   */\n  export namespace slice {\n    /**\n     * The options for the `slice` function.\n     */\n    export interface IOptions {\n      /**\n       * The starting index of the slice, inclusive.\n       *\n       * Negative values are taken as an offset from the end\n       * of the array.\n       *\n       * The default is `0` if `step > 0` else `n - 1`.\n       */\n      start?: number;\n\n      /**\n       * The stopping index of the slice, exclusive.\n       *\n       * Negative values are taken as an offset from the end\n       * of the array.\n       *\n       * The default is `n` if `step > 0` else `-n - 1`.\n       */\n      stop?: number;\n\n      /**\n       * The step value for the slice.\n       *\n       * This must not be `0`.\n       *\n       * The default is `1`.\n       */\n      step?: number;\n    }\n  }\n\n  /**\n   * An array-like object which supports item assignment.\n   */\n  export type MutableArrayLike<T> = {\n    readonly length: number;\n    [index: number]: T;\n  };\n\n  /**\n   * Move an element in an array from one index to another.\n   *\n   * @param array - The mutable array-like object of interest.\n   *\n   * @param fromIndex - The index of the element to move. Negative\n   *   values are taken as an offset from the end of the array.\n   *\n   * @param toIndex - The target index of the element. Negative\n   *   values are taken as an offset from the end of the array.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Undefined Behavior\n   * A `fromIndex` or `toIndex` which is non-integral.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from from '@lumino/algorithm';\n   *\n   * let data = [0, 1, 2, 3, 4];\n   * ArrayExt.move(data, 1, 2);  // [0, 2, 1, 3, 4]\n   * ArrayExt.move(data, 4, 2);  // [0, 2, 4, 1, 3]\n   * ```\n   */\n  export function move<T>(\n    array: MutableArrayLike<T>,\n    fromIndex: number,\n    toIndex: number\n  ): void {\n    let n = array.length;\n    if (n <= 1) {\n      return;\n    }\n    if (fromIndex < 0) {\n      fromIndex = Math.max(0, fromIndex + n);\n    } else {\n      fromIndex = Math.min(fromIndex, n - 1);\n    }\n    if (toIndex < 0) {\n      toIndex = Math.max(0, toIndex + n);\n    } else {\n      toIndex = Math.min(toIndex, n - 1);\n    }\n    if (fromIndex === toIndex) {\n      return;\n    }\n    let value = array[fromIndex];\n    let d = fromIndex < toIndex ? 1 : -1;\n    for (let i = fromIndex; i !== toIndex; i += d) {\n      array[i] = array[i + d];\n    }\n    array[toIndex] = value;\n  }\n\n  /**\n   * Reverse an array in-place.\n   *\n   * @param array - The mutable array-like object of interest.\n   *\n   * @param start - The index of the first element in the range to be\n   *   reversed, inclusive. The default value is `0`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @param stop - The index of the last element in the range to be\n   *   reversed, inclusive. The default value is `-1`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Undefined Behavior\n   * A `start` or  `stop` index which is non-integral.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * let data = [0, 1, 2, 3, 4];\n   * ArrayExt.reverse(data, 1, 3);  // [0, 3, 2, 1, 4]\n   * ArrayExt.reverse(data, 3);     // [0, 3, 2, 4, 1]\n   * ArrayExt.reverse(data);        // [1, 4, 2, 3, 0]\n   * ```\n   */\n  export function reverse<T>(\n    array: MutableArrayLike<T>,\n    start = 0,\n    stop = -1\n  ): void {\n    let n = array.length;\n    if (n <= 1) {\n      return;\n    }\n    if (start < 0) {\n      start = Math.max(0, start + n);\n    } else {\n      start = Math.min(start, n - 1);\n    }\n    if (stop < 0) {\n      stop = Math.max(0, stop + n);\n    } else {\n      stop = Math.min(stop, n - 1);\n    }\n    while (start < stop) {\n      let a = array[start];\n      let b = array[stop];\n      array[start++] = b;\n      array[stop--] = a;\n    }\n  }\n\n  /**\n   * Rotate the elements of an array in-place.\n   *\n   * @param array - The mutable array-like object of interest.\n   *\n   * @param delta - The amount of rotation to apply to the elements. A\n   *   positive value will rotate the elements to the left. A negative\n   *   value will rotate the elements to the right.\n   *\n   * @param start - The index of the first element in the range to be\n   *   rotated, inclusive. The default value is `0`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @param stop - The index of the last element in the range to be\n   *   rotated, inclusive. The default value is `-1`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Undefined Behavior\n   * A `delta`, `start`, or `stop` which is non-integral.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * let data = [0, 1, 2, 3, 4];\n   * ArrayExt.rotate(data, 2);        // [2, 3, 4, 0, 1]\n   * ArrayExt.rotate(data, -2);       // [0, 1, 2, 3, 4]\n   * ArrayExt.rotate(data, 10);       // [0, 1, 2, 3, 4]\n   * ArrayExt.rotate(data, 9);        // [4, 0, 1, 2, 3]\n   * ArrayExt.rotate(data, 2, 1, 3);  // [4, 2, 0, 1, 3]\n   * ```\n   */\n  export function rotate<T>(\n    array: MutableArrayLike<T>,\n    delta: number,\n    start = 0,\n    stop = -1\n  ): void {\n    let n = array.length;\n    if (n <= 1) {\n      return;\n    }\n    if (start < 0) {\n      start = Math.max(0, start + n);\n    } else {\n      start = Math.min(start, n - 1);\n    }\n    if (stop < 0) {\n      stop = Math.max(0, stop + n);\n    } else {\n      stop = Math.min(stop, n - 1);\n    }\n    if (start >= stop) {\n      return;\n    }\n    let length = stop - start + 1;\n    if (delta > 0) {\n      delta = delta % length;\n    } else if (delta < 0) {\n      delta = ((delta % length) + length) % length;\n    }\n    if (delta === 0) {\n      return;\n    }\n    let pivot = start + delta;\n    reverse(array, start, pivot - 1);\n    reverse(array, pivot, stop);\n    reverse(array, start, stop);\n  }\n\n  /**\n   * Fill an array with a static value.\n   *\n   * @param array - The mutable array-like object to fill.\n   *\n   * @param value - The static value to use to fill the array.\n   *\n   * @param start - The index of the first element in the range to be\n   *   filled, inclusive. The default value is `0`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @param stop - The index of the last element in the range to be\n   *   filled, inclusive. The default value is `-1`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * #### Notes\n   * If `stop < start` the fill will wrap at the end of the array.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Undefined Behavior\n   * A `start` or `stop` which is non-integral.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * let data = ['one', 'two', 'three', 'four'];\n   * ArrayExt.fill(data, 'r');        // ['r', 'r', 'r', 'r']\n   * ArrayExt.fill(data, 'g', 1);     // ['r', 'g', 'g', 'g']\n   * ArrayExt.fill(data, 'b', 2, 3);  // ['r', 'g', 'b', 'b']\n   * ArrayExt.fill(data, 'z', 3, 1);  // ['z', 'z', 'b', 'z']\n   * ```\n   */\n  export function fill<T>(\n    array: MutableArrayLike<T>,\n    value: T,\n    start = 0,\n    stop = -1\n  ): void {\n    let n = array.length;\n    if (n === 0) {\n      return;\n    }\n    if (start < 0) {\n      start = Math.max(0, start + n);\n    } else {\n      start = Math.min(start, n - 1);\n    }\n    if (stop < 0) {\n      stop = Math.max(0, stop + n);\n    } else {\n      stop = Math.min(stop, n - 1);\n    }\n    let span: number;\n    if (stop < start) {\n      span = stop + 1 + (n - start);\n    } else {\n      span = stop - start + 1;\n    }\n    for (let i = 0; i < span; ++i) {\n      array[(start + i) % n] = value;\n    }\n  }\n\n  /**\n   * Insert a value into an array at a specific index.\n   *\n   * @param array - The array of interest.\n   *\n   * @param index - The index at which to insert the value. Negative\n   *   values are taken as an offset from the end of the array.\n   *\n   * @param value - The value to set at the specified index.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * let data = [0, 1, 2];\n   * ArrayExt.insert(data, 0, -1);  // [-1, 0, 1, 2]\n   * ArrayExt.insert(data, 2, 12);  // [-1, 0, 12, 1, 2]\n   * ArrayExt.insert(data, -1, 7);  // [-1, 0, 12, 1, 7, 2]\n   * ArrayExt.insert(data, 6, 19);  // [-1, 0, 12, 1, 7, 2, 19]\n   * ```\n   */\n  export function insert<T>(array: Array<T>, index: number, value: T): void {\n    let n = array.length;\n    if (index < 0) {\n      index = Math.max(0, index + n);\n    } else {\n      index = Math.min(index, n);\n    }\n    for (let i = n; i > index; --i) {\n      array[i] = array[i - 1];\n    }\n    array[index] = value;\n  }\n\n  /**\n   * Remove and return a value at a specific index in an array.\n   *\n   * @param array - The array of interest.\n   *\n   * @param index - The index of the value to remove. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @returns The value at the specified index, or `undefined` if the\n   *   index is out of range.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * let data = [0, 12, 23, 39, 14, 12, 75];\n   * ArrayExt.removeAt(data, 2);   // 23\n   * ArrayExt.removeAt(data, -2);  // 12\n   * ArrayExt.removeAt(data, 10);  // undefined;\n   * ```\n   */\n  export function removeAt<T>(array: Array<T>, index: number): T | undefined {\n    let n = array.length;\n    if (index < 0) {\n      index += n;\n    }\n    if (index < 0 || index >= n) {\n      return undefined;\n    }\n    let value = array[index];\n    for (let i = index + 1; i < n; ++i) {\n      array[i - 1] = array[i];\n    }\n    array.length = n - 1;\n    return value;\n  }\n\n  /**\n   * Remove the first occurrence of a value from an array.\n   *\n   * @param array - The array of interest.\n   *\n   * @param value - The value to remove from the array. Values are\n   *   compared using strict `===` equality.\n   *\n   * @param start - The index of the first element in the range to be\n   *   searched, inclusive. The default value is `0`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @param stop - The index of the last element in the range to be\n   *   searched, inclusive. The default value is `-1`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @returns The index of the removed value, or `-1` if the value\n   *   is not contained in the array.\n   *\n   * #### Notes\n   * If `stop < start` the search will wrap at the end of the array.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * let data = [0, 12, 23, 39, 14, 12, 75];\n   * ArrayExt.removeFirstOf(data, 12);        // 1\n   * ArrayExt.removeFirstOf(data, 17);        // -1\n   * ArrayExt.removeFirstOf(data, 39, 3);     // -1\n   * ArrayExt.removeFirstOf(data, 39, 3, 2);  // 2\n   * ```\n   */\n  export function removeFirstOf<T>(\n    array: Array<T>,\n    value: T,\n    start = 0,\n    stop = -1\n  ): number {\n    let index = firstIndexOf(array, value, start, stop);\n    if (index !== -1) {\n      removeAt(array, index);\n    }\n    return index;\n  }\n\n  /**\n   * Remove the last occurrence of a value from an array.\n   *\n   * @param array - The array of interest.\n   *\n   * @param value - The value to remove from the array. Values are\n   *   compared using strict `===` equality.\n   *\n   * @param start - The index of the first element in the range to be\n   *   searched, inclusive. The default value is `-1`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @param stop - The index of the last element in the range to be\n   *   searched, inclusive. The default value is `0`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @returns The index of the removed value, or `-1` if the value\n   *   is not contained in the array.\n   *\n   * #### Notes\n   * If `start < stop` the search will wrap at the end of the array.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * let data = [0, 12, 23, 39, 14, 12, 75];\n   * ArrayExt.removeLastOf(data, 12);        // 5\n   * ArrayExt.removeLastOf(data, 17);        // -1\n   * ArrayExt.removeLastOf(data, 39, 2);     // -1\n   * ArrayExt.removeLastOf(data, 39, 2, 3);  // 3\n   * ```\n   */\n  export function removeLastOf<T>(\n    array: Array<T>,\n    value: T,\n    start = -1,\n    stop = 0\n  ): number {\n    let index = lastIndexOf(array, value, start, stop);\n    if (index !== -1) {\n      removeAt(array, index);\n    }\n    return index;\n  }\n\n  /**\n   * Remove all occurrences of a value from an array.\n   *\n   * @param array - The array of interest.\n   *\n   * @param value - The value to remove from the array. Values are\n   *   compared using strict `===` equality.\n   *\n   * @param start - The index of the first element in the range to be\n   *   searched, inclusive. The default value is `0`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @param stop - The index of the last element in the range to be\n   *   searched, inclusive. The default value is `-1`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @returns The number of elements removed from the array.\n   *\n   * #### Notes\n   * If `stop < start` the search will conceptually wrap at the end of\n   * the array, however the array will be traversed front-to-back.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * let data = [14, 12, 23, 39, 14, 12, 19, 14];\n   * ArrayExt.removeAllOf(data, 12);        // 2\n   * ArrayExt.removeAllOf(data, 17);        // 0\n   * ArrayExt.removeAllOf(data, 14, 1, 4);  // 1\n   * ```\n   */\n  export function removeAllOf<T>(\n    array: Array<T>,\n    value: T,\n    start = 0,\n    stop = -1\n  ): number {\n    let n = array.length;\n    if (n === 0) {\n      return 0;\n    }\n    if (start < 0) {\n      start = Math.max(0, start + n);\n    } else {\n      start = Math.min(start, n - 1);\n    }\n    if (stop < 0) {\n      stop = Math.max(0, stop + n);\n    } else {\n      stop = Math.min(stop, n - 1);\n    }\n    let count = 0;\n    for (let i = 0; i < n; ++i) {\n      if (start <= stop && i >= start && i <= stop && array[i] === value) {\n        count++;\n      } else if (\n        stop < start &&\n        (i <= stop || i >= start) &&\n        array[i] === value\n      ) {\n        count++;\n      } else if (count > 0) {\n        array[i - count] = array[i];\n      }\n    }\n    if (count > 0) {\n      array.length = n - count;\n    }\n    return count;\n  }\n\n  /**\n   * Remove the first occurrence of a value which matches a predicate.\n   *\n   * @param array - The array of interest.\n   *\n   * @param fn - The predicate function to apply to the values.\n   *\n   * @param start - The index of the first element in the range to be\n   *   searched, inclusive. The default value is `0`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @param stop - The index of the last element in the range to be\n   *   searched, inclusive. The default value is `-1`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @returns The removed `{ index, value }`, which will be `-1` and\n   *   `undefined` if the value is not contained in the array.\n   *\n   * #### Notes\n   * If `stop < start` the search will wrap at the end of the array.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * function isEven(value: number): boolean {\n   *   return value % 2 === 0;\n   * }\n   *\n   * let data = [0, 12, 23, 39, 14, 12, 75];\n   * ArrayExt.removeFirstWhere(data, isEven);     // { index: 0, value: 0 }\n   * ArrayExt.removeFirstWhere(data, isEven, 2);  // { index: 3, value: 14 }\n   * ArrayExt.removeFirstWhere(data, isEven, 4);  // { index: -1, value: undefined }\n   * ```\n   */\n  export function removeFirstWhere<T>(\n    array: Array<T>,\n    fn: (value: T, index: number) => boolean,\n    start = 0,\n    stop = -1\n  ): { index: number; value: T | undefined } {\n    let value: T | undefined;\n    let index = findFirstIndex(array, fn, start, stop);\n    if (index !== -1) {\n      value = removeAt(array, index);\n    }\n    return { index, value };\n  }\n\n  /**\n   * Remove the last occurrence of a value which matches a predicate.\n   *\n   * @param array - The array of interest.\n   *\n   * @param fn - The predicate function to apply to the values.\n   *\n   * @param start - The index of the first element in the range to be\n   *   searched, inclusive. The default value is `-1`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @param stop - The index of the last element in the range to be\n   *   searched, inclusive. The default value is `0`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @returns The removed `{ index, value }`, which will be `-1` and\n   *   `undefined` if the value is not contained in the array.\n   *\n   * #### Notes\n   * If `start < stop` the search will wrap at the end of the array.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * function isEven(value: number): boolean {\n   *   return value % 2 === 0;\n   * }\n   *\n   * let data = [0, 12, 23, 39, 14, 12, 75];\n   * ArrayExt.removeLastWhere(data, isEven);        // { index: 5, value: 12 }\n   * ArrayExt.removeLastWhere(data, isEven, 2);     // { index: 1, value: 12 }\n   * ArrayExt.removeLastWhere(data, isEven, 2, 1);  // { index: -1, value: undefined }\n   * ```\n   */\n  export function removeLastWhere<T>(\n    array: Array<T>,\n    fn: (value: T, index: number) => boolean,\n    start = -1,\n    stop = 0\n  ): { index: number; value: T | undefined } {\n    let value: T | undefined;\n    let index = findLastIndex(array, fn, start, stop);\n    if (index !== -1) {\n      value = removeAt(array, index);\n    }\n    return { index, value };\n  }\n\n  /**\n   * Remove all occurrences of values which match a predicate.\n   *\n   * @param array - The array of interest.\n   *\n   * @param fn - The predicate function to apply to the values.\n   *\n   * @param start - The index of the first element in the range to be\n   *   searched, inclusive. The default value is `0`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @param stop - The index of the last element in the range to be\n   *   searched, inclusive. The default value is `-1`. Negative values\n   *   are taken as an offset from the end of the array.\n   *\n   * @returns The number of elements removed from the array.\n   *\n   * #### Notes\n   * If `stop < start` the search will conceptually wrap at the end of\n   * the array, however the array will be traversed front-to-back.\n   *\n   * #### Complexity\n   * Linear.\n   *\n   * #### Example\n   * ```typescript\n   * import { ArrayExt } from '@lumino/algorithm';\n   *\n   * function isEven(value: number): boolean {\n   *   return value % 2 === 0;\n   * }\n   *\n   * function isNegative(value: number): boolean {\n   *   return value < 0;\n   * }\n   *\n   * let data = [0, 12, -13, -9, 23, 39, 14, -15, 12, 75];\n   * ArrayExt.removeAllWhere(data, isEven);            // 4\n   * ArrayExt.removeAllWhere(data, isNegative, 0, 3);  // 2\n   * ```\n   */\n  export function removeAllWhere<T>(\n    array: Array<T>,\n    fn: (value: T, index: number) => boolean,\n    start = 0,\n    stop = -1\n  ): number {\n    let n = array.length;\n    if (n === 0) {\n      return 0;\n    }\n    if (start < 0) {\n      start = Math.max(0, start + n);\n    } else {\n      start = Math.min(start, n - 1);\n    }\n    if (stop < 0) {\n      stop = Math.max(0, stop + n);\n    } else {\n      stop = Math.min(stop, n - 1);\n    }\n    let count = 0;\n    for (let i = 0; i < n; ++i) {\n      if (start <= stop && i >= start && i <= stop && fn(array[i], i)) {\n        count++;\n      } else if (stop < start && (i <= stop || i >= start) && fn(array[i], i)) {\n        count++;\n      } else if (count > 0) {\n        array[i - count] = array[i];\n      }\n    }\n    if (count > 0) {\n      array.length = n - count;\n    }\n    return count;\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || from);\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n\n/**\n * An object which can produce an iterator over its values.\n */\nexport interface IIterable<T> {\n  /**\n   * Get an iterator over the object's values.\n   *\n   * @returns An iterator which yields the object's values.\n   *\n   * #### Notes\n   * Depending on the iterable, the returned iterator may or may not be\n   * a new object. A collection or other container-like object should\n   * typically return a new iterator, while an iterator itself should\n   * normally return `this`.\n   */\n  iter(): IIterator<T>;\n}\n\n/**\n * An object which traverses a collection of values.\n *\n * #### Notes\n * An `IIterator` is itself an `IIterable`. Most implementations of\n * `IIterator` should simply return `this` from the `iter()` method.\n */\nexport interface IIterator<T> extends IIterable<T> {\n  /**\n   * Create an independent clone of the iterator.\n   *\n   * @returns A new independent clone of the iterator.\n   *\n   * #### Notes\n   * The cloned iterator can be consumed independently of the current\n   * iterator. In essence, it is a copy of the iterator value stream\n   * which starts at the current location.\n   *\n   * This can be useful for lookahead and stream duplication.\n   */\n  clone(): IIterator<T>;\n\n  /**\n   * Get the next value from the iterator.\n   *\n   * @returns The next value from the iterator, or `undefined`.\n   *\n   * #### Notes\n   * The `undefined` value is used to signal the end of iteration and\n   * should therefore not be used as a value in a collection.\n   *\n   * The use of the `undefined` sentinel is an explicit design choice\n   * which favors performance over purity. The ES6 iterator design of\n   * returning a `{ value, done }` pair is suboptimal, as it requires\n   * an object allocation on each iteration; and an `isDone()` method\n   * would increase implementation and runtime complexity.\n   */\n  next(): T | undefined;\n}\n\n/**\n * A type alias for an iterable or builtin array-like object.\n */\nexport type IterableOrArrayLike<T> = IIterable<T> | ArrayLike<T>;\n\n/**\n * Create an iterator for an iterable object.\n *\n * @param object - The iterable or array-like object of interest.\n *\n * @returns A new iterator for the given object.\n *\n * #### Notes\n * This function allows iteration algorithms to operate on user-defined\n * iterable types and builtin array-like objects in a uniform fashion.\n */\nexport function iter<T>(object: IterableOrArrayLike<T>): IIterator<T> {\n  let it: IIterator<T>;\n  if (typeof (object as any).iter === 'function') {\n    it = (object as IIterable<T>).iter();\n  } else {\n    it = new ArrayIterator<T>(object as ArrayLike<T>);\n  }\n  return it;\n}\n\n/**\n * Create an iterator for the keys in an object.\n *\n * @param object - The object of interest.\n *\n * @returns A new iterator for the keys in the given object.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { each, keys } from '@lumino/algorithm';\n *\n * let data = { one: 1, two: 2, three: 3 };\n *\n * each(keys(data), key => { console.log(key); }); // 'one', 'two', 'three'\n * ```\n */\nexport function iterKeys<T>(object: {\n  readonly [key: string]: T;\n}): IIterator<string> {\n  return new KeyIterator(object);\n}\n\n/**\n * Create an iterator for the values in an object.\n *\n * @param object - The object of interest.\n *\n * @returns A new iterator for the values in the given object.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { each, values } from '@lumino/algorithm';\n *\n * let data = { one: 1, two: 2, three: 3 };\n *\n * each(values(data), value => { console.log(value); }); // 1, 2, 3\n * ```\n */\nexport function iterValues<T>(object: {\n  readonly [key: string]: T;\n}): IIterator<T> {\n  return new ValueIterator<T>(object);\n}\n\n/**\n * Create an iterator for the items in an object.\n *\n * @param object - The object of interest.\n *\n * @returns A new iterator for the items in the given object.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { each, items } from '@lumino/algorithm';\n *\n * let data = { one: 1, two: 2, three: 3 };\n *\n * each(items(data), value => { console.log(value); }); // ['one', 1], ['two', 2], ['three', 3]\n * ```\n */\nexport function iterItems<T>(object: {\n  readonly [key: string]: T;\n}): IIterator<[string, T]> {\n  return new ItemIterator<T>(object);\n}\n\n/**\n * Create an iterator for an iterator-like function.\n *\n * @param fn - A function which behaves like an iterator `next` method.\n *\n * @returns A new iterator for the given function.\n *\n * #### Notes\n * The returned iterator **cannot** be cloned.\n *\n * #### Example\n * ```typescript\n * import { each, iterFn } from '@lumino/algorithm';\n *\n * let it = iterFn((() => {\n *   let i = 0;\n *   return () => i > 3 ? undefined : i++;\n * })());\n *\n * each(it, v => { console.log(v); }); // 0, 1, 2, 3\n * ```\n */\nexport function iterFn<T>(fn: () => T | undefined): IIterator<T> {\n  return new FnIterator<T>(fn);\n}\n\n/**\n * Invoke a function for each value in an iterable.\n *\n * @param object - The iterable or array-like object of interest.\n *\n * @param fn - The callback function to invoke for each value.\n *\n * #### Notes\n * Iteration can be terminated early by returning `false` from the\n * callback function.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { each } from '@lumino/algorithm';\n *\n * let data = [5, 7, 0, -2, 9];\n *\n * each(data, value => { console.log(value); });\n * ```\n */\nexport function each<T>(\n  object: IterableOrArrayLike<T>,\n  fn: (value: T, index: number) => boolean | void\n): void {\n  let index = 0;\n  let it = iter(object);\n  let value: T | undefined;\n  while ((value = it.next()) !== undefined) {\n    if (fn(value, index++) === false) {\n      return;\n    }\n  }\n}\n\n/**\n * Test whether all values in an iterable satisfy a predicate.\n *\n * @param object - The iterable or array-like object of interest.\n *\n * @param fn - The predicate function to invoke for each value.\n *\n * @returns `true` if all values pass the test, `false` otherwise.\n *\n * #### Notes\n * Iteration terminates on the first `false` predicate result.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { every } from '@lumino/algorithm';\n *\n * let data = [5, 7, 1];\n *\n * every(data, value => value % 2 === 0);  // false\n * every(data, value => value % 2 === 1);  // true\n * ```\n */\nexport function every<T>(\n  object: IterableOrArrayLike<T>,\n  fn: (value: T, index: number) => boolean\n): boolean {\n  let index = 0;\n  let it = iter(object);\n  let value: T | undefined;\n  while ((value = it.next()) !== undefined) {\n    if (!fn(value, index++)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Test whether any value in an iterable satisfies a predicate.\n *\n * @param object - The iterable or array-like object of interest.\n *\n * @param fn - The predicate function to invoke for each value.\n *\n * @returns `true` if any value passes the test, `false` otherwise.\n *\n * #### Notes\n * Iteration terminates on the first `true` predicate result.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { some } from '@lumino/algorithm';\n *\n * let data = [5, 7, 1];\n *\n * some(data, value => value === 7);  // true\n * some(data, value => value === 3);  // false\n * ```\n */\nexport function some<T>(\n  object: IterableOrArrayLike<T>,\n  fn: (value: T, index: number) => boolean\n): boolean {\n  let index = 0;\n  let it = iter(object);\n  let value: T | undefined;\n  while ((value = it.next()) !== undefined) {\n    if (fn(value, index++)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Create an array from an iterable of values.\n *\n * @param object - The iterable or array-like object of interest.\n *\n * @returns A new array of values from the given object.\n *\n * #### Example\n * ```typescript\n * import { iter, toArray } from '@lumino/algorithm';\n *\n * let data = [1, 2, 3, 4, 5, 6];\n *\n * let stream = iter(data);\n *\n * toArray(stream);  // [1, 2, 3, 4, 5, 6];\n * ```\n */\nexport function toArray<T>(object: IterableOrArrayLike<T>): T[] {\n  let index = 0;\n  let result: T[] = [];\n  let it = iter(object);\n  let value: T | undefined;\n  while ((value = it.next()) !== undefined) {\n    result[index++] = value;\n  }\n  return result;\n}\n\n/**\n * Create an object from an iterable of key/value pairs.\n *\n * @param object - The iterable or array-like object of interest.\n *\n * @returns A new object mapping keys to values.\n *\n * #### Example\n * ```typescript\n * import { toObject } from '@lumino/algorithm';\n *\n * let data = [['one', 1], ['two', 2], ['three', 3]];\n *\n * toObject(data);  // { one: 1, two: 2, three: 3 }\n * ```\n */\nexport function toObject<T>(\n  object: IterableOrArrayLike<[string, T]>\n): { [key: string]: T } {\n  let it = iter(object);\n  let pair: [string, T] | undefined;\n  let result: { [key: string]: T } = {};\n  while ((pair = it.next()) !== undefined) {\n    result[pair[0]] = pair[1];\n  }\n  return result;\n}\n\n/**\n * An iterator for an array-like object.\n *\n * #### Notes\n * This iterator can be used for any builtin JS array-like object.\n */\nexport class ArrayIterator<T> implements IIterator<T> {\n  /**\n   * Construct a new array iterator.\n   *\n   * @param source - The array-like object of interest.\n   */\n  constructor(source: ArrayLike<T>) {\n    this._source = source;\n  }\n\n  /**\n   * Get an iterator over the object's values.\n   *\n   * @returns An iterator which yields the object's values.\n   */\n  iter(): IIterator<T> {\n    return this;\n  }\n\n  /**\n   * Create an independent clone of the iterator.\n   *\n   * @returns A new independent clone of the iterator.\n   */\n  clone(): IIterator<T> {\n    let result = new ArrayIterator<T>(this._source);\n    result._index = this._index;\n    return result;\n  }\n\n  /**\n   * Get the next value from the iterator.\n   *\n   * @returns The next value from the iterator, or `undefined`.\n   */\n  next(): T | undefined {\n    if (this._index >= this._source.length) {\n      return undefined;\n    }\n    return this._source[this._index++];\n  }\n\n  private _index = 0;\n  private _source: ArrayLike<T>;\n}\n\n/**\n * An iterator for the keys in an object.\n *\n * #### Notes\n * This iterator can be used for any JS object.\n */\nexport class KeyIterator implements IIterator<string> {\n  /**\n   * Construct a new key iterator.\n   *\n   * @param source - The object of interest.\n   *\n   * @param keys - The keys to iterate, if known.\n   */\n  constructor(\n    source: { readonly [key: string]: any },\n    keys = Object.keys(source)\n  ) {\n    this._source = source;\n    this._keys = keys;\n  }\n\n  /**\n   * Get an iterator over the object's values.\n   *\n   * @returns An iterator which yields the object's values.\n   */\n  iter(): IIterator<string> {\n    return this;\n  }\n\n  /**\n   * Create an independent clone of the iterator.\n   *\n   * @returns A new independent clone of the iterator.\n   */\n  clone(): IIterator<string> {\n    let result = new KeyIterator(this._source, this._keys);\n    result._index = this._index;\n    return result;\n  }\n\n  /**\n   * Get the next value from the iterator.\n   *\n   * @returns The next value from the iterator, or `undefined`.\n   */\n  next(): string | undefined {\n    if (this._index >= this._keys.length) {\n      return undefined;\n    }\n    let key = this._keys[this._index++];\n    if (key in this._source) {\n      return key;\n    }\n    return this.next();\n  }\n\n  private _index = 0;\n  private _keys: string[];\n  private _source: { readonly [key: string]: any };\n}\n\n/**\n * An iterator for the values in an object.\n *\n * #### Notes\n * This iterator can be used for any JS object.\n */\nexport class ValueIterator<T> implements IIterator<T> {\n  /**\n   * Construct a new value iterator.\n   *\n   * @param source - The object of interest.\n   *\n   * @param keys - The keys to iterate, if known.\n   */\n  constructor(\n    source: { readonly [key: string]: T },\n    keys = Object.keys(source)\n  ) {\n    this._source = source;\n    this._keys = keys;\n  }\n\n  /**\n   * Get an iterator over the object's values.\n   *\n   * @returns An iterator which yields the object's values.\n   */\n  iter(): IIterator<T> {\n    return this;\n  }\n\n  /**\n   * Create an independent clone of the iterator.\n   *\n   * @returns A new independent clone of the iterator.\n   */\n  clone(): IIterator<T> {\n    let result = new ValueIterator<T>(this._source, this._keys);\n    result._index = this._index;\n    return result;\n  }\n\n  /**\n   * Get the next value from the iterator.\n   *\n   * @returns The next value from the iterator, or `undefined`.\n   */\n  next(): T | undefined {\n    if (this._index >= this._keys.length) {\n      return undefined;\n    }\n    let key = this._keys[this._index++];\n    if (key in this._source) {\n      return this._source[key];\n    }\n    return this.next();\n  }\n\n  private _index = 0;\n  private _keys: string[];\n  private _source: { readonly [key: string]: T };\n}\n\n/**\n * An iterator for the items in an object.\n *\n * #### Notes\n * This iterator can be used for any JS object.\n */\nexport class ItemIterator<T> implements IIterator<[string, T]> {\n  /**\n   * Construct a new item iterator.\n   *\n   * @param source - The object of interest.\n   *\n   * @param keys - The keys to iterate, if known.\n   */\n  constructor(\n    source: { readonly [key: string]: T },\n    keys = Object.keys(source)\n  ) {\n    this._source = source;\n    this._keys = keys;\n  }\n\n  /**\n   * Get an iterator over the object's values.\n   *\n   * @returns An iterator which yields the object's values.\n   */\n  iter(): IIterator<[string, T]> {\n    return this;\n  }\n\n  /**\n   * Create an independent clone of the iterator.\n   *\n   * @returns A new independent clone of the iterator.\n   */\n  clone(): IIterator<[string, T]> {\n    let result = new ItemIterator<T>(this._source, this._keys);\n    result._index = this._index;\n    return result;\n  }\n\n  /**\n   * Get the next value from the iterator.\n   *\n   * @returns The next value from the iterator, or `undefined`.\n   */\n  next(): [string, T] | undefined {\n    if (this._index >= this._keys.length) {\n      return undefined;\n    }\n    let key = this._keys[this._index++];\n    if (key in this._source) {\n      return [key, this._source[key]];\n    }\n    return this.next();\n  }\n\n  private _index = 0;\n  private _keys: string[];\n  private _source: { readonly [key: string]: T };\n}\n\n/**\n * An iterator for an iterator-like function.\n */\nexport class FnIterator<T> implements IIterator<T> {\n  /**\n   * Construct a new function iterator.\n   *\n   * @param fn - The iterator-like function of interest.\n   */\n  constructor(fn: () => T | undefined) {\n    this._fn = fn;\n  }\n\n  /**\n   * Get an iterator over the object's values.\n   *\n   * @returns An iterator which yields the object's values.\n   */\n  iter(): IIterator<T> {\n    return this;\n  }\n\n  /**\n   * Create an independent clone of the iterator.\n   *\n   * @returns A new independent clone of the iterator.\n   */\n  clone(): IIterator<T> {\n    throw new Error('An `FnIterator` cannot be cloned.');\n  }\n\n  /**\n   * Get the next value from the iterator.\n   *\n   * @returns The next value from the iterator, or `undefined`.\n   */\n  next(): T | undefined {\n    return this._fn.call(undefined);\n  }\n\n  private _fn: () => T | undefined;\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { IIterator } from './iter';\n\n/**\n * Create an iterator of evenly spaced values.\n *\n * @param start - The starting value for the range, inclusive.\n *\n * @param stop - The stopping value for the range, exclusive.\n *\n * @param step - The distance between each value.\n *\n * @returns An iterator which produces evenly spaced values.\n *\n * #### Notes\n * In the single argument form of `range(stop)`, `start` defaults to\n * `0` and `step` defaults to `1`.\n *\n * In the two argument form of `range(start, stop)`, `step` defaults\n * to `1`.\n */\nexport function range(\n  start: number,\n  stop?: number,\n  step?: number\n): IIterator<number> {\n  if (stop === undefined) {\n    return new RangeIterator(0, start, 1);\n  }\n  if (step === undefined) {\n    return new RangeIterator(start, stop, 1);\n  }\n  return new RangeIterator(start, stop, step);\n}\n\n/**\n * An iterator which produces a range of evenly spaced values.\n */\nexport class RangeIterator implements IIterator<number> {\n  /**\n   * Construct a new range iterator.\n   *\n   * @param start - The starting value for the range, inclusive.\n   *\n   * @param stop - The stopping value for the range, exclusive.\n   *\n   * @param step - The distance between each value.\n   */\n  constructor(start: number, stop: number, step: number) {\n    this._start = start;\n    this._stop = stop;\n    this._step = step;\n    this._length = Private.rangeLength(start, stop, step);\n  }\n\n  /**\n   * Get an iterator over the object's values.\n   *\n   * @returns An iterator which yields the object's values.\n   */\n  iter(): IIterator<number> {\n    return this;\n  }\n\n  /**\n   * Create an independent clone of the iterator.\n   *\n   * @returns A new independent clone of the iterator.\n   */\n  clone(): IIterator<number> {\n    let result = new RangeIterator(this._start, this._stop, this._step);\n    result._index = this._index;\n    return result;\n  }\n\n  /**\n   * Get the next value from the iterator.\n   *\n   * @returns The next value from the iterator, or `undefined`.\n   */\n  next(): number | undefined {\n    if (this._index >= this._length) {\n      return undefined;\n    }\n    return this._start + this._step * this._index++;\n  }\n\n  private _index = 0;\n  private _length: number;\n  private _start: number;\n  private _stop: number;\n  private _step: number;\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * Compute the effective length of a range.\n   *\n   * @param start - The starting value for the range, inclusive.\n   *\n   * @param stop - The stopping value for the range, exclusive.\n   *\n   * @param step - The distance between each value.\n   *\n   * @returns The number of steps need to traverse the range.\n   */\n  export function rangeLength(\n    start: number,\n    stop: number,\n    step: number\n  ): number {\n    if (step === 0) {\n      return Infinity;\n    }\n    if (start > stop && step > 0) {\n      return 0;\n    }\n    if (start < stop && step < 0) {\n      return 0;\n    }\n    return Math.ceil((stop - start) / step);\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n\n/**\n * The namespace for string-specific algorithms.\n */\nexport namespace StringExt {\n  /**\n   * Find the indices of characters in a source text.\n   *\n   * @param source - The source text which should be searched.\n   *\n   * @param query - The characters to locate in the source text.\n   *\n   * @param start - The index to start the search.\n   *\n   * @returns The matched indices, or `null` if there is no match.\n   *\n   * #### Complexity\n   * Linear on `sourceText`.\n   *\n   * #### Notes\n   * In order for there to be a match, all of the characters in `query`\n   * **must** appear in `source` in the order given by `query`.\n   *\n   * Characters are matched using strict `===` equality.\n   */\n  export function findIndices(\n    source: string,\n    query: string,\n    start = 0\n  ): number[] | null {\n    let indices = new Array<number>(query.length);\n    for (let i = 0, j = start, n = query.length; i < n; ++i, ++j) {\n      j = source.indexOf(query[i], j);\n      if (j === -1) {\n        return null;\n      }\n      indices[i] = j;\n    }\n    return indices;\n  }\n\n  /**\n   * The result of a string match function.\n   */\n  export interface IMatchResult {\n    /**\n     * A score which indicates the strength of the match.\n     *\n     * The documentation of a given match function should specify\n     * whether a lower or higher score is a stronger match.\n     */\n    score: number;\n\n    /**\n     * The indices of the matched characters in the source text.\n     *\n     * The indices will appear in increasing order.\n     */\n    indices: number[];\n  }\n\n  /**\n   * A string matcher which uses a sum-of-squares algorithm.\n   *\n   * @param source - The source text which should be searched.\n   *\n   * @param query - The characters to locate in the source text.\n   *\n   * @param start - The index to start the search.\n   *\n   * @returns The match result, or `null` if there is no match.\n   *   A lower `score` represents a stronger match.\n   *\n   * #### Complexity\n   * Linear on `sourceText`.\n   *\n   * #### Notes\n   * This scoring algorithm uses a sum-of-squares approach to determine\n   * the score. In order for there to be a match, all of the characters\n   * in `query` **must** appear in `source` in order. The index of each\n   * matching character is squared and added to the score. This means\n   * that early and consecutive character matches are preferred, while\n   * late matches are heavily penalized.\n   */\n  export function matchSumOfSquares(\n    source: string,\n    query: string,\n    start = 0\n  ): IMatchResult | null {\n    let indices = findIndices(source, query, start);\n    if (!indices) {\n      return null;\n    }\n    let score = 0;\n    for (let i = 0, n = indices.length; i < n; ++i) {\n      let j = indices[i] - start;\n      score += j * j;\n    }\n    return { score, indices };\n  }\n\n  /**\n   * A string matcher which uses a sum-of-deltas algorithm.\n   *\n   * @param source - The source text which should be searched.\n   *\n   * @param query - The characters to locate in the source text.\n   *\n   * @param start - The index to start the search.\n   *\n   * @returns The match result, or `null` if there is no match.\n   *   A lower `score` represents a stronger match.\n   *\n   * #### Complexity\n   * Linear on `sourceText`.\n   *\n   * #### Notes\n   * This scoring algorithm uses a sum-of-deltas approach to determine\n   * the score. In order for there to be a match, all of the characters\n   * in `query` **must** appear in `source` in order. The delta between\n   * the indices are summed to create the score. This means that groups\n   * of matched characters are preferred, while fragmented matches are\n   * penalized.\n   */\n  export function matchSumOfDeltas(\n    source: string,\n    query: string,\n    start = 0\n  ): IMatchResult | null {\n    let indices = findIndices(source, query, start);\n    if (!indices) {\n      return null;\n    }\n    let score = 0;\n    let last = start - 1;\n    for (let i = 0, n = indices.length; i < n; ++i) {\n      let j = indices[i];\n      score += j - last - 1;\n      last = j;\n    }\n    return { score, indices };\n  }\n\n  /**\n   * Highlight the matched characters of a source text.\n   *\n   * @param source - The text which should be highlighted.\n   *\n   * @param indices - The indices of the matched characters. They must\n   *   appear in increasing order and must be in bounds of the source.\n   *\n   * @param fn - The function to apply to the matched chunks.\n   *\n   * @returns An array of unmatched and highlighted chunks.\n   */\n  export function highlight<T>(\n    source: string,\n    indices: ReadonlyArray<number>,\n    fn: (chunk: string) => T\n  ): Array<string | T> {\n    // Set up the result array.\n    let result: Array<string | T> = [];\n\n    // Set up the counter variables.\n    let k = 0;\n    let last = 0;\n    let n = indices.length;\n\n    // Iterator over each index.\n    while (k < n) {\n      // Set up the chunk indices.\n      let i = indices[k];\n      let j = indices[k];\n\n      // Advance the right chunk index until it's non-contiguous.\n      while (++k < n && indices[k] === j + 1) {\n        j++;\n      }\n\n      // Extract the unmatched text.\n      if (last < i) {\n        result.push(source.slice(last, i));\n      }\n\n      // Extract and highlight the matched text.\n      if (i < j + 1) {\n        result.push(fn(source.slice(i, j + 1)));\n      }\n\n      // Update the last visited index.\n      last = j + 1;\n    }\n\n    // Extract any remaining unmatched text.\n    if (last < source.length) {\n      result.push(source.slice(last));\n    }\n\n    // Return the highlighted result.\n    return result;\n  }\n\n  /**\n   * A 3-way string comparison function.\n   *\n   * @param a - The first string of interest.\n   *\n   * @param b - The second string of interest.\n   *\n   * @returns `-1` if `a < b`, else `1` if `a > b`, else `0`.\n   */\n  export function cmp(a: string, b: string): number {\n    return a < b ? -1 : a > b ? 1 : 0;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { findIndex, topologicSort } from '@lumino/algorithm';\n\nimport { CommandRegistry } from '@lumino/commands';\n\nimport { PromiseDelegate, Token } from '@lumino/coreutils';\n\nimport { ContextMenu, Menu, Widget } from '@lumino/widgets';\n\n/**\n * A user-defined application plugin.\n *\n * @typeparam T - The type for the application.\n *\n * @typeparam U - The service type, if the plugin `provides` one.\n *\n * #### Notes\n * Plugins are the foundation for building an extensible application.\n *\n * Plugins consume and provide \"services\", which are nothing more than\n * concrete implementations of interfaces and/or abstract types.\n *\n * Unlike regular imports and exports, which tie the service consumer\n * to a particular implementation of the service, plugins decouple the\n * service producer from the service consumer, allowing an application\n * to be easily customized by third parties in a type-safe fashion.\n */\nexport interface IPlugin<T extends Application, U> {\n  /**\n   * The human readable ID of the plugin.\n   *\n   * #### Notes\n   * This must be unique within an application.\n   */\n  id: string;\n\n  /**\n   * Plugin description.\n   *\n   * #### Notes\n   * This can be used to provide user documentation on the feature\n   * brought by a plugin.\n   */\n  description?: string;\n\n  /**\n   * Whether the plugin should be activated on application start.\n   *\n   * #### Notes\n   * The default is `false`.\n   */\n  autoStart?: boolean;\n\n  /**\n   * The types of required services for the plugin, if any.\n   *\n   * #### Notes\n   * These tokens correspond to the services that are required by\n   * the plugin for correct operation.\n   *\n   * When the plugin is activated, a concrete instance of each type\n   * will be passed to the `activate()` function, in the order they\n   * are specified in the `requires` array.\n   */\n  requires?: Token<any>[];\n\n  /**\n   * The types of optional services for the plugin, if any.\n   *\n   * #### Notes\n   * These tokens correspond to the services that can be used by the\n   * plugin if available, but are not necessarily required.\n   *\n   * The optional services will be passed to the `activate()` function\n   * following all required services. If an optional service cannot be\n   * resolved, `null` will be passed in its place.\n   */\n  optional?: Token<any>[];\n\n  /**\n   * The type of service provided by the plugin, if any.\n   *\n   * #### Notes\n   * This token corresponds to the service exported by the plugin.\n   *\n   * When the plugin is activated, the return value of `activate()`\n   * is used as the concrete instance of the type.\n   */\n  provides?: Token<U> | null;\n\n  /**\n   * A function invoked to activate the plugin.\n   *\n   * @param app - The application which owns the plugin.\n   *\n   * @param args - The services specified by the `requires` property.\n   *\n   * @returns The provided service, or a promise to the service.\n   *\n   * #### Notes\n   * This function will be called whenever the plugin is manually\n   * activated, or when another plugin being activated requires\n   * the service it provides.\n   *\n   * This function will not be called unless all of its required\n   * services can be fulfilled.\n   */\n  activate: (app: T, ...args: any[]) => U | Promise<U>;\n\n  /**\n   * A function invoked to deactivate the plugin.\n   *\n   * @param app - The application which owns the plugin.\n   *\n   * @param args - The services specified by the `requires` property.\n   */\n  deactivate?: ((app: T, ...args: Token<any>[]) => void | Promise<void>) | null;\n}\n\n/**\n * A class for creating pluggable applications.\n *\n * @typeparam T - The type of the application shell.\n *\n * #### Notes\n * The `Application` class is useful when creating large, complex\n * UI applications with the ability to be safely extended by third\n * party code via plugins.\n */\nexport class Application<T extends Widget = Widget> {\n  /**\n   * Construct a new application.\n   *\n   * @param options - The options for creating the application.\n   */\n  constructor(options: Application.IOptions<T>) {\n    // Initialize the application state.\n    this.commands = new CommandRegistry();\n    this.contextMenu = new ContextMenu({\n      commands: this.commands,\n      renderer: options.contextMenuRenderer\n    });\n    this.shell = options.shell;\n  }\n\n  /**\n   * The application command registry.\n   */\n  readonly commands: CommandRegistry;\n\n  /**\n   * The application context menu.\n   */\n  readonly contextMenu: ContextMenu;\n\n  /**\n   * The application shell widget.\n   *\n   * #### Notes\n   * The shell widget is the root \"container\" widget for the entire\n   * application. It will typically expose an API which allows the\n   * application plugins to insert content in a variety of places.\n   */\n  readonly shell: T;\n\n  /**\n   * A promise which resolves after the application has started.\n   *\n   * #### Notes\n   * This promise will resolve after the `start()` method is called,\n   * when all the bootstrapping and shell mounting work is complete.\n   */\n  get started(): Promise<void> {\n    return this._delegate.promise;\n  }\n\n  /**\n   * Get a plugin description.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @returns The plugin description.\n   */\n  getPluginDescription(id: string): string {\n    const plugin = this._pluginMap[id];\n    return plugin ? plugin.description || '' : '';\n  }\n\n  /**\n   * Test whether a plugin is registered with the application.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @returns `true` if the plugin is registered, `false` otherwise.\n   */\n  hasPlugin(id: string): boolean {\n    return id in this._pluginMap;\n  }\n\n  /**\n   * Test whether a plugin is activated with the application.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @returns `true` if the plugin is activated, `false` otherwise.\n   */\n  isPluginActivated(id: string): boolean {\n    const plugin = this._pluginMap[id];\n    return plugin ? plugin.activated : false;\n  }\n\n  /**\n   * List the IDs of the plugins registered with the application.\n   *\n   * @returns A new array of the registered plugin IDs.\n   */\n  listPlugins(): string[] {\n    return Object.keys(this._pluginMap);\n  }\n\n  /**\n   * Register a plugin with the application.\n   *\n   * @param plugin - The plugin to register.\n   *\n   * #### Notes\n   * An error will be thrown if a plugin with the same ID is already\n   * registered, or if the plugin has a circular dependency.\n   *\n   * If the plugin provides a service which has already been provided\n   * by another plugin, the new service will override the old service.\n   */\n  registerPlugin(plugin: IPlugin<this, any>): void {\n    // Throw an error if the plugin id is already registered.\n    if (plugin.id in this._pluginMap) {\n      throw new Error(`Plugin '${plugin.id}' is already registered.`);\n    }\n\n    // Create the normalized plugin data.\n    const data = Private.createPluginData(plugin);\n\n    // Ensure the plugin does not cause a cyclic dependency.\n    Private.ensureNoCycle(data, this._pluginMap, this._serviceMap);\n\n    // Add the service token to the service map.\n    if (data.provides) {\n      this._serviceMap.set(data.provides, data.id);\n    }\n\n    // Add the plugin to the plugin map.\n    this._pluginMap[data.id] = data;\n  }\n\n  /**\n   * Register multiple plugins with the application.\n   *\n   * @param plugins - The plugins to register.\n   *\n   * #### Notes\n   * This calls `registerPlugin()` for each of the given plugins.\n   */\n  registerPlugins(plugins: IPlugin<this, any>[]): void {\n    for (const plugin of plugins) {\n      this.registerPlugin(plugin);\n    }\n  }\n\n  /**\n   * Deregister a plugin with the application.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @param force - Whether to deregister the plugin even if it is active.\n   */\n  deregisterPlugin(id: string, force?: boolean): void {\n    const plugin = this._pluginMap[id];\n    if (!plugin) {\n      return;\n    }\n\n    if (plugin.activated && !force) {\n      throw new Error(`Plugin '${id}' is still active.`);\n    }\n\n    delete this._pluginMap[id];\n  }\n\n  /**\n   * Activate the plugin with the given ID.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @returns A promise which resolves when the plugin is activated\n   *   or rejects with an error if it cannot be activated.\n   */\n  async activatePlugin(id: string): Promise<void> {\n    // Reject the promise if the plugin is not registered.\n    const plugin = this._pluginMap[id];\n    if (!plugin) {\n      return Promise.reject(new Error(`Plugin '${id}' is not registered.`));\n    }\n\n    // Resolve immediately if the plugin is already activated.\n    if (plugin.activated) {\n      return;\n    }\n\n    // Return the pending resolver promise if it exists.\n    if (plugin.promise) {\n      return plugin.promise;\n    }\n\n    // Resolve the required services for the plugin.\n    const required = plugin.requires.map(t => this.resolveRequiredService(t));\n\n    // Resolve the optional services for the plugin.\n    const optional = plugin.optional.map(t => this.resolveOptionalService(t));\n\n    // Setup the resolver promise for the plugin.\n    plugin.promise = Promise.all([...required, ...optional])\n      .then(services => plugin!.activate.apply(undefined, [this, ...services]))\n      .then(service => {\n        plugin!.service = service;\n        plugin!.activated = true;\n        plugin!.promise = null;\n      })\n      .catch(error => {\n        plugin!.promise = null;\n        throw error;\n      });\n\n    // Return the pending resolver promise.\n    return plugin.promise;\n  }\n\n  /**\n   * Deactivate the plugin and its downstream dependents if and only if the\n   * plugin and its dependents all support `deactivate`.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @returns A list of IDs of downstream plugins deactivated with this one.\n   */\n  async deactivatePlugin(id: string): Promise<string[]> {\n    // Reject the promise if the plugin is not registered.\n    const plugin = this._pluginMap[id];\n    if (!plugin) {\n      throw new ReferenceError(`Plugin '${id}' is not registered.`);\n    }\n\n    // Bail early if the plugin is not activated.\n    if (!plugin.activated) {\n      return [];\n    }\n\n    // Check that this plugin can deactivate.\n    if (!plugin.deactivate) {\n      throw new TypeError(`Plugin '${id}'#deactivate() method missing`);\n    }\n\n    // Find the optimal deactivation order for plugins downstream of this one.\n    const manifest = Private.findDependents(\n      id,\n      this._pluginMap,\n      this._serviceMap\n    );\n    const downstream = manifest.map(id => this._pluginMap[id]!);\n\n    // Check that all downstream plugins can deactivate.\n    for (const plugin of downstream) {\n      if (!plugin.deactivate) {\n        throw new TypeError(\n          `Plugin ${plugin.id}#deactivate() method missing (depends on ${id})`\n        );\n      }\n    }\n\n    // Deactivate all downstream plugins.\n    for (const plugin of downstream) {\n      const services = [...plugin.requires, ...plugin.optional].map(service => {\n        const id = this._serviceMap.get(service);\n        return id ? this._pluginMap[id]!.service : null;\n      });\n\n      // Await deactivation so the next plugins only receive active services.\n      await plugin.deactivate!(this, ...services);\n      plugin.service = null;\n      plugin.activated = false;\n    }\n\n    // Remove plugin ID and return manifest of deactivated plugins.\n    manifest.pop();\n    return manifest;\n  }\n\n  /**\n   * Resolve a required service of a given type.\n   *\n   * @param token - The token for the service type of interest.\n   *\n   * @returns A promise which resolves to an instance of the requested\n   *   service, or rejects with an error if it cannot be resolved.\n   *\n   * #### Notes\n   * Services are singletons. The same instance will be returned each\n   * time a given service token is resolved.\n   *\n   * If the plugin which provides the service has not been activated,\n   * resolving the service will automatically activate the plugin.\n   *\n   * User code will not typically call this method directly. Instead,\n   * the required services for the user's plugins will be resolved\n   * automatically when the plugin is activated.\n   */\n  async resolveRequiredService<U>(token: Token<U>): Promise<U> {\n    // Reject the promise if there is no provider for the type.\n    const id = this._serviceMap.get(token);\n    if (!id) {\n      return Promise.reject(new Error(`No provider for: ${token.name}.`));\n    }\n\n    // Activate the plugin if necessary.\n    const plugin = this._pluginMap[id]!;\n    if (!plugin.activated) {\n      await this.activatePlugin(id);\n    }\n\n    return plugin.service;\n  }\n\n  /**\n   * Resolve an optional service of a given type.\n   *\n   * @param token - The token for the service type of interest.\n   *\n   * @returns A promise which resolves to an instance of the requested\n   *   service, or `null` if it cannot be resolved.\n   *\n   * #### Notes\n   * Services are singletons. The same instance will be returned each\n   * time a given service token is resolved.\n   *\n   * If the plugin which provides the service has not been activated,\n   * resolving the service will automatically activate the plugin.\n   *\n   * User code will not typically call this method directly. Instead,\n   * the optional services for the user's plugins will be resolved\n   * automatically when the plugin is activated.\n   */\n  async resolveOptionalService<U>(token: Token<U>): Promise<U | null> {\n    // Resolve with `null` if there is no provider for the type.\n    const id = this._serviceMap.get(token);\n    if (!id) {\n      return null;\n    }\n\n    // Activate the plugin if necessary.\n    const plugin = this._pluginMap[id]!;\n    if (!plugin.activated) {\n      try {\n        await this.activatePlugin(id);\n      } catch (reason) {\n        console.error(reason);\n        return null;\n      }\n    }\n\n    return plugin.service;\n  }\n\n  /**\n   * Start the application.\n   *\n   * @param options - The options for starting the application.\n   *\n   * @returns A promise which resolves when all bootstrapping work\n   *   is complete and the shell is mounted to the DOM.\n   *\n   * #### Notes\n   * This should be called once by the application creator after all\n   * initial plugins have been registered.\n   *\n   * If a plugin fails to the load, the error will be logged and the\n   * other valid plugins will continue to be loaded.\n   *\n   * Bootstrapping the application consists of the following steps:\n   * 1. Activate the startup plugins\n   * 2. Wait for those plugins to activate\n   * 3. Attach the shell widget to the DOM\n   * 4. Add the application event listeners\n   */\n  start(options: Application.IStartOptions = {}): Promise<void> {\n    // Return immediately if the application is already started.\n    if (this._started) {\n      return this._delegate.promise;\n    }\n\n    // Mark the application as started;\n    this._started = true;\n\n    // Parse the host ID for attaching the shell.\n    const hostID = options.hostID || '';\n\n    // Collect the ids of the startup plugins.\n    const startups = Private.collectStartupPlugins(this._pluginMap, options);\n\n    // Generate the activation promises.\n    const promises = startups.map(id => {\n      return this.activatePlugin(id).catch(error => {\n        console.error(`Plugin '${id}' failed to activate.`);\n        console.error(error);\n      });\n    });\n\n    // Wait for the plugins to activate, then finalize startup.\n    Promise.all(promises).then(() => {\n      this.attachShell(hostID);\n      this.addEventListeners();\n      this._delegate.resolve(undefined);\n    });\n\n    // Return the pending delegate promise.\n    return this._delegate.promise;\n  }\n\n  /**\n   * Handle the DOM events for the application.\n   *\n   * @param event - The DOM event sent to the application.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events registered for the application. It\n   * should not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'resize':\n        this.evtResize(event);\n        break;\n      case 'keydown':\n        this.evtKeydown(event as KeyboardEvent);\n        break;\n      case 'contextmenu':\n        this.evtContextMenu(event as MouseEvent);\n        break;\n    }\n  }\n\n  /**\n   * Attach the application shell to the DOM.\n   *\n   * @param id - The ID of the host node for the shell, or `''`.\n   *\n   * #### Notes\n   * If the ID is not provided, the document body will be the host.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected attachShell(id: string): void {\n    Widget.attach(\n      this.shell,\n      (id && document.getElementById(id)) || document.body\n    );\n  }\n\n  /**\n   * Add the application event listeners.\n   *\n   * #### Notes\n   * The default implementation of this method adds listeners for\n   * `'keydown'` and `'resize'` events.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected addEventListeners(): void {\n    document.addEventListener('contextmenu', this);\n    document.addEventListener('keydown', this, true);\n    window.addEventListener('resize', this);\n  }\n\n  /**\n   * A method invoked on a document `'keydown'` event.\n   *\n   * #### Notes\n   * The default implementation of this method invokes the key down\n   * processing method of the application command registry.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected evtKeydown(event: KeyboardEvent): void {\n    this.commands.processKeydownEvent(event);\n  }\n\n  /**\n   * A method invoked on a document `'contextmenu'` event.\n   *\n   * #### Notes\n   * The default implementation of this method opens the application\n   * `contextMenu` at the current mouse position.\n   *\n   * If the application context menu has no matching content *or* if\n   * the shift key is pressed, the default browser context menu will\n   * be opened instead.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected evtContextMenu(event: MouseEvent): void {\n    if (event.shiftKey) {\n      return;\n    }\n    if (this.contextMenu.open(event)) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n\n  /**\n   * A method invoked on a window `'resize'` event.\n   *\n   * #### Notes\n   * The default implementation of this method updates the shell.\n   *\n   * A subclass may reimplement this method as needed.\n   */\n  protected evtResize(event: Event): void {\n    this.shell.update();\n  }\n\n  private _started = false;\n  private _pluginMap = Private.createPluginMap();\n  private _serviceMap = Private.createServiceMap();\n  private _delegate = new PromiseDelegate<void>();\n}\n\n/**\n * The namespace for the `Application` class statics.\n */\nexport namespace Application {\n  /**\n   * An options object for creating an application.\n   */\n  export interface IOptions<T extends Widget> {\n    /**\n     * The shell widget to use for the application.\n     *\n     * This should be a newly created and initialized widget.\n     *\n     * The application will attach the widget to the DOM.\n     */\n    shell: T;\n\n    /**\n     * A custom renderer for the context menu.\n     */\n    contextMenuRenderer?: Menu.IRenderer;\n  }\n\n  /**\n   * An options object for application startup.\n   */\n  export interface IStartOptions {\n    /**\n     * The ID of the DOM node to host the application shell.\n     *\n     * #### Notes\n     * If this is not provided, the document body will be the host.\n     */\n    hostID?: string;\n\n    /**\n     * The plugins to activate on startup.\n     *\n     * #### Notes\n     * These will be *in addition* to any `autoStart` plugins.\n     */\n    startPlugins?: string[];\n\n    /**\n     * The plugins to **not** activate on startup.\n     *\n     * #### Notes\n     * This will override `startPlugins` and any `autoStart` plugins.\n     */\n    ignorePlugins?: string[];\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * An object which holds the full application state for a plugin.\n   */\n  export interface IPluginData {\n    /**\n     * The human readable ID of the plugin.\n     */\n    readonly id: string;\n\n    /**\n     * The description of the plugin.\n     */\n    readonly description: string;\n\n    /**\n     * Whether the plugin should be activated on application start.\n     */\n    readonly autoStart: boolean;\n\n    /**\n     * The types of required services for the plugin, or `[]`.\n     */\n    readonly requires: Token<any>[];\n\n    /**\n     * The types of optional services for the the plugin, or `[]`.\n     */\n    readonly optional: Token<any>[];\n\n    /**\n     * The type of service provided by the plugin, or `null`.\n     */\n    readonly provides: Token<any> | null;\n\n    /**\n     * The function which activates the plugin.\n     */\n    readonly activate: (app: any, ...args: any[]) => any;\n\n    /**\n     * The optional function which deactivates the plugin.\n     */\n    readonly deactivate:\n      | ((app: Application, ...args: any[]) => void | Promise<void>)\n      | null;\n\n    /**\n     * Whether the plugin has been activated.\n     */\n    activated: boolean;\n\n    /**\n     * The resolved service for the plugin, or `null`.\n     */\n    service: any | null;\n\n    /**\n     * The pending resolver promise, or `null`.\n     */\n    promise: Promise<void> | null;\n  }\n\n  /**\n   * A type alias for a mapping of plugin id to plugin data.\n   */\n  export type PluginMap = { [id: string]: IPluginData };\n\n  /**\n   * A type alias for a mapping of service token to plugin id.\n   */\n  export type ServiceMap = Map<Token<any>, string>;\n\n  /**\n   * Create a new plugin map.\n   */\n  export function createPluginMap(): PluginMap {\n    return Object.create(null);\n  }\n\n  /**\n   * Create a new service map.\n   */\n  export function createServiceMap(): ServiceMap {\n    return new Map<Token<any>, string>();\n  }\n\n  /**\n   * Create a normalized plugin data object for the given plugin.\n   */\n  export function createPluginData(plugin: IPlugin<any, any>): IPluginData {\n    return {\n      id: plugin.id,\n      description: plugin.description || '',\n      service: null,\n      promise: null,\n      activated: false,\n      activate: plugin.activate,\n      deactivate: plugin.deactivate || null,\n      provides: plugin.provides || null,\n      autoStart: plugin.autoStart || false,\n      requires: plugin.requires ? plugin.requires.slice() : [],\n      optional: plugin.optional ? plugin.optional.slice() : []\n    };\n  }\n\n  /**\n   * Ensure no cycle is present in the plugin resolution graph.\n   *\n   * If a cycle is detected, an error will be thrown.\n   */\n  export function ensureNoCycle(\n    plugin: IPluginData,\n    plugins: PluginMap,\n    services: ServiceMap\n  ): void {\n    const dependencies = [...plugin.requires, ...plugin.optional];\n    const visit = (token: Token<any>): boolean => {\n      if (token === plugin.provides) {\n        return true;\n      }\n      const id = services.get(token);\n      if (!id) {\n        return false;\n      }\n      const visited = plugins[id]!;\n      const dependencies = [...visited.requires, ...visited.optional];\n      if (dependencies.length === 0) {\n        return false;\n      }\n      trace.push(id);\n      if (dependencies.some(visit)) {\n        return true;\n      }\n      trace.pop();\n      return false;\n    };\n\n    // Bail early if there cannot be a cycle.\n    if (!plugin.provides || dependencies.length === 0) {\n      return;\n    }\n\n    // Setup a stack to trace service resolution.\n    const trace = [plugin.id];\n\n    // Throw an exception if a cycle is present.\n    if (dependencies.some(visit)) {\n      throw new Error(`Cycle detected: ${trace.join(' -> ')}.`);\n    }\n  }\n\n  /**\n   * Find dependents in deactivation order.\n   *\n   * @param id - The ID of the plugin of interest.\n   *\n   * @param plugins - The map containing all plugins.\n   *\n   * @param services - The map containing all services.\n   *\n   * @returns A list of dependent plugin IDs in order of deactivation\n   *\n   * #### Notes\n   * The final item of the returned list is always the plugin of interest.\n   */\n  export function findDependents(\n    id: string,\n    plugins: PluginMap,\n    services: ServiceMap\n  ): string[] {\n    const edges = new Array<[string, string]>();\n    const add = (id: string): void => {\n      const plugin = plugins[id]!;\n      // FIXME In the case of missing optional dependencies, we may consider\n      // deactivating and reactivating the plugin without the missing service.\n      const dependencies = [...plugin.requires, ...plugin.optional];\n      edges.push(\n        ...dependencies.reduce<[string, string][]>((acc, dep) => {\n          const service = services.get(dep);\n          if (service) {\n            // An edge is oriented from dependent to provider.\n            acc.push([id, service]);\n          }\n          return acc;\n        }, [])\n      );\n    };\n\n    for (const id in plugins) {\n      add(id);\n    }\n\n    const sorted = topologicSort(edges);\n    const index = findIndex(sorted, candidate => candidate === id);\n\n    if (index === -1) {\n      return [id];\n    }\n\n    return sorted.slice(0, index + 1);\n  }\n\n  /**\n   * Collect the IDs of the plugins to activate on startup.\n   */\n  export function collectStartupPlugins(\n    pluginMap: PluginMap,\n    options: Application.IStartOptions\n  ): string[] {\n    // Create a map to hold the plugin IDs.\n    const collection = new Map<string, boolean>();\n\n    // Collect the auto-start plugins.\n    for (const id in pluginMap) {\n      if (pluginMap[id].autoStart) {\n        collection.set(id, true);\n      }\n    }\n\n    // Add the startup plugins.\n    if (options.startPlugins) {\n      for (const id of options.startPlugins) {\n        collection.set(id, true);\n      }\n    }\n\n    // Remove the ignored plugins.\n    if (options.ignorePlugins) {\n      for (const id of options.ignorePlugins) {\n        collection.delete(id);\n      }\n    }\n\n    // Return the collected startup plugins.\n    return Array.from(collection.keys());\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { each, IterableOrArrayLike } from './iter';\n\n/**\n * Topologically sort an iterable of edges.\n *\n * @param edges - The iterable or array-like object of edges to sort.\n *   An edge is represented as a 2-tuple of `[fromNode, toNode]`.\n *\n * @returns The topologically sorted array of nodes.\n *\n * #### Notes\n * If a cycle is present in the graph, the cycle will be ignored and\n * the return value will be only approximately sorted.\n *\n * #### Example\n * ```typescript\n * import { topologicSort } from '@lumino/algorithm';\n *\n * let data = [\n *   ['d', 'e'],\n *   ['c', 'd'],\n *   ['a', 'b'],\n *   ['b', 'c']\n * ];\n *\n * topologicSort(data);  // ['a', 'b', 'c', 'd', 'e']\n * ```\n */\nexport function topologicSort<T>(edges: IterableOrArrayLike<[T, T]>): T[] {\n  // Setup the shared sorting state.\n  let sorted: T[] = [];\n  let visited = new Set<T>();\n  let graph = new Map<T, T[]>();\n\n  // Add the edges to the graph.\n  each(edges, addEdge);\n\n  // Visit each node in the graph.\n  graph.forEach((v, k) => {\n    visit(k);\n  });\n\n  // Return the sorted results.\n  return sorted;\n\n  // Add an edge to the graph.\n  function addEdge(edge: [T, T]): void {\n    let [fromNode, toNode] = edge;\n    let children = graph.get(toNode);\n    if (children) {\n      children.push(fromNode);\n    } else {\n      graph.set(toNode, [fromNode]);\n    }\n  }\n\n  // Recursively visit the node.\n  function visit(node: T): void {\n    if (visited.has(node)) {\n      return;\n    }\n    visited.add(node);\n    let children = graph.get(node);\n    if (children) {\n      children.forEach(visit);\n    }\n    sorted.push(node);\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { iter, IterableOrArrayLike } from './iter';\n\n/**\n * Find the first value in an iterable which matches a predicate.\n *\n * @param object - The iterable or array-like object to search.\n *\n * @param fn - The predicate function to apply to the values.\n *\n * @returns The first matching value, or `undefined` if no matching\n *   value is found.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { find } from '@lumino/algorithm';\n *\n * interface IAnimal { species: string, name: string };\n *\n * function isCat(value: IAnimal): boolean {\n *   return value.species === 'cat';\n * }\n *\n * let data: IAnimal[] = [\n *   { species: 'dog', name: 'spot' },\n *   { species: 'cat', name: 'fluffy' },\n *   { species: 'alligator', name: 'pocho' }\n * ];\n *\n * find(data, isCat).name;  // 'fluffy'\n * ```\n */\nexport function find<T>(\n  object: IterableOrArrayLike<T>,\n  fn: (value: T, index: number) => boolean\n): T | undefined {\n  let index = 0;\n  let it = iter(object);\n  let value: T | undefined;\n  while ((value = it.next()) !== undefined) {\n    if (fn(value, index++)) {\n      return value;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Find the index of the first value which matches a predicate.\n *\n * @param object - The iterable or array-like object to search.\n *\n * @param fn - The predicate function to apply to the values.\n *\n * @returns The index of the first matching value, or `-1` if no\n *   matching value is found.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { findIndex } from '@lumino/algorithm';\n *\n * interface IAnimal { species: string, name: string };\n *\n * function isCat(value: IAnimal): boolean {\n *   return value.species === 'cat';\n * }\n *\n * let data: IAnimal[] = [\n *   { species: 'dog', name: 'spot' },\n *   { species: 'cat', name: 'fluffy' },\n *   { species: 'alligator', name: 'pocho' }\n * ];\n *\n * findIndex(data, isCat);  // 1\n * ```\n */\nexport function findIndex<T>(\n  object: IterableOrArrayLike<T>,\n  fn: (value: T, index: number) => boolean\n): number {\n  let index = 0;\n  let it = iter(object);\n  let value: T | undefined;\n  while ((value = it.next()) !== undefined) {\n    if (fn(value, index++)) {\n      return index - 1;\n    }\n  }\n  return -1;\n}\n\n/**\n * Find the minimum value in an iterable.\n *\n * @param object - The iterable or array-like object to search.\n *\n * @param fn - The 3-way comparison function to apply to the values.\n *   It should return `< 0` if the first value is less than the second.\n *   `0` if the values are equivalent, or `> 0` if the first value is\n *   greater than the second.\n *\n * @returns The minimum value in the iterable. If multiple values are\n *   equivalent to the minimum, the left-most value is returned. If\n *   the iterable is empty, this returns `undefined`.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { min } from '@lumino/algorithm';\n *\n * function numberCmp(a: number, b: number): number {\n *   return a - b;\n * }\n *\n * min([7, 4, 0, 3, 9, 4], numberCmp);  // 0\n * ```\n */\nexport function min<T>(\n  object: IterableOrArrayLike<T>,\n  fn: (first: T, second: T) => number\n): T | undefined {\n  let it = iter(object);\n  let value = it.next();\n  if (value === undefined) {\n    return undefined;\n  }\n  let result = value;\n  while ((value = it.next()) !== undefined) {\n    if (fn(value, result) < 0) {\n      result = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Find the maximum value in an iterable.\n *\n * @param object - The iterable or array-like object to search.\n *\n * @param fn - The 3-way comparison function to apply to the values.\n *   It should return `< 0` if the first value is less than the second.\n *   `0` if the values are equivalent, or `> 0` if the first value is\n *   greater than the second.\n *\n * @returns The maximum value in the iterable. If multiple values are\n *   equivalent to the maximum, the left-most value is returned. If\n *   the iterable is empty, this returns `undefined`.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { max } from '@lumino/algorithm';\n *\n * function numberCmp(a: number, b: number): number {\n *   return a - b;\n * }\n *\n * max([7, 4, 0, 3, 9, 4], numberCmp);  // 9\n * ```\n */\nexport function max<T>(\n  object: IterableOrArrayLike<T>,\n  fn: (first: T, second: T) => number\n): T | undefined {\n  let it = iter(object);\n  let value = it.next();\n  if (value === undefined) {\n    return undefined;\n  }\n  let result = value;\n  while ((value = it.next()) !== undefined) {\n    if (fn(value, result) > 0) {\n      result = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Find the minimum and maximum values in an iterable.\n *\n * @param object - The iterable or array-like object to search.\n *\n * @param fn - The 3-way comparison function to apply to the values.\n *   It should return `< 0` if the first value is less than the second.\n *   `0` if the values are equivalent, or `> 0` if the first value is\n *   greater than the second.\n *\n * @returns A 2-tuple of the `[min, max]` values in the iterable. If\n *   multiple values are equivalent, the left-most values are returned.\n *   If the iterable is empty, this returns `undefined`.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { minmax } from '@lumino/algorithm';\n *\n * function numberCmp(a: number, b: number): number {\n *   return a - b;\n * }\n *\n * minmax([7, 4, 0, 3, 9, 4], numberCmp);  // [0, 9]\n * ```\n */\nexport function minmax<T>(\n  object: IterableOrArrayLike<T>,\n  fn: (first: T, second: T) => number\n): [T, T] | undefined {\n  let it = iter(object);\n  let value = it.next();\n  if (value === undefined) {\n    return undefined;\n  }\n  let vmin = value;\n  let vmax = value;\n  while ((value = it.next()) !== undefined) {\n    if (fn(value, vmin) < 0) {\n      vmin = value;\n    } else if (fn(value, vmax) > 0) {\n      vmax = value;\n    }\n  }\n  return [vmin, vmax];\n}\n"],"names":["ArrayExt","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","Symbol","iterator","this","n","v","op","TypeError","call","pop","length","push","__spreadArrays","s","i","il","arguments","r","Array","k","a","j","jl","iter","object","ArrayIterator","firstIndexOf","array","start","stop","span","Math","max","min","lastIndexOf","findFirstIndex","fn","findLastIndex","d","reverse","b","removeAt","index","findFirstValue","undefined","findLastValue","lowerBound","begin","half","middle","upperBound","shallowEqual","slice","options","Error","floor","move","fromIndex","toIndex","rotate","delta","pivot","fill","insert","removeFirstOf","removeLastOf","removeAllOf","count","removeFirstWhere","removeLastWhere","removeAllWhere","Private","StringExt","source","_index","_source","clone","rangeLength","Infinity","ceil","findIndices","query","indices","indexOf","matchSumOfSquares","score","matchSumOfDeltas","last","highlight","cmp","_started","_pluginMap","createPluginMap","_serviceMap","createServiceMap","_delegate","PromiseDelegate","commands","CommandRegistry","contextMenu","ContextMenu","renderer","contextMenuRenderer","shell","promise","getPluginDescription","id","plugin","description","hasPlugin","isPluginActivated","activated","listPlugins","Object","keys","registerPlugin","data","createPluginData","ensureNoCycle","provides","set","registerPlugins","plugins","deregisterPlugin","force","activatePlugin","required","requires","map","resolveRequiredService","optional","resolveOptionalService","all","services","activate","service","catch","error","deactivatePlugin","ReferenceError","deactivate","manifest","findDependents","downstream","get","token","name","console","hostID","promises","collectStartupPlugins","attachShell","addEventListeners","handleEvent","event","type","evtResize","evtKeydown","evtContextMenu","Widget","document","getElementById","addEventListener","window","processKeydownEvent","shiftKey","open","preventDefault","stopPropagation","update","create","Map","autoStart","dependencies","visit","visited","trace","some","join","edges","add","reduce","acc","dep","sorted","Set","graph","it","fromNode","toNode","children","edge","each","forEach","node","has","topologicSort","findIndex","pluginMap","collection","startPlugins","ignorePlugins","delete","from"],"sourceRoot":""}