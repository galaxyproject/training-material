{"version":3,"file":"2887.cdee592.js","mappings":"sMAOO,MAAMA,EAAY,IAAI,EAAAC,MAAiB,kC,0BCQvC,MAAMC,EAMXC,YAAYC,GA4HJ,KAAAC,UAA8B,GA3HpCC,KAAKC,SAAWH,EAAQI,OAC1B,CAOAC,UAAUC,GACR,MAAMC,EAAUL,KAAKD,UAAUO,MAAMC,GAAMA,EAAEH,KAAOA,IACpD,IAAKC,EACH,MAAMG,MAAM,WAAWJ,eAEzB,OAAOC,CACT,CAKAF,aACE,OAAOH,KAAKD,SACd,CAWAI,YAAYL,GACV,MAAM,GAAEM,EAAE,KAAEK,EAAI,KAAEC,EAAI,OAAEC,GAAWb,EAC7Bc,EAAQZ,KAAKD,UAAUc,WAAWN,GAAMA,EAAEH,KAAOA,IACjDC,EAAUL,KAAKD,UAAUa,GAC/B,IAAKP,EACH,MAAMG,MAAM,WAAWJ,eAEzB,MAAMU,EAAU,IACXT,EACHI,KAAMA,QAAAA,EAAQJ,EAAQI,KACtBC,KAAMA,QAAAA,EAAQL,EAAQK,MAGxB,GAAIC,EAEF,GAAIA,EAAOP,GAAI,CACb,MAAMC,EAAUL,KAAKD,UAAUO,MAC5BD,IAAW,MAAC,OAAc,QAAd,EAAAA,EAAQM,cAAM,eAAEP,OAAOO,aAAM,EAANA,EAAQP,GAAE,IAE5CC,IACFS,EAAQH,OAASN,EAAQM,O,MAEtB,GAAIA,EAAOD,KAAM,CACtB,MAAMK,QAAkBf,KAAKC,SAASe,SAAS,CAC7CZ,GAAI,EAAAa,KAAA,QACJP,KAAMC,EAAOD,KACbQ,SAAU,EAAAC,QAAA,QAAgBL,EAAQL,QAGhCM,IACFD,EAAQH,OAASI,E,CAMvB,OADAf,KAAKD,UAAUa,GAASE,EACjBA,CACT,CAQAX,eAAeL,G,UACb,MAAM,KAAEW,EAAI,KAAEC,GAASZ,EACjBsB,EAAUpB,KAAKD,UAAUO,MAAMC,GAAMA,EAAEG,OAASA,IACtD,GAAIU,EACF,OAAOA,EAET,MAAMC,EAAiC,QAApB,EAAc,QAAd,EAAAvB,EAAQa,cAAM,eAAED,YAAI,QAAI,GACrCN,EAAe,QAAV,EAAAN,EAAQM,UAAE,QAAI,EAAAa,KAAA,QACnBN,QAAeX,KAAKC,SAASe,SAAS,CAC1CZ,KACAM,KAAMW,EACNH,SAAU,EAAAC,QAAA,QAAgBrB,EAAQW,QAE9BJ,EAA0B,CAC9BD,KACAK,OACAC,KAAMA,QAAAA,EAAQD,EACda,KAAM,WACNX,OAAQ,CACNP,GAAIO,EAAOP,GACXM,KAAMC,EAAOD,OAIjB,OADAV,KAAKD,UAAUwB,KAAKlB,GACbA,CACT,CAOAF,eAAeC,G,MACb,MAAMC,EAAUL,KAAKD,UAAUO,MAAMC,GAAMA,EAAEH,KAAOA,IACpD,IAAKC,EACH,MAAMG,MAAM,WAAWJ,eAEzB,MAAMoB,EAAyB,QAAd,EAAAnB,EAAQM,cAAM,eAAEP,GAC7BoB,SACIxB,KAAKC,SAASwB,SAASD,GAE/B,EAAAE,SAAA,cAAuB1B,KAAKD,UAAWM,EACzC,E","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/session/src/tokens.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/session/src/sessions.ts"],"sourcesContent":["import { Session } from '@jupyterlab/services';\n\nimport { Token } from '@lumino/coreutils';\n\n/**\n * The token for the sessions service.\n */\nexport const ISessions = new Token<ISessions>('@jupyterlite/session:ISessions');\n\n/**\n * The interface for the sessions services.\n */\nexport interface ISessions {\n  /**\n   * Get a session by id.\n   *\n   * @param id The id of the session.\n   */\n  get(id: string): Promise<Session.IModel>;\n\n  /**\n   * List the running sessions\n   */\n  list(): Promise<Session.IModel[]>;\n\n  /**\n   * Path an existing session.\n   * This can be used to rename a session.\n   *\n   * @param options The options to patch the session.\n   */\n  patch: (options: Session.IModel) => Promise<Session.IModel>;\n\n  /**\n   * Start a new session.\n   *\n   * @param options The options to start a new session.\n   */\n  startNew: (options: Session.IModel) => Promise<Session.IModel>;\n\n  /**\n   * Shut down a session.\n   *\n   * @param id The id of the session to shut down.\n   */\n  shutdown: (id: string) => Promise<void>;\n}\n","import { Session } from '@jupyterlab/services';\n\nimport { PathExt } from '@jupyterlab/coreutils';\n\nimport { IKernels } from '@jupyterlite/kernel';\n\nimport { ArrayExt } from '@lumino/algorithm';\n\nimport { UUID } from '@lumino/coreutils';\n\nimport { ISessions } from './tokens';\n\n/**\n * A class to handle requests to /api/sessions\n */\nexport class Sessions implements ISessions {\n  /**\n   * Construct a new Sessions.\n   *\n   * @param options The instantiation options for a Sessions.\n   */\n  constructor(options: Sessions.IOptions) {\n    this._kernels = options.kernels;\n  }\n\n  /**\n   * Get a session by id.\n   *\n   * @param id The id of the session.\n   */\n  async get(id: string): Promise<Session.IModel> {\n    const session = this._sessions.find((s) => s.id === id);\n    if (!session) {\n      throw Error(`Session ${id} not found`);\n    }\n    return session;\n  }\n\n  /**\n   * List the running sessions\n   */\n  async list(): Promise<Session.IModel[]> {\n    return this._sessions;\n  }\n\n  /**\n   * Path an existing session.\n   * This can be used to rename a session.\n   *\n   * - path updates session to track renamed paths\n   * - kernel.name starts a new kernel with a given kernelspec\n   *\n   * @param options The options to patch the session.\n   */\n  async patch(options: Session.IModel): Promise<Session.IModel> {\n    const { id, path, name, kernel } = options;\n    const index = this._sessions.findIndex((s) => s.id === id);\n    const session = this._sessions[index];\n    if (!session) {\n      throw Error(`Session ${id} not found`);\n    }\n    const patched = {\n      ...session,\n      path: path ?? session.path,\n      name: name ?? session.name,\n    };\n\n    if (kernel) {\n      // Kernel id takes precedence over name.\n      if (kernel.id) {\n        const session = this._sessions.find(\n          (session) => session.kernel?.id === kernel?.id\n        );\n        if (session) {\n          patched.kernel = session.kernel;\n        }\n      } else if (kernel.name) {\n        const newKernel = await this._kernels.startNew({\n          id: UUID.uuid4(),\n          name: kernel.name,\n          location: PathExt.dirname(patched.path),\n        });\n\n        if (newKernel) {\n          patched.kernel = newKernel;\n        }\n      }\n    }\n\n    this._sessions[index] = patched;\n    return patched;\n  }\n\n  /**\n   * Start a new session\n   * TODO: read path and name\n   *\n   * @param options The options to start a new session.\n   */\n  async startNew(options: Session.IModel): Promise<Session.IModel> {\n    const { path, name } = options;\n    const running = this._sessions.find((s) => s.name === name);\n    if (running) {\n      return running;\n    }\n    const kernelName = options.kernel?.name ?? '';\n    const id = options.id ?? UUID.uuid4();\n    const kernel = await this._kernels.startNew({\n      id,\n      name: kernelName,\n      location: PathExt.dirname(options.path),\n    });\n    const session: Session.IModel = {\n      id,\n      path,\n      name: name ?? path,\n      type: 'notebook',\n      kernel: {\n        id: kernel.id,\n        name: kernel.name,\n      },\n    };\n    this._sessions.push(session);\n    return session;\n  }\n\n  /**\n   * Shut down a session.\n   *\n   * @param id The id of the session to shut down.\n   */\n  async shutdown(id: string): Promise<void> {\n    const session = this._sessions.find((s) => s.id === id);\n    if (!session) {\n      throw Error(`Session ${id} not found`);\n    }\n    const kernelId = session.kernel?.id;\n    if (kernelId) {\n      await this._kernels.shutdown(kernelId);\n    }\n    ArrayExt.removeFirstOf(this._sessions, session);\n  }\n\n  private _kernels: IKernels;\n  // TODO: offload to a database\n  private _sessions: Session.IModel[] = [];\n}\n\n/**\n * A namespace for sessions statics.\n */\nexport namespace Sessions {\n  /**\n   * The instantiation options for the sessions.\n   */\n  export interface IOptions {\n    /**\n     * A reference to the kernels service.\n     */\n    kernels: IKernels;\n  }\n}\n"],"names":["ISessions","Token","Sessions","constructor","options","_sessions","this","_kernels","kernels","async","id","session","find","s","Error","path","name","kernel","index","findIndex","patched","newKernel","startNew","UUID","location","PathExt","running","kernelName","type","push","kernelId","shutdown","ArrayExt"],"sourceRoot":""}