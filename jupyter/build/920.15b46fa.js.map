{"version":3,"file":"920.15b46fa.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/datagrid/src/basickeyhandler.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/datagrid/node_modules/tslib/tslib.es6.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/datagrid/src/cellrenderer.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/datagrid/src/textrenderer.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/datagrid/src/cellgroup.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/datagrid/src/hyperlinkrenderer.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/datagrid/src/basicmousehandler.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/datagrid/src/selectionmodel.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/datagrid/src/notification.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/datagrid/src/basicselectionmodel.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/datagrid/src/celleditor.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/datagrid/src/celleditorcontroller.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/datagrid/src/datamodel.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/datagrid/src/graphicscontext.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/datagrid/src/sectionlist.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/datagrid/src/renderermap.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/datagrid/src/datagrid.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/datagrid/src/jsonmodel.ts"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { Platform } from '@lumino/domutils';\n\nimport { getKeyboardLayout } from '@lumino/keyboard';\n\nimport { DataGrid } from './datagrid';\n\nimport { SelectionModel } from './selectionmodel';\n\nimport { CellEditor } from './celleditor';\n\nimport { MutableDataModel } from './datamodel';\n\n/**\n * A basic implementation of a data grid key handler.\n *\n * #### Notes\n * This class may be subclassed and customized as needed.\n */\nexport class BasicKeyHandler implements DataGrid.IKeyHandler {\n  /**\n   * Whether the key handler is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._disposed;\n  }\n\n  /**\n   * Dispose of the resources held by the key handler.\n   */\n  dispose(): void {\n    this._disposed = true;\n  }\n\n  /**\n   * Handle the key down event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keydown event of interest.\n   *\n   * #### Notes\n   * This will not be called if the mouse button is pressed.\n   */\n  onKeyDown(grid: DataGrid, event: KeyboardEvent): void {\n    // if grid is editable and cell selection available, start cell editing\n    // on key press (letters, numbers and space only)\n    if (\n      grid.editable &&\n      grid.selectionModel!.cursorRow !== -1 &&\n      grid.selectionModel!.cursorColumn !== -1\n    ) {\n      const input = String.fromCharCode(event.keyCode);\n      if (/[a-zA-Z0-9-_ ]/.test(input)) {\n        const row = grid.selectionModel!.cursorRow;\n        const column = grid.selectionModel!.cursorColumn;\n        const cell: CellEditor.CellConfig = {\n          grid: grid,\n          row: row,\n          column: column\n        };\n        grid.editorController!.edit(cell);\n        if (getKeyboardLayout().keyForKeydownEvent(event) === 'Space') {\n          event.stopPropagation();\n          event.preventDefault();\n        }\n        return;\n      }\n    }\n\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'ArrowLeft':\n        this.onArrowLeft(grid, event);\n        break;\n      case 'ArrowRight':\n        this.onArrowRight(grid, event);\n        break;\n      case 'ArrowUp':\n        this.onArrowUp(grid, event);\n        break;\n      case 'ArrowDown':\n        this.onArrowDown(grid, event);\n        break;\n      case 'PageUp':\n        this.onPageUp(grid, event);\n        break;\n      case 'PageDown':\n        this.onPageDown(grid, event);\n        break;\n      case 'Escape':\n        this.onEscape(grid, event);\n        break;\n      case 'Delete':\n        this.onDelete(grid, event);\n        break;\n      case 'C':\n        this.onKeyC(grid, event);\n        break;\n      case 'Enter':\n        if (grid.selectionModel) {\n          grid.moveCursor(event.shiftKey ? 'up' : 'down');\n          grid.scrollToCursor();\n        }\n        break;\n      case 'Tab':\n        if (grid.selectionModel) {\n          grid.moveCursor(event.shiftKey ? 'left' : 'right');\n          grid.scrollToCursor();\n          event.stopPropagation();\n          event.preventDefault();\n        }\n        break;\n    }\n  }\n\n  /**\n   * Handle the `'ArrowLeft'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onArrowLeft(grid: DataGrid, event: KeyboardEvent): void {\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // Handle no model with the accel modifier.\n    if (!model && accel) {\n      grid.scrollTo(0, grid.scrollY);\n      return;\n    }\n\n    // Handle no model and no modifier. (ignore shift)\n    if (!model) {\n      grid.scrollByStep('left');\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Handle the row selection mode with accel key.\n    if (mode === 'row' && accel) {\n      grid.scrollTo(0, grid.scrollY);\n      return;\n    }\n\n    // Handle the row selection mode with no modifier. (ignore shift)\n    if (mode === 'row') {\n      grid.scrollByStep('left');\n      return;\n    }\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Dispatch based on the modifier keys.\n    if (accel && shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 - 1 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (accel) {\n      r1 = r;\n      r2 = r;\n      c1 = 0;\n      c2 = 0;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    } else {\n      r1 = r;\n      r2 = r;\n      c1 = c - 1;\n      c2 = c - 1;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    if (shift || mode === 'column') {\n      grid.scrollToColumn(cs.c2);\n    } else {\n      grid.scrollToCursor();\n    }\n  }\n\n  /**\n   * Handle the `'ArrowRight'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onArrowRight(grid: DataGrid, event: KeyboardEvent): void {\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // Handle no model with the accel modifier.\n    if (!model && accel) {\n      grid.scrollTo(grid.maxScrollX, grid.scrollY);\n      return;\n    }\n\n    // Handle no model and no modifier. (ignore shift)\n    if (!model) {\n      grid.scrollByStep('right');\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Handle the row selection model with accel key.\n    if (mode === 'row' && accel) {\n      grid.scrollTo(grid.maxScrollX, grid.scrollY);\n      return;\n    }\n\n    // Handle the row selection mode with no modifier. (ignore shift)\n    if (mode === 'row') {\n      grid.scrollByStep('right');\n      return;\n    }\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Dispatch based on the modifier keys.\n    if (accel && shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = Infinity;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 + 1 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (accel) {\n      r1 = r;\n      r2 = r;\n      c1 = Infinity;\n      c2 = Infinity;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    } else {\n      r1 = r;\n      r2 = r;\n      c1 = c + 1;\n      c2 = c + 1;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    if (shift || mode === 'column') {\n      grid.scrollToColumn(cs.c2);\n    } else {\n      grid.scrollToCursor();\n    }\n  }\n\n  /**\n   * Handle the `'ArrowUp'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onArrowUp(grid: DataGrid, event: KeyboardEvent): void {\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // Handle no model with the accel modifier.\n    if (!model && accel) {\n      grid.scrollTo(grid.scrollX, 0);\n      return;\n    }\n\n    // Handle no model and no modifier. (ignore shift)\n    if (!model) {\n      grid.scrollByStep('up');\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Handle the column selection mode with accel key.\n    if (mode === 'column' && accel) {\n      grid.scrollTo(grid.scrollX, 0);\n      return;\n    }\n\n    // Handle the column selection mode with no modifier. (ignore shift)\n    if (mode === 'column') {\n      grid.scrollByStep('up');\n      return;\n    }\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Dispatch based on the modifier keys.\n    if (accel && shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 - 1 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (accel) {\n      r1 = 0;\n      r2 = 0;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    } else {\n      r1 = r - 1;\n      r2 = r - 1;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    if (shift || mode === 'row') {\n      grid.scrollToRow(cs.r2);\n    } else {\n      grid.scrollToCursor();\n    }\n  }\n\n  /**\n   * Handle the `'ArrowDown'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onArrowDown(grid: DataGrid, event: KeyboardEvent): void {\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // Handle no model with the accel modifier.\n    if (!model && accel) {\n      grid.scrollTo(grid.scrollX, grid.maxScrollY);\n      return;\n    }\n\n    // Handle no model and no modifier. (ignore shift)\n    if (!model) {\n      grid.scrollByStep('down');\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Handle the column selection mode with accel key.\n    if (mode === 'column' && accel) {\n      grid.scrollTo(grid.scrollX, grid.maxScrollY);\n      return;\n    }\n\n    // Handle the column selection mode with no modifier. (ignore shift)\n    if (mode === 'column') {\n      grid.scrollByStep('down');\n      return;\n    }\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Dispatch based on the modifier keys.\n    if (accel && shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = Infinity;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 + 1 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (accel) {\n      r1 = Infinity;\n      r2 = Infinity;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    } else {\n      r1 = r + 1;\n      r2 = r + 1;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    if (shift || mode === 'row') {\n      grid.scrollToRow(cs.r2);\n    } else {\n      grid.scrollToCursor();\n    }\n  }\n\n  /**\n   * Handle the `'PageUp'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onPageUp(grid: DataGrid, event: KeyboardEvent): void {\n    // Ignore the event if the accel key is pressed.\n    if (Platform.accelKey(event)) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Scroll by page if there is no selection model.\n    if (!model || model.selectionMode === 'column') {\n      grid.scrollByPage('up');\n      return;\n    }\n\n    // Get the normal number of cells in the page height.\n    let n = Math.floor(grid.pageHeight / grid.defaultSizes.rowHeight);\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Select or resize as needed.\n    if (event.shiftKey) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 - n : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else {\n      r1 = cs ? cs.r1 - n : 0;\n      r2 = r1;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    grid.scrollToRow(cs.r2);\n  }\n\n  /**\n   * Handle the `'PageDown'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onPageDown(grid: DataGrid, event: KeyboardEvent): void {\n    // Ignore the event if the accel key is pressed.\n    if (Platform.accelKey(event)) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Scroll by page if there is no selection model.\n    if (!model || model.selectionMode === 'column') {\n      grid.scrollByPage('down');\n      return;\n    }\n\n    // Get the normal number of cells in the page height.\n    let n = Math.floor(grid.pageHeight / grid.defaultSizes.rowHeight);\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Select or resize as needed.\n    if (event.shiftKey) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 + n : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else {\n      r1 = cs ? cs.r1 + n : 0;\n      r2 = r1;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    grid.scrollToRow(cs.r2);\n  }\n\n  /**\n   * Handle the `'Escape'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onEscape(grid: DataGrid, event: KeyboardEvent): void {\n    if (grid.selectionModel) {\n      grid.selectionModel.clear();\n    }\n  }\n\n  /**\n   * Handle the `'Delete'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onDelete(grid: DataGrid, event: KeyboardEvent): void {\n    if (grid.editable && !grid.selectionModel!.isEmpty) {\n      const dataModel = grid.dataModel as MutableDataModel;\n      // Fetch the max row and column.\n      let maxRow = dataModel.rowCount('body') - 1;\n      let maxColumn = dataModel.columnCount('body') - 1;\n\n      const it = grid.selectionModel!.selections();\n      let s: SelectionModel.Selection | undefined;\n      while ((s = it.next()) !== undefined) {\n        // Clamp the cell to the model bounds.\n        let sr1 = Math.max(0, Math.min(s.r1, maxRow));\n        let sc1 = Math.max(0, Math.min(s.c1, maxColumn));\n        let sr2 = Math.max(0, Math.min(s.r2, maxRow));\n        let sc2 = Math.max(0, Math.min(s.c2, maxColumn));\n\n        for (let r = sr1; r <= sr2; ++r) {\n          for (let c = sc1; c <= sc2; ++c) {\n            dataModel.setData('body', r, c, null);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Handle the `'C'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onKeyC(grid: DataGrid, event: KeyboardEvent): void {\n    // Bail early if the modifiers aren't correct for copy.\n    if (event.shiftKey || !Platform.accelKey(event)) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Copy the current selection to the clipboard.\n    grid.copyToClipboard();\n  }\n\n  private _disposed = false;\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || from);\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { DataModel } from './datamodel';\n\nimport { GraphicsContext } from './graphicscontext';\n\n/**\n * An object which renders the cells of a data grid.\n *\n * #### Notes\n * If the predefined cell renderers are insufficient for a particular\n * use case, a custom cell renderer can be defined which derives from\n * this class.\n *\n * The data grid renders cells in column-major order, by region. The\n * region order is: body, row header, column header, corner header.\n */\nexport abstract class CellRenderer {\n  /**\n   * Paint the content for a cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   *\n   * #### Notes\n   * The grid will save/restore the `gc` state before/after invoking\n   * the renderer.\n   *\n   * For performance, the cell content is efficiently clipped to the\n   * width of the column, but *the height is not clipped*. If height\n   * clipping is needed, the renderer must set up its own clip rect.\n   *\n   * The renderer **must not** draw outside the cell bounding height.\n   */\n  abstract paint(gc: GraphicsContext, config: CellRenderer.CellConfig): void;\n}\n\n/**\n * The namespace for the `CellRenderer` class statics.\n */\nexport namespace CellRenderer {\n  /**\n   * An object which holds the configuration data for a cell.\n   */\n  export type CellConfig = {\n    /**\n     * The X position of the cell rectangle, in viewport coordinates.\n     */\n    readonly x: number;\n\n    /**\n     * The Y position of the cell rectangle, in viewport coordinates.\n     */\n    readonly y: number;\n\n    /**\n     * The height of the cell rectangle, in viewport pixels.\n     */\n    readonly height: number;\n\n    /**\n     * The width of the cell rectangle, in viewport pixels.\n     */\n    readonly width: number;\n\n    /**\n     * The region for the cell.\n     */\n    readonly region: DataModel.CellRegion;\n\n    /**\n     * The row index of the cell.\n     */\n    readonly row: number;\n\n    /**\n     * The column index of the cell.\n     */\n    readonly column: number;\n\n    /**\n     * The value for the cell.\n     */\n    readonly value: any;\n\n    /**\n     * The metadata for the cell.\n     */\n    readonly metadata: DataModel.Metadata;\n  };\n\n  /**\n   * A type alias for a cell renderer config function.\n   *\n   * This type is used to compute a value from a cell config object.\n   */\n  export type ConfigFunc<T> = (config: CellConfig) => T;\n\n  /**\n   * A type alias for a cell renderer config option.\n   *\n   * A config option can be a static value or a config function.\n   */\n  export type ConfigOption<T> = T | ConfigFunc<T>;\n\n  /**\n   * Resolve a config option for a cell renderer.\n   *\n   * @param option - The config option to resolve.\n   *\n   * @param config - The cell config object.\n   *\n   * @returns The resolved value for the option.\n   */\n  export function resolveOption<T>(\n    option: ConfigOption<T>,\n    config: CellConfig\n  ): T {\n    return typeof option === 'function'\n      ? (option as ConfigFunc<T>)(config)\n      : option;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { CellRenderer } from './cellrenderer';\n\nimport { GraphicsContext } from './graphicscontext';\n\n/**\n * A cell renderer which renders data values as text.\n */\nexport class TextRenderer extends CellRenderer {\n  /**\n   * Construct a new text renderer.\n   *\n   * @param options - The options for initializing the renderer.\n   */\n  constructor(options: TextRenderer.IOptions = {}) {\n    super();\n    this.font = options.font || '12px sans-serif';\n    this.textColor = options.textColor || '#000000';\n    this.backgroundColor = options.backgroundColor || '';\n    this.verticalAlignment = options.verticalAlignment || 'center';\n    this.horizontalAlignment = options.horizontalAlignment || 'left';\n    this.format = options.format || TextRenderer.formatGeneric();\n    this.elideDirection = options.elideDirection || 'right';\n    this.wrapText = options.wrapText || false;\n  }\n\n  /**\n   * The CSS shorthand font for drawing the text.\n   */\n  readonly font: CellRenderer.ConfigOption<string>;\n\n  /**\n   * The CSS color for drawing the text.\n   */\n  readonly textColor: CellRenderer.ConfigOption<string>;\n\n  /**\n   * The CSS color for the cell background.\n   */\n  readonly backgroundColor: CellRenderer.ConfigOption<string>;\n\n  /**\n   * The vertical alignment for the cell text.\n   */\n  readonly verticalAlignment: CellRenderer.ConfigOption<\n    TextRenderer.VerticalAlignment\n  >;\n\n  /**\n   * The horizontal alignment for the cell text.\n   */\n  readonly horizontalAlignment: CellRenderer.ConfigOption<\n    TextRenderer.HorizontalAlignment\n  >;\n\n  /**\n   * The format function for the cell value.\n   */\n  readonly format: TextRenderer.FormatFunc;\n\n  /**\n   * Which side to draw the ellipsis.\n   */\n  readonly elideDirection: CellRenderer.ConfigOption<\n    TextRenderer.ElideDirection\n  >;\n\n  /**\n   * Boolean flag for applying text wrapping.\n   */\n  readonly wrapText: CellRenderer.ConfigOption<boolean>;\n\n  /**\n   * Paint the content for a cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  paint(gc: GraphicsContext, config: CellRenderer.CellConfig): void {\n    this.drawBackground(gc, config);\n    this.drawText(gc, config);\n  }\n\n  /**\n   * Draw the background for the cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  drawBackground(gc: GraphicsContext, config: CellRenderer.CellConfig): void {\n    // Resolve the background color for the cell.\n    let color = CellRenderer.resolveOption(this.backgroundColor, config);\n\n    // Bail if there is no background color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Fill the cell with the background color.\n    gc.fillStyle = color;\n    gc.fillRect(config.x, config.y, config.width, config.height);\n  }\n\n  /**\n   * Draw the text for the cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  drawText(gc: GraphicsContext, config: CellRenderer.CellConfig): void {\n    // Resolve the font for the cell.\n    let font = CellRenderer.resolveOption(this.font, config);\n\n    // Bail if there is no font to draw.\n    if (!font) {\n      return;\n    }\n\n    // Resolve the text color for the cell.\n    let color = CellRenderer.resolveOption(this.textColor, config);\n\n    // Bail if there is no text color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Format the cell value to text.\n    let format = this.format;\n    let text = format(config);\n\n    // Bail if there is no text to draw.\n    if (!text) {\n      return;\n    }\n\n    // Resolve the vertical and horizontal alignment.\n    let vAlign = CellRenderer.resolveOption(this.verticalAlignment, config);\n    let hAlign = CellRenderer.resolveOption(this.horizontalAlignment, config);\n\n    // Resolve the elision direction\n    let elideDirection = CellRenderer.resolveOption(\n      this.elideDirection,\n      config\n    );\n\n    // Resolve the text wrapping flag\n    let wrapText = CellRenderer.resolveOption(this.wrapText, config);\n\n    // Compute the padded text box height for the specified alignment.\n    let boxHeight = config.height - (vAlign === 'center' ? 1 : 2);\n\n    // Bail if the text box has no effective size.\n    if (boxHeight <= 0) {\n      return;\n    }\n\n    // Compute the text height for the gc font.\n    let textHeight = TextRenderer.measureFontHeight(font);\n\n    // Set up the text position variables.\n    let textX: number;\n    let textY: number;\n    let boxWidth: number;\n\n    // Compute the Y position for the text.\n    switch (vAlign) {\n      case 'top':\n        textY = config.y + 2 + textHeight;\n        break;\n      case 'center':\n        textY = config.y + config.height / 2 + textHeight / 2;\n        break;\n      case 'bottom':\n        textY = config.y + config.height - 2;\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Compute the X position for the text.\n    switch (hAlign) {\n      case 'left':\n        textX = config.x + 8;\n        boxWidth = config.width - 14;\n        break;\n      case 'center':\n        textX = config.x + config.width / 2;\n        boxWidth = config.width;\n        break;\n      case 'right':\n        textX = config.x + config.width - 8;\n        boxWidth = config.width - 14;\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Clip the cell if the text is taller than the text box height.\n    if (textHeight > boxHeight) {\n      gc.beginPath();\n      gc.rect(config.x, config.y, config.width, config.height - 1);\n      gc.clip();\n    }\n\n    // Set the gc state.\n    gc.font = font;\n    gc.fillStyle = color;\n    gc.textAlign = hAlign;\n    gc.textBaseline = 'bottom';\n\n    // The current text width in pixels.\n    let textWidth = gc.measureText(text).width;\n\n    // Apply text wrapping if enabled.\n    if (wrapText && textWidth > boxWidth) {\n      // Make sure box clipping happens.\n      gc.beginPath();\n      gc.rect(config.x, config.y, config.width, config.height - 1);\n      gc.clip();\n\n      // Split column name to words based on\n      // whitespace preceding a word boundary.\n      // \"Hello  world\" --> [\"Hello  \", \"world\"]\n      const wordsInColumn = text.split(/\\s(?=\\b)/);\n\n      // Y-coordinate offset for any additional lines\n      let curY = textY;\n      let textInCurrentLine = wordsInColumn.shift()!;\n\n      // Single word. Applying text wrap on word by splitting\n      // it into characters and fitting the maximum number of\n      // characters possible per line (box width).\n      if (wordsInColumn.length === 0) {\n        let curLineTextWidth = gc.measureText(textInCurrentLine).width;\n        while (curLineTextWidth > boxWidth && textInCurrentLine !== '') {\n          // Iterating from the end of the string until we find a\n          // substring (0,i) which has a width less than the box width.\n          for (let i = textInCurrentLine.length; i > 0; i--) {\n            const curSubString = textInCurrentLine.substring(0, i);\n            const curSubStringWidth = gc.measureText(curSubString).width;\n            if (curSubStringWidth < boxWidth || curSubString.length === 1) {\n              // Found a substring which has a width less than the current\n              // box width. Rendering that substring on the current line\n              // and setting the remainder of the parent string as the next\n              // string to iterate on for the next line.\n              const nextLineText = textInCurrentLine.substring(\n                i,\n                textInCurrentLine.length\n              );\n              textInCurrentLine = nextLineText;\n              curLineTextWidth = gc.measureText(textInCurrentLine).width;\n              gc.fillText(curSubString, textX, curY);\n              curY += textHeight;\n              // No need to continue iterating after we identified\n              // an index to break the string on.\n              break;\n            }\n          }\n        }\n      }\n\n      // Multiple words in column header. Fitting maximum\n      // number of words possible per line (box width).\n      else {\n        while (wordsInColumn.length !== 0) {\n          // Processing the next word in the queue.\n          const curWord = wordsInColumn.shift();\n          // Joining that word with the existing text for\n          // the current line.\n          const incrementedText = [textInCurrentLine, curWord].join(' ');\n          const incrementedTextWidth = gc.measureText(incrementedText).width;\n          if (incrementedTextWidth > boxWidth) {\n            // If the newly combined text has a width larger than\n            // the box width, we render the line before the current\n            // word was added. We set the current word as the next\n            // line.\n            gc.fillText(textInCurrentLine, textX, curY);\n            curY += textHeight;\n            textInCurrentLine = curWord!;\n          } else {\n            // The combined text hasd a width less than the box width. We\n            // set the the current line text to be the new combined text.\n            textInCurrentLine = incrementedText;\n          }\n        }\n      }\n      gc.fillText(textInCurrentLine!, textX, curY);\n      // Terminating the call here as we don't want\n      // to apply text eliding when wrapping is active.\n      return;\n    }\n\n    // Elide text that is too long\n    let elide = '\\u2026';\n\n    // Compute elided text\n    if (elideDirection === 'right') {\n      while (textWidth > boxWidth && text.length > 1) {\n        if (text.length > 4 && textWidth >= 2 * boxWidth) {\n          // If text width is substantially bigger, take half the string\n          text = text.substring(0, text.length / 2 + 1) + elide;\n        } else {\n          // Otherwise incrementally remove the last character\n          text = text.substring(0, text.length - 2) + elide;\n        }\n        textWidth = gc.measureText(text).width;\n      }\n    } else {\n      while (textWidth > boxWidth && text.length > 1) {\n        if (text.length > 4 && textWidth >= 2 * boxWidth) {\n          // If text width is substantially bigger, take half the string\n          text = elide + text.substring(text.length / 2);\n        } else {\n          // Otherwise incrementally remove the last character\n          text = elide + text.substring(2);\n        }\n        textWidth = gc.measureText(text).width;\n      }\n    }\n\n    // Draw the text for the cell.\n    gc.fillText(text, textX, textY);\n  }\n}\n\n/**\n * The namespace for the `TextRenderer` class statics.\n */\nexport namespace TextRenderer {\n  /**\n   * A type alias for the supported vertical alignment modes.\n   */\n  export type VerticalAlignment = 'top' | 'center' | 'bottom';\n\n  /**\n   * A type alias for the supported horizontal alignment modes.\n   */\n  export type HorizontalAlignment = 'left' | 'center' | 'right';\n\n  /**\n   * A type alias for the supported ellipsis sides.\n   */\n  export type ElideDirection = 'left' | 'right';\n\n  /**\n   * An options object for initializing a text renderer.\n   */\n  export interface IOptions {\n    /**\n     * The font for drawing the cell text.\n     *\n     * The default is `'12px sans-serif'`.\n     */\n    font?: CellRenderer.ConfigOption<string>;\n\n    /**\n     * The color for the drawing the cell text.\n     *\n     * The default `'#000000'`.\n     */\n    textColor?: CellRenderer.ConfigOption<string>;\n\n    /**\n     * The background color for the cells.\n     *\n     * The default is `''`.\n     */\n    backgroundColor?: CellRenderer.ConfigOption<string>;\n\n    /**\n     * The vertical alignment for the cell text.\n     *\n     * The default is `'center'`.\n     */\n    verticalAlignment?: CellRenderer.ConfigOption<VerticalAlignment>;\n\n    /**\n     * The horizontal alignment for the cell text.\n     *\n     * The default is `'left'`.\n     */\n    horizontalAlignment?: CellRenderer.ConfigOption<HorizontalAlignment>;\n\n    /**\n     * The format function for the renderer.\n     *\n     * The default is `TextRenderer.formatGeneric()`.\n     */\n    format?: FormatFunc;\n\n    /**\n     * The ellipsis direction for the cell text.\n     *\n     * The default is `'right'`.\n     */\n    elideDirection?: CellRenderer.ConfigOption<ElideDirection>;\n\n    /**\n     * Whether or not to apply text wrapping.\n     *\n     * The default is `'false'`.\n     */\n    wrapText?: CellRenderer.ConfigOption<boolean>;\n  }\n\n  /**\n   * A type alias for a format function.\n   */\n  export type FormatFunc = CellRenderer.ConfigFunc<string>;\n\n  /**\n   * Create a generic text format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new generic text format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `String()` to coerce any value\n   * to a string.\n   */\n  export function formatGeneric(\n    options: formatGeneric.IOptions = {}\n  ): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return String(value);\n    };\n  }\n\n  /**\n   * The namespace for the `formatGeneric` function statics.\n   */\n  export namespace formatGeneric {\n    /**\n     * The options for creating a generic format function.\n     */\n    export interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a fixed decimal format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new fixed decimal format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Number()` and `toFixed()` to\n   * coerce values.\n   *\n   * The `formatIntlNumber()` formatter is more flexible, but slower.\n   */\n  export function formatFixed(options: formatFixed.IOptions = {}): FormatFunc {\n    let digits = options.digits;\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return Number(value).toFixed(digits);\n    };\n  }\n\n  /**\n   * The namespace for the `formatFixed` function statics.\n   */\n  export namespace formatFixed {\n    /**\n     * The options for creating a fixed format function.\n     */\n    export interface IOptions {\n      /**\n       * The number of digits to include after the decimal point.\n       *\n       * The default is determined by the user agent.\n       */\n      digits?: number;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a significant figure format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new significant figure format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Number()` and `toPrecision()`\n   * to coerce values.\n   *\n   * The `formatIntlNumber()` formatter is more flexible, but slower.\n   */\n  export function formatPrecision(\n    options: formatPrecision.IOptions = {}\n  ): FormatFunc {\n    let digits = options.digits;\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return Number(value).toPrecision(digits);\n    };\n  }\n\n  /**\n   * The namespace for the `formatPrecision` function statics.\n   */\n  export namespace formatPrecision {\n    /**\n     * The options for creating a precision format function.\n     */\n    export interface IOptions {\n      /**\n       * The number of significant figures to include in the value.\n       *\n       * The default is determined by the user agent.\n       */\n      digits?: number;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a scientific notation format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new scientific notation format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Number()` and `toExponential()`\n   * to coerce values.\n   *\n   * The `formatIntlNumber()` formatter is more flexible, but slower.\n   */\n  export function formatExponential(\n    options: formatExponential.IOptions = {}\n  ): FormatFunc {\n    let digits = options.digits;\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return Number(value).toExponential(digits);\n    };\n  }\n\n  /**\n   * The namespace for the `formatExponential` function statics.\n   */\n  export namespace formatExponential {\n    /**\n     * The options for creating an exponential format function.\n     */\n    export interface IOptions {\n      /**\n       * The number of digits to include after the decimal point.\n       *\n       * The default is determined by the user agent.\n       */\n      digits?: number;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create an international number format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new international number format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Intl.NumberFormat` object to\n   * coerce values.\n   *\n   * This is the most flexible (but slowest) number formatter.\n   */\n  export function formatIntlNumber(\n    options: formatIntlNumber.IOptions = {}\n  ): FormatFunc {\n    let missing = options.missing || '';\n    let nft = new Intl.NumberFormat(options.locales, options.options);\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return nft.format(value);\n    };\n  }\n\n  /**\n   * The namespace for the `formatIntlNumber` function statics.\n   */\n  export namespace formatIntlNumber {\n    /**\n     * The options for creating an intl number format function.\n     */\n    export interface IOptions {\n      /**\n       * The locales to pass to the `Intl.NumberFormat` constructor.\n       *\n       * The default is determined by the user agent.\n       */\n      locales?: string | string[];\n\n      /**\n       * The options to pass to the `Intl.NumberFormat` constructor.\n       *\n       * The default is determined by the user agent.\n       */\n      options?: Intl.NumberFormatOptions;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a date format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new date format function.\n   *\n   * #### Notes\n   * This formatter uses `Date.toDateString()` to format the values.\n   *\n   * If a value is not a `Date` object, `new Date(value)` is used to\n   * coerce the value to a date.\n   *\n   * The `formatIntlDateTime()` formatter is more flexible, but slower.\n   */\n  export function formatDate(options: formatDate.IOptions = {}): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      if (value instanceof Date) {\n        return value.toDateString();\n      }\n      return new Date(value).toDateString();\n    };\n  }\n\n  /**\n   * The namespace for the `formatDate` function statics.\n   */\n  export namespace formatDate {\n    /**\n     * The options for creating a date format function.\n     */\n    export interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a time format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new time format function.\n   *\n   * #### Notes\n   * This formatter uses `Date.toTimeString()` to format the values.\n   *\n   * If a value is not a `Date` object, `new Date(value)` is used to\n   * coerce the value to a date.\n   *\n   * The `formatIntlDateTime()` formatter is more flexible, but slower.\n   */\n  export function formatTime(options: formatTime.IOptions = {}): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      if (value instanceof Date) {\n        return value.toTimeString();\n      }\n      return new Date(value).toTimeString();\n    };\n  }\n\n  /**\n   * The namespace for the `formatTime` function statics.\n   */\n  export namespace formatTime {\n    /**\n     * The options for creating a time format function.\n     */\n    export interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create an ISO datetime format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new ISO datetime format function.\n   *\n   * #### Notes\n   * This formatter uses `Date.toISOString()` to format the values.\n   *\n   * If a value is not a `Date` object, `new Date(value)` is used to\n   * coerce the value to a date.\n   *\n   * The `formatIntlDateTime()` formatter is more flexible, but slower.\n   */\n  export function formatISODateTime(\n    options: formatISODateTime.IOptions = {}\n  ): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      if (value instanceof Date) {\n        return value.toISOString();\n      }\n      return new Date(value).toISOString();\n    };\n  }\n\n  /**\n   * The namespace for the `formatISODateTime` function statics.\n   */\n  export namespace formatISODateTime {\n    /**\n     * The options for creating an ISO datetime format function.\n     */\n    export interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a UTC datetime format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new UTC datetime format function.\n   *\n   * #### Notes\n   * This formatter uses `Date.toUTCString()` to format the values.\n   *\n   * If a value is not a `Date` object, `new Date(value)` is used to\n   * coerce the value to a date.\n   *\n   * The `formatIntlDateTime()` formatter is more flexible, but slower.\n   */\n  export function formatUTCDateTime(\n    options: formatUTCDateTime.IOptions = {}\n  ): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      if (value instanceof Date) {\n        return value.toUTCString();\n      }\n      return new Date(value).toUTCString();\n    };\n  }\n\n  /**\n   * The namespace for the `formatUTCDateTime` function statics.\n   */\n  export namespace formatUTCDateTime {\n    /**\n     * The options for creating a UTC datetime format function.\n     */\n    export interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create an international datetime format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new international datetime format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Intl.DateTimeFormat` object to\n   * coerce values.\n   *\n   * This is the most flexible (but slowest) datetime formatter.\n   */\n  export function formatIntlDateTime(\n    options: formatIntlDateTime.IOptions = {}\n  ): FormatFunc {\n    let missing = options.missing || '';\n    let dtf = new Intl.DateTimeFormat(options.locales, options.options);\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return dtf.format(value);\n    };\n  }\n\n  /**\n   * The namespace for the `formatIntlDateTime` function statics.\n   */\n  export namespace formatIntlDateTime {\n    /**\n     * The options for creating an intl datetime format function.\n     */\n    export interface IOptions {\n      /**\n       * The locales to pass to the `Intl.DateTimeFormat` constructor.\n       *\n       * The default is determined by the user agent.\n       */\n      locales?: string | string[];\n\n      /**\n       * The options to pass to the `Intl.DateTimeFormat` constructor.\n       *\n       * The default is determined by the user agent.\n       */\n      options?: Intl.DateTimeFormatOptions;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Measure the height of a font.\n   *\n   * @param font - The CSS font string of interest.\n   *\n   * @returns The height of the font bounding box.\n   *\n   * #### Notes\n   * This function uses a temporary DOM node to measure the text box\n   * height for the specified font. The first call for a given font\n   * will incur a DOM reflow, but the return value is cached, so any\n   * subsequent call for the same font will return the cached value.\n   */\n  export function measureFontHeight(font: string): number {\n    // Look up the cached font height.\n    let height = Private.fontHeightCache[font];\n\n    // Return the cached font height if it exists.\n    if (height !== undefined) {\n      return height;\n    }\n\n    // Normalize the font.\n    Private.fontMeasurementGC.font = font;\n    let normFont = Private.fontMeasurementGC.font;\n\n    // Set the font on the measurement node.\n    Private.fontMeasurementNode.style.font = normFont;\n\n    // Add the measurement node to the document.\n    document.body.appendChild(Private.fontMeasurementNode);\n\n    // Measure the node height.\n    height = Private.fontMeasurementNode.offsetHeight;\n\n    // Remove the measurement node from the document.\n    document.body.removeChild(Private.fontMeasurementNode);\n\n    // Cache the measured height for the font and norm font.\n    Private.fontHeightCache[font] = height;\n    Private.fontHeightCache[normFont] = height;\n\n    // Return the measured height.\n    return height;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * A cache of measured font heights.\n   */\n  export const fontHeightCache: { [font: string]: number } = Object.create(\n    null\n  );\n\n  /**\n   * The DOM node used for font height measurement.\n   */\n  export const fontMeasurementNode = (() => {\n    let node = document.createElement('div');\n    node.style.position = 'absolute';\n    node.style.top = '-99999px';\n    node.style.left = '-99999px';\n    node.style.visibility = 'hidden';\n    node.textContent = 'M';\n    return node;\n  })();\n\n  /**\n   * The GC used for font measurement.\n   */\n  export const fontMeasurementGC = (() => {\n    let canvas = document.createElement('canvas');\n    canvas.width = 0;\n    canvas.height = 0;\n    return canvas.getContext('2d')!;\n  })();\n}\n","import { DataModel } from './datamodel';\nimport { SectionList } from './sectionlist';\n\n/**\n * An interface describing a merged cell group.\n * r1: start row\n * r2: end row\n * c1: start column\n * c2: end column\n */\nexport interface CellGroup {\n  r1: number;\n  r2: number;\n  c1: number;\n  c2: number;\n}\n\n/**\n * A collection of helper functions relating to merged cell groups\n */\nexport namespace CellGroup {\n  export function areCellsMerged(\n    dataModel: DataModel,\n    rgn: DataModel.CellRegion,\n    cell1: number[],\n    cell2: number[]\n  ): boolean {\n    const numGroups = dataModel.groupCount(rgn);\n    const [row1, column1] = cell1;\n    const [row2, column2] = cell2;\n\n    for (let i = 0; i < numGroups; i++) {\n      const group = dataModel.group(rgn, i)!;\n      if (\n        row1 >= group.r1 &&\n        row1 <= group.r2 &&\n        column1 >= group.c1 &&\n        column1 <= group.c2 &&\n        row2 >= group.r1 &&\n        row2 <= group.r2 &&\n        column2 >= group.c1 &&\n        column2 <= group.c2\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Calculates the cell boundary offsets needed for\n   * a row or column at the given index by taking\n   * into account merged cell groups in the region.\n   * @param dataModel\n   * @param regions\n   * @param axis\n   * @param sectionList\n   * @param index\n   */\n  export function calculateMergeOffsets(\n    dataModel: DataModel,\n    regions: DataModel.CellRegion[],\n    axis: 'row' | 'column',\n    sectionList: SectionList,\n    index: number\n  ): [number, number, CellGroup] {\n    let mergeStartOffset = 0;\n    let mergeEndOffset = 0;\n    let mergedCellGroups: CellGroup[] = [];\n\n    for (const region of regions) {\n      mergedCellGroups = mergedCellGroups.concat(\n        getCellGroupsAtRegion(dataModel, region)\n      );\n    }\n\n    let groupsAtAxis: CellGroup[] = [];\n\n    if (axis === 'row') {\n      for (const region of regions) {\n        groupsAtAxis = groupsAtAxis.concat(\n          getCellGroupsAtRow(dataModel, region, index)\n        );\n      }\n    } else {\n      for (const region of regions) {\n        groupsAtAxis = groupsAtAxis.concat(\n          getCellGroupsAtColumn(dataModel, region, index)\n        );\n      }\n    }\n\n    if (groupsAtAxis.length === 0) {\n      return [0, 0, { r1: -1, r2: -1, c1: -1, c2: -1 }];\n    }\n\n    let joinedGroup = groupsAtAxis[0];\n\n    for (let g = 0; g < mergedCellGroups.length; g++) {\n      const group = mergedCellGroups[g];\n      if (areCellGroupsIntersectingAtAxis(joinedGroup, group, axis)) {\n        joinedGroup = joinCellGroups([group, joinedGroup]);\n        mergedCellGroups.splice(g, 1);\n        g = 0;\n      }\n    }\n\n    let minRow = joinedGroup.r1;\n    let maxRow = joinedGroup.r2;\n\n    for (let r = index - 1; r >= minRow; r--) {\n      mergeStartOffset += sectionList.sizeOf(r);\n    }\n\n    for (let r = index + 1; r <= maxRow; r++) {\n      mergeEndOffset += sectionList.sizeOf(r);\n    }\n\n    return [mergeStartOffset, mergeEndOffset, joinedGroup];\n  }\n\n  /**\n   * Checks if two cell-groups are intersecting\n   * in the given axis.\n   * @param group1\n   * @param group2\n   * @param axis\n   */\n  export function areCellGroupsIntersectingAtAxis(\n    group1: CellGroup,\n    group2: CellGroup,\n    axis: 'row' | 'column'\n  ): boolean {\n    if (axis === 'row') {\n      return (\n        (group1.r1 >= group2.r1 && group1.r1 <= group2.r2) ||\n        (group1.r2 >= group2.r1 && group1.r2 <= group2.r2) ||\n        (group2.r1 >= group1.r1 && group2.r1 <= group1.r2) ||\n        (group2.r2 >= group1.r1 && group2.r2 <= group1.r2)\n      );\n    }\n    return (\n      (group1.c1 >= group2.c1 && group1.c1 <= group2.c2) ||\n      (group1.c2 >= group2.c1 && group1.c2 <= group2.c2) ||\n      (group2.c1 >= group1.c1 && group2.c1 <= group1.c2) ||\n      (group2.c2 >= group1.c1 && group2.c2 <= group1.c2)\n    );\n  }\n\n  /**\n   * Checks if cell-groups are intersecting.\n   * @param group1\n   * @param group2\n   */\n  export function areCellGroupsIntersecting(\n    group1: CellGroup,\n    group2: CellGroup\n  ): boolean {\n    return (\n      ((group1.r1 >= group2.r1 && group1.r1 <= group2.r2) ||\n        (group1.r2 >= group2.r1 && group1.r2 <= group2.r2) ||\n        (group2.r1 >= group1.r1 && group2.r1 <= group1.r2) ||\n        (group2.r2 >= group1.r1 && group2.r2 <= group1.r2)) &&\n      ((group1.c1 >= group2.c1 && group1.c1 <= group2.c2) ||\n        (group1.c2 >= group2.c1 && group1.c2 <= group2.c2) ||\n        (group2.c1 >= group1.c1 && group2.c1 <= group1.c2) ||\n        (group2.c2 >= group1.c1 && group2.c2 <= group1.c2))\n    );\n  }\n\n  /**\n   * Retrieves the index of the cell-group to which\n   * the cell at the given row, column belongs.\n   * @param dataModel\n   * @param rgn\n   * @param row\n   * @param column\n   */\n  export function getGroupIndex(\n    dataModel: DataModel,\n    rgn: DataModel.CellRegion,\n    row: number,\n    column: number\n  ): number {\n    const numGroups = dataModel.groupCount(rgn);\n    for (let i = 0; i < numGroups; i++) {\n      const group = dataModel.group(rgn, i)!;\n      if (\n        row >= group.r1 &&\n        row <= group.r2 &&\n        column >= group.c1 &&\n        column <= group.c2\n      ) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns a cell-group for the given row/index coordinates.\n   * @param dataModel\n   * @param rgn\n   * @param row\n   * @param column\n   */\n  export function getGroup(\n    dataModel: DataModel,\n    rgn: DataModel.CellRegion,\n    row: number,\n    column: number\n  ): CellGroup | null {\n    const groupIndex = getGroupIndex(dataModel, rgn, row, column);\n    if (groupIndex === -1) {\n      return null;\n    }\n\n    return dataModel.group(rgn, groupIndex);\n  }\n\n  /**\n   * Returns all cell groups which belong to\n   * a given cell cell region.\n   * @param dataModel\n   * @param rgn\n   */\n  export function getCellGroupsAtRegion(\n    dataModel: DataModel,\n    rgn: DataModel.CellRegion\n  ): CellGroup[] {\n    let groupsAtRegion: CellGroup[] = [];\n    const numGroups = dataModel.groupCount(rgn);\n\n    for (let i = 0; i < numGroups; i++) {\n      const group = dataModel.group(rgn, i)!;\n      groupsAtRegion.push(group);\n    }\n    return groupsAtRegion;\n  }\n\n  /**\n   * Calculates and returns a merged cell-group from\n   * two cell-group objects.\n   * @param groups\n   */\n  export function joinCellGroups(groups: CellGroup[]): CellGroup {\n    let startRow = Number.MAX_VALUE;\n    let endRow = Number.MIN_VALUE;\n    let startColumn = Number.MAX_VALUE;\n    let endColumn = Number.MIN_VALUE;\n\n    for (const group of groups) {\n      startRow = Math.min(startRow, group.r1);\n      endRow = Math.max(endRow, group.r2);\n      startColumn = Math.min(startColumn, group.c1);\n      endColumn = Math.max(endColumn, group.c2);\n    }\n\n    return { r1: startRow, r2: endRow, c1: startColumn, c2: endColumn };\n  }\n\n  /**\n   * Merges a cell group with other cells groups in the\n   * same region if they intersect.\n   * @param dataModel the data model of the grid.\n   * @param group the target cell group.\n   * @param region the region of the cell group.\n   * @returns a new cell group after merging has happened.\n   */\n  export function joinCellGroupWithMergedCellGroups(\n    dataModel: DataModel,\n    group: CellGroup,\n    region: DataModel.CellRegion\n  ): CellGroup {\n    let joinedGroup: CellGroup = { ...group };\n\n    const mergedCellGroups: CellGroup[] = getCellGroupsAtRegion(\n      dataModel,\n      region\n    );\n\n    for (let g = 0; g < mergedCellGroups.length; g++) {\n      const mergedGroup = mergedCellGroups[g];\n      if (areCellGroupsIntersecting(joinedGroup, mergedGroup)) {\n        joinedGroup = joinCellGroups([joinedGroup, mergedGroup]);\n      }\n    }\n\n    return joinedGroup;\n  }\n\n  /**\n   * Retrieves a list of cell groups intersecting at\n   * a given row.\n   * @param dataModel data model of the grid.\n   * @param rgn the cell region.\n   * @param row the target row to look for intersections at.\n   * @returns all cell groups intersecting with the row.\n   */\n  export function getCellGroupsAtRow(\n    dataModel: DataModel,\n    rgn: DataModel.CellRegion,\n    row: number\n  ): CellGroup[] {\n    let groupsAtRow = [];\n    const numGroups = dataModel.groupCount(rgn);\n\n    for (let i = 0; i < numGroups; i++) {\n      const group = dataModel.group(rgn, i)!;\n      if (row >= group.r1 && row <= group.r2) {\n        groupsAtRow.push(group);\n      }\n    }\n    return groupsAtRow;\n  }\n\n  /**\n   * Retrieves a list of cell groups intersecting at\n   * a given column.\n   * @param dataModel data model of the grid.\n   * @param rgn the cell region.\n   * @param column the target column to look for intersections at.\n   * @returns all cell groups intersecting with the column.\n   */\n  export function getCellGroupsAtColumn(\n    dataModel: DataModel,\n    rgn: DataModel.CellRegion,\n    column: number\n  ): CellGroup[] {\n    let groupsAtColumn = [];\n    const numGroups = dataModel.groupCount(rgn);\n\n    for (let i = 0; i < numGroups; i++) {\n      const group = dataModel.group(rgn, i)!;\n      if (column >= group.c1 && column <= group.c2) {\n        groupsAtColumn.push(group);\n      }\n    }\n    return groupsAtColumn;\n  }\n\n  /**\n   * Checks if cell group 1 is above cell group 2.\n   * @param group1 cell group 1.\n   * @param group2 cell group 2.\n   * @returns boolean.\n   */\n  export function isCellGroupAbove(\n    group1: CellGroup,\n    group2: CellGroup\n  ): boolean {\n    return group2.r2 >= group1.r1;\n  }\n\n  /**\n   * Checks if cell group 1 is below cell group 2.\n   */\n  export function isCellGroupBelow(\n    group1: CellGroup,\n    group2: CellGroup\n  ): boolean {\n    return group2.r1 <= group1.r2;\n  }\n\n  /**\n   * Merges a target cell group with any cell groups\n   * it intersects with at a given row or column.\n   * @param dataModel data model of the grid.\n   * @param regions list of cell regions.\n   * @param axis row or column.\n   * @param group the target cell group.\n   * @returns a new merged cell group.\n   */\n  export function joinCellGroupsIntersectingAtAxis(\n    dataModel: DataModel,\n    regions: DataModel.CellRegion[],\n    axis: 'row' | 'column',\n    group: CellGroup\n  ): CellGroup {\n    let groupsAtAxis: CellGroup[] = [];\n    if (axis === 'row') {\n      for (const region of regions) {\n        for (let r = group.r1; r <= group.r2; r++) {\n          groupsAtAxis = groupsAtAxis.concat(\n            CellGroup.getCellGroupsAtRow(dataModel, region, r)\n          );\n        }\n      }\n    } else {\n      for (const region of regions) {\n        for (let c = group.c1; c <= group.c2; c++) {\n          groupsAtAxis = groupsAtAxis.concat(\n            CellGroup.getCellGroupsAtColumn(dataModel, region, c)\n          );\n        }\n      }\n    }\n\n    let mergedGroupAtAxis: CellGroup = CellGroup.joinCellGroups(groupsAtAxis);\n\n    if (groupsAtAxis.length > 0) {\n      let mergedCellGroups: CellGroup[] = [];\n      for (const region of regions) {\n        mergedCellGroups = mergedCellGroups.concat(\n          CellGroup.getCellGroupsAtRegion(dataModel, region)\n        );\n      }\n\n      for (let g = 0; g < mergedCellGroups.length; g++) {\n        const group = mergedCellGroups[g];\n        if (\n          CellGroup.areCellGroupsIntersectingAtAxis(\n            mergedGroupAtAxis,\n            group,\n            axis\n          )\n        ) {\n          mergedGroupAtAxis = CellGroup.joinCellGroups([\n            group,\n            mergedGroupAtAxis\n          ]);\n          mergedCellGroups.splice(g, 1);\n          g = 0;\n        }\n      }\n    }\n    return mergedGroupAtAxis;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { CellRenderer } from './cellrenderer';\n\nimport { GraphicsContext } from './graphicscontext';\n\nimport { TextRenderer } from './textrenderer';\n\n/**\n * A cell renderer which renders data values as text.\n */\nexport class HyperlinkRenderer extends TextRenderer {\n  /**\n   * Construct a new text renderer.\n   *\n   * @param options - The options for initializing the renderer.\n   */\n  constructor(options: HyperlinkRenderer.IOptions = {}) {\n    // Set default parameters before passing over the super.\n    options.textColor = options.textColor || 'navy';\n    options.font = options.font || 'bold 12px sans-serif';\n    super(options);\n    this.url = options.url;\n    this.urlName = options.urlName;\n  }\n\n  /**\n   * The URL address.\n   */\n  readonly url: CellRenderer.ConfigOption<string> | undefined;\n\n  /**\n   * The friendly link name.\n   */\n  readonly urlName: CellRenderer.ConfigOption<string> | undefined;\n\n  /**\n   * Draw the text for the cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  drawText(gc: GraphicsContext, config: CellRenderer.CellConfig): void {\n    // Resolve the font for the cell.\n    let font = CellRenderer.resolveOption(this.font, config);\n\n    // Bail if there is no font to draw.\n    if (!font) {\n      return;\n    }\n\n    // Resolve for the friendly URL name.\n    let urlName = CellRenderer.resolveOption(this.urlName, config);\n\n    // Resolve the text color for the cell.\n    let color = CellRenderer.resolveOption(this.textColor, config);\n\n    // Bail if there is no text color to draw.\n    if (!color) {\n      return;\n    }\n\n    const format = this.format;\n    let text;\n\n    // If we have a friendly URL name, use that.\n    if (urlName) {\n      text = format({\n        ...config,\n        value: urlName\n      } as CellRenderer.CellConfig);\n    } else {\n      // Otherwise use the raw value attribute.\n      text = format(config);\n    }\n\n    // Bail if there is no text to draw.\n    if (!text) {\n      return;\n    }\n\n    // Resolve the vertical and horizontal alignment.\n    let vAlign = CellRenderer.resolveOption(this.verticalAlignment, config);\n    let hAlign = CellRenderer.resolveOption(this.horizontalAlignment, config);\n\n    // Resolve the elision direction\n    let elideDirection = CellRenderer.resolveOption(\n      this.elideDirection,\n      config\n    );\n\n    // Resolve the text wrapping flag\n    let wrapText = CellRenderer.resolveOption(this.wrapText, config);\n\n    // Compute the padded text box height for the specified alignment.\n    let boxHeight = config.height - (vAlign === 'center' ? 1 : 2);\n\n    // Bail if the text box has no effective size.\n    if (boxHeight <= 0) {\n      return;\n    }\n\n    // Compute the text height for the gc font.\n    let textHeight = HyperlinkRenderer.measureFontHeight(font);\n\n    // Set up the text position variables.\n    let textX: number;\n    let textY: number;\n    let boxWidth: number;\n\n    // Compute the Y position for the text.\n    switch (vAlign) {\n      case 'top':\n        textY = config.y + 2 + textHeight;\n        break;\n      case 'center':\n        textY = config.y + config.height / 2 + textHeight / 2;\n        break;\n      case 'bottom':\n        textY = config.y + config.height - 2;\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Compute the X position for the text.\n    switch (hAlign) {\n      case 'left':\n        textX = config.x + 8;\n        boxWidth = config.width - 14;\n        break;\n      case 'center':\n        textX = config.x + config.width / 2;\n        boxWidth = config.width;\n        break;\n      case 'right':\n        textX = config.x + config.width - 8;\n        boxWidth = config.width - 14;\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Clip the cell if the text is taller than the text box height.\n    if (textHeight > boxHeight) {\n      gc.beginPath();\n      gc.rect(config.x, config.y, config.width, config.height - 1);\n      gc.clip();\n    }\n\n    // Set the gc state.\n    gc.font = font;\n    gc.fillStyle = color;\n    gc.textAlign = hAlign;\n    gc.textBaseline = 'bottom';\n\n    // The current text width in pixels.\n    let textWidth = gc.measureText(text).width;\n\n    // Apply text wrapping if enabled.\n    if (wrapText && textWidth > boxWidth) {\n      // Make sure box clipping happens.\n      gc.beginPath();\n      gc.rect(config.x, config.y, config.width, config.height - 1);\n      gc.clip();\n\n      // Split column name to words based on\n      // whitespace preceding a word boundary.\n      // \"Hello  world\" --> [\"Hello  \", \"world\"]\n      const wordsInColumn = text.split(/\\s(?=\\b)/);\n\n      // Y-coordinate offset for any additional lines\n      let curY = textY;\n      let textInCurrentLine = wordsInColumn.shift()!;\n\n      // Single word. Applying text wrap on word by splitting\n      // it into characters and fitting the maximum number of\n      // characters possible per line (box width).\n      if (wordsInColumn.length === 0) {\n        let curLineTextWidth = gc.measureText(textInCurrentLine).width;\n        while (curLineTextWidth > boxWidth && textInCurrentLine !== '') {\n          // Iterating from the end of the string until we find a\n          // substring (0,i) which has a width less than the box width.\n          for (let i = textInCurrentLine.length; i > 0; i--) {\n            const curSubString = textInCurrentLine.substring(0, i);\n            const curSubStringWidth = gc.measureText(curSubString).width;\n            if (curSubStringWidth < boxWidth || curSubString.length === 1) {\n              // Found a substring which has a width less than the current\n              // box width. Rendering that substring on the current line\n              // and setting the remainder of the parent string as the next\n              // string to iterate on for the next line.\n              const nextLineText = textInCurrentLine.substring(\n                i,\n                textInCurrentLine.length\n              );\n              textInCurrentLine = nextLineText;\n              curLineTextWidth = gc.measureText(textInCurrentLine).width;\n              gc.fillText(curSubString, textX, curY);\n              curY += textHeight;\n              // No need to continue iterating after we identified\n              // an index to break the string on.\n              break;\n            }\n          }\n        }\n      }\n\n      // Multiple words in column header. Fitting maximum\n      // number of words possible per line (box width).\n      else {\n        while (wordsInColumn.length !== 0) {\n          // Processing the next word in the queue.\n          const curWord = wordsInColumn.shift();\n          // Joining that word with the existing text for\n          // the current line.\n          const incrementedText = [textInCurrentLine, curWord].join(' ');\n          const incrementedTextWidth = gc.measureText(incrementedText).width;\n          if (incrementedTextWidth > boxWidth) {\n            // If the newly combined text has a width larger than\n            // the box width, we render the line before the current\n            // word was added. We set the current word as the next\n            // line.\n            gc.fillText(textInCurrentLine, textX, curY);\n            curY += textHeight;\n            textInCurrentLine = curWord!;\n          } else {\n            // The combined text hasd a width less than the box width. We\n            // set the the current line text to be the new combined text.\n            textInCurrentLine = incrementedText;\n          }\n        }\n      }\n      gc.fillText(textInCurrentLine!, textX, curY);\n      // Terminating the call here as we don't want\n      // to apply text eliding when wrapping is active.\n      return;\n    }\n\n    // Elide text that is too long\n    let elide = '\\u2026';\n\n    // Compute elided text\n    if (elideDirection === 'right') {\n      while (textWidth > boxWidth && text.length > 1) {\n        if (text.length > 4 && textWidth >= 2 * boxWidth) {\n          // If text width is substantially bigger, take half the string\n          text = text.substring(0, text.length / 2 + 1) + elide;\n        } else {\n          // Otherwise incrementally remove the last character\n          text = text.substring(0, text.length - 2) + elide;\n        }\n        textWidth = gc.measureText(text).width;\n      }\n    } else {\n      while (textWidth > boxWidth && text.length > 1) {\n        if (text.length > 4 && textWidth >= 2 * boxWidth) {\n          // If text width is substantially bigger, take half the string\n          text = elide + text.substring(text.length / 2);\n        } else {\n          // Otherwise incrementally remove the last character\n          text = elide + text.substring(2);\n        }\n        textWidth = gc.measureText(text).width;\n      }\n    }\n\n    // Draw the text for the cell.\n    gc.fillText(text, textX, textY);\n  }\n}\n\nexport namespace HyperlinkRenderer {\n  /**\n   * A type alias for the supported vertical alignment modes.\n   */\n  export type VerticalAlignment = 'top' | 'center' | 'bottom';\n\n  /**\n   * A type alias for the supported horizontal alignment modes.\n   */\n  export type HorizontalAlignment = 'left' | 'center' | 'right';\n\n  /**\n   * A type alias for the supported ellipsis sides.\n   */\n  export type ElideDirection = 'left' | 'right';\n\n  /**\n   * An options object for initializing a text renderer.\n   */\n  export interface IOptions extends TextRenderer.IOptions {\n    /**\n     * The URL address\n     */\n    url?: CellRenderer.ConfigOption<string> | undefined;\n    /**\n     * The friendly link name.\n     *\n     * The default is the URL itself.\n     */\n    urlName?: CellRenderer.ConfigOption<string> | undefined;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { IDisposable } from '@lumino/disposable';\n\nimport { Platform } from '@lumino/domutils';\n\nimport { Drag } from '@lumino/dragdrop';\n\nimport { DataGrid } from './datagrid';\n\nimport { HyperlinkRenderer } from './hyperlinkrenderer';\n\nimport { DataModel } from './datamodel';\n\nimport { SelectionModel } from './selectionmodel';\n\nimport { CellEditor } from './celleditor';\n\nimport { CellGroup } from './cellgroup';\n\nimport { CellRenderer } from './cellrenderer';\n\nimport { TextRenderer } from './textrenderer';\n\n/**\n * A basic implementation of a data grid mouse handler.\n *\n * #### Notes\n * This class may be subclassed and customized as needed.\n */\nexport class BasicMouseHandler implements DataGrid.IMouseHandler {\n  /**\n   * Dispose of the resources held by the mouse handler.\n   */\n  dispose(): void {\n    // Bail early if the handler is already disposed.\n    if (this._disposed) {\n      return;\n    }\n\n    // Release any held resources.\n    this.release();\n\n    // Mark the handler as disposed.\n    this._disposed = true;\n  }\n\n  /**\n   * Whether the mouse handler is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._disposed;\n  }\n\n  /**\n   * Release the resources held by the handler.\n   */\n  release(): void {\n    // Bail early if the is no press data.\n    if (!this._pressData) {\n      return;\n    }\n\n    // Clear the autoselect timeout.\n    if (this._pressData.type === 'select') {\n      this._pressData.timeout = -1;\n    }\n\n    // Clear the press data.\n    this._pressData.override.dispose();\n    this._pressData = null;\n  }\n\n  /**\n   * Handle the mouse hover event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse hover event of interest.\n   */\n  onMouseHover(grid: DataGrid, event: MouseEvent): void {\n    // Hit test the grid.\n    let hit = grid.hitTest(event.clientX, event.clientY);\n\n    // Get the resize handle for the hit test.\n    let handle = Private.resizeHandleForHitTest(hit);\n\n    // Fetch the cursor for the handle.\n    let cursor = this.cursorForHandle(handle);\n\n    // Hyperlink logic.\n    const config = Private.createCellConfigObject(grid, hit);\n\n    if (config) {\n      // Retrieve renderer for hovered cell.\n      const renderer = grid.cellRenderers.get(config);\n      if (renderer instanceof HyperlinkRenderer) {\n        cursor = this.cursorForHandle('hyperlink');\n      }\n    }\n\n    // Update the viewport cursor based on the part.\n    grid.viewport.node.style.cursor = cursor;\n\n    // TODO support user-defined hover items\n  }\n\n  /**\n   * Handle the mouse leave event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse hover event of interest.\n   */\n  onMouseLeave(grid: DataGrid, event: MouseEvent): void {\n    // TODO support user-defined hover popups.\n\n    // Clear the viewport cursor.\n    grid.viewport.node.style.cursor = '';\n  }\n\n  /**\n   * Handle the mouse down event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse down event of interest.\n   */\n  onMouseDown(grid: DataGrid, event: MouseEvent): void {\n    // Unpack the event.\n    let { clientX, clientY } = event;\n\n    // Hit test the grid.\n    let hit = grid.hitTest(clientX, clientY);\n\n    // Unpack the hit test.\n    const { region, row, column } = hit;\n\n    // Bail if the hit test is on an uninteresting region.\n    if (region === 'void') {\n      return;\n    }\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // Hyperlink logic.\n    if (grid) {\n      // Create cell config object.\n      const config = Private.createCellConfigObject(grid, hit);\n\n      // Retrieve cell renderer.\n      let renderer = grid.cellRenderers.get(config!);\n\n      // Only process hyperlink renderers.\n      if (renderer instanceof HyperlinkRenderer) {\n        // Use the url param if it exists.\n        let url = CellRenderer.resolveOption(renderer.url, config!);\n        // Otherwise assume cell value is the URL.\n        if (!url) {\n          const format = TextRenderer.formatGeneric();\n          url = format(config!);\n        }\n\n        // Open the hyperlink only if user hit Ctrl+Click.\n        if (accel) {\n          window.open(url);\n          // Reset cursor default after clicking\n          const cursor = this.cursorForHandle('none');\n          grid.viewport.node.style.cursor = cursor;\n          // Not applying selections if navigating away.\n          return;\n        }\n      }\n    }\n\n    // If the hit test is the body region, the only option is select.\n    if (region === 'body') {\n      // Fetch the selection model.\n      let model = grid.selectionModel;\n\n      // Bail early if there is no selection model.\n      if (!model) {\n        return;\n      }\n\n      // Override the document cursor.\n      let override = Drag.overrideCursor('default');\n\n      // Set up the press data.\n      this._pressData = {\n        type: 'select',\n        region,\n        row,\n        column,\n        override,\n        localX: -1,\n        localY: -1,\n        timeout: -1\n      };\n\n      // Set up the selection variables.\n      let r1: number;\n      let c1: number;\n      let r2: number;\n      let c2: number;\n      let cursorRow: number;\n      let cursorColumn: number;\n      let clear: SelectionModel.ClearMode;\n\n      // Accel == new selection, keep old selections.\n      if (accel) {\n        r1 = row;\n        r2 = row;\n        c1 = column;\n        c2 = column;\n        cursorRow = row;\n        cursorColumn = column;\n        clear = 'none';\n      } else if (shift) {\n        r1 = model.cursorRow;\n        r2 = row;\n        c1 = model.cursorColumn;\n        c2 = column;\n        cursorRow = model.cursorRow;\n        cursorColumn = model.cursorColumn;\n        clear = 'current';\n      } else {\n        r1 = row;\n        r2 = row;\n        c1 = column;\n        c2 = column;\n        cursorRow = row;\n        cursorColumn = column;\n        clear = 'all';\n      }\n\n      // Make the selection.\n      model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n\n      // Done.\n      return;\n    }\n\n    // Otherwise, the hit test is on a header region.\n\n    // Convert the hit test into a part.\n    let handle = Private.resizeHandleForHitTest(hit);\n\n    // Fetch the cursor for the handle.\n    let cursor = this.cursorForHandle(handle);\n\n    // Handle horizontal resize.\n    if (handle === 'left' || handle === 'right') {\n      // Set up the resize data type.\n      const type = 'column-resize';\n\n      // Determine the column region.\n      let rgn: DataModel.ColumnRegion =\n        region === 'column-header' ? 'body' : 'row-header';\n\n      // Determine the section index.\n      let index = handle === 'left' ? column - 1 : column;\n\n      // Fetch the section size.\n      let size = grid.columnSize(rgn, index);\n\n      // Override the document cursor.\n      let override = Drag.overrideCursor(cursor);\n\n      // Create the temporary press data.\n      this._pressData = { type, region: rgn, index, size, clientX, override };\n\n      // Done.\n      return;\n    }\n\n    // Handle vertical resize\n    if (handle === 'top' || handle === 'bottom') {\n      // Set up the resize data type.\n      const type = 'row-resize';\n\n      // Determine the row region.\n      let rgn: DataModel.RowRegion =\n        region === 'row-header' ? 'body' : 'column-header';\n\n      // Determine the section index.\n      let index = handle === 'top' ? row - 1 : row;\n\n      // Fetch the section size.\n      let size = grid.rowSize(rgn, index);\n\n      // Override the document cursor.\n      let override = Drag.overrideCursor(cursor);\n\n      // Create the temporary press data.\n      this._pressData = { type, region: rgn, index, size, clientY, override };\n\n      // Done.\n      return;\n    }\n\n    // Otherwise, the only option is select.\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Bail if there is no selection model.\n    if (!model) {\n      return;\n    }\n\n    // Override the document cursor.\n    let override = Drag.overrideCursor('default');\n\n    // Set up the press data.\n    this._pressData = {\n      type: 'select',\n      region,\n      row,\n      column,\n      override,\n      localX: -1,\n      localY: -1,\n      timeout: -1\n    };\n\n    // Set up the selection variables.\n    let r1: number;\n    let c1: number;\n    let r2: number;\n    let c2: number;\n    let cursorRow: number;\n    let cursorColumn: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Compute the selection based on the pressed region.\n    if (region === 'corner-header') {\n      r1 = 0;\n      r2 = Infinity;\n      c1 = 0;\n      c2 = Infinity;\n      cursorRow = accel ? 0 : shift ? model.cursorRow : 0;\n      cursorColumn = accel ? 0 : shift ? model.cursorColumn : 0;\n      clear = accel ? 'none' : shift ? 'current' : 'all';\n    } else if (region === 'row-header') {\n      r1 = accel ? row : shift ? model.cursorRow : row;\n      r2 = row;\n\n      const selectionGroup: CellGroup = { r1: r1, c1: 0, r2: r2, c2: 0 };\n      const joinedGroup = CellGroup.joinCellGroupsIntersectingAtAxis(\n        grid.dataModel!,\n        ['row-header', 'body'],\n        'row',\n        selectionGroup\n      );\n      // Check if there are any merges\n      if (joinedGroup.r1 != Number.MAX_VALUE) {\n        r1 = joinedGroup.r1;\n        r2 = joinedGroup.r2;\n      }\n\n      c1 = 0;\n      c2 = Infinity;\n      cursorRow = accel ? row : shift ? model.cursorRow : row;\n      cursorColumn = accel ? 0 : shift ? model.cursorColumn : 0;\n      clear = accel ? 'none' : shift ? 'current' : 'all';\n    } else if (region === 'column-header') {\n      r1 = 0;\n      r2 = Infinity;\n      c1 = accel ? column : shift ? model.cursorColumn : column;\n      c2 = column;\n\n      const selectionGroup: CellGroup = { r1: 0, c1: c1, r2: 0, c2: c2 };\n      const joinedGroup = CellGroup.joinCellGroupsIntersectingAtAxis(\n        grid.dataModel!,\n        ['column-header', 'body'],\n        'column',\n        selectionGroup\n      );\n      // Check if there are any merges\n      if (joinedGroup.c1 != Number.MAX_VALUE) {\n        c1 = joinedGroup.c1;\n        c2 = joinedGroup.c2;\n      }\n\n      cursorRow = accel ? 0 : shift ? model.cursorRow : 0;\n      cursorColumn = accel ? column : shift ? model.cursorColumn : column;\n      clear = accel ? 'none' : shift ? 'current' : 'all';\n    } else {\n      r1 = accel ? row : shift ? model.cursorRow : row;\n      r2 = row;\n      c1 = accel ? column : shift ? model.cursorColumn : column;\n      c2 = column;\n      cursorRow = accel ? row : shift ? model.cursorRow : row;\n      cursorColumn = accel ? column : shift ? model.cursorColumn : column;\n      clear = accel ? 'none' : shift ? 'current' : 'all';\n    }\n\n    // Make the selection.\n    model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n  }\n\n  /**\n   * Handle the mouse move event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse move event of interest.\n   */\n  onMouseMove(grid: DataGrid, event: MouseEvent): void {\n    // Fetch the press data.\n    const data = this._pressData;\n\n    // Bail early if there is no press data.\n    if (!data) {\n      return;\n    }\n\n    // Handle a row resize.\n    if (data.type === 'row-resize') {\n      let dy = event.clientY - data.clientY;\n      grid.resizeRow(data.region, data.index, data.size + dy);\n      return;\n    }\n\n    // Handle a column resize.\n    if (data.type === 'column-resize') {\n      let dx = event.clientX - data.clientX;\n      grid.resizeColumn(data.region, data.index, data.size + dx);\n      return;\n    }\n\n    // Otherwise, it's a select.\n\n    // Mouse moves during a corner header press are a no-op.\n    if (data.region === 'corner-header') {\n      return;\n    }\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Bail early if the selection model was removed.\n    if (!model) {\n      return;\n    }\n\n    // Map to local coordinates.\n    let { lx, ly } = grid.mapToLocal(event.clientX, event.clientY);\n\n    // Update the local mouse coordinates in the press data.\n    data.localX = lx;\n    data.localY = ly;\n\n    // Fetch the grid geometry.\n    let hw = grid.headerWidth;\n    let hh = grid.headerHeight;\n    let vpw = grid.viewportWidth;\n    let vph = grid.viewportHeight;\n    let sx = grid.scrollX;\n    let sy = grid.scrollY;\n    let msx = grid.maxScrollY;\n    let msy = grid.maxScrollY;\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Set up the timeout variable.\n    let timeout = -1;\n\n    // Compute the timemout based on hit region and mouse position.\n    if (data.region === 'row-header' || mode === 'row') {\n      if (ly < hh && sy > 0) {\n        timeout = Private.computeTimeout(hh - ly);\n      } else if (ly >= vph && sy < msy) {\n        timeout = Private.computeTimeout(ly - vph);\n      }\n    } else if (data.region === 'column-header' || mode === 'column') {\n      if (lx < hw && sx > 0) {\n        timeout = Private.computeTimeout(hw - lx);\n      } else if (lx >= vpw && sx < msx) {\n        timeout = Private.computeTimeout(lx - vpw);\n      }\n    } else {\n      if (lx < hw && sx > 0) {\n        timeout = Private.computeTimeout(hw - lx);\n      } else if (lx >= vpw && sx < msx) {\n        timeout = Private.computeTimeout(lx - vpw);\n      } else if (ly < hh && sy > 0) {\n        timeout = Private.computeTimeout(hh - ly);\n      } else if (ly >= vph && sy < msy) {\n        timeout = Private.computeTimeout(ly - vph);\n      }\n    }\n\n    // Update or initiate the autoselect if needed.\n    if (timeout >= 0) {\n      if (data.timeout < 0) {\n        data.timeout = timeout;\n        setTimeout(() => {\n          Private.autoselect(grid, data);\n        }, timeout);\n      } else {\n        data.timeout = timeout;\n      }\n      return;\n    }\n\n    // Otherwise, clear the autoselect timeout.\n    data.timeout = -1;\n\n    // Map the position to virtual coordinates.\n    let { vx, vy } = grid.mapToVirtual(event.clientX, event.clientY);\n\n    // Clamp the coordinates to the limits.\n    vx = Math.max(0, Math.min(vx, grid.bodyWidth - 1));\n    vy = Math.max(0, Math.min(vy, grid.bodyHeight - 1));\n\n    // Set up the selection variables.\n    let r1: number;\n    let c1: number;\n    let r2: number;\n    let c2: number;\n    let cursorRow = model.cursorRow;\n    let cursorColumn = model.cursorColumn;\n    let clear: SelectionModel.ClearMode = 'current';\n\n    // Compute the selection based pressed region.\n    if (data.region === 'row-header' || mode === 'row') {\n      r1 = data.row;\n      r2 = grid.rowAt('body', vy);\n\n      const selectionGroup: CellGroup = { r1: r1, c1: 0, r2: r2, c2: 0 };\n      const joinedGroup = CellGroup.joinCellGroupsIntersectingAtAxis(\n        grid.dataModel!,\n        ['row-header', 'body'],\n        'row',\n        selectionGroup\n      );\n      // Check if there are any merges\n      if (joinedGroup.r1 != Number.MAX_VALUE) {\n        r1 = Math.min(r1, joinedGroup.r1);\n        r2 = Math.max(r2, joinedGroup.r2);\n      }\n\n      c1 = 0;\n      c2 = Infinity;\n    } else if (data.region === 'column-header' || mode === 'column') {\n      r1 = 0;\n      r2 = Infinity;\n      c1 = data.column;\n      c2 = grid.columnAt('body', vx);\n\n      const selectionGroup: CellGroup = { r1: 0, c1: c1, r2: 0, c2: c2 };\n      const joinedGroup = CellGroup.joinCellGroupsIntersectingAtAxis(\n        grid.dataModel!,\n        ['column-header', 'body'],\n        'column',\n        selectionGroup\n      );\n      // Check if there are any merges\n      if (joinedGroup.c1 != Number.MAX_VALUE) {\n        c1 = joinedGroup.c1;\n        c2 = joinedGroup.c2;\n      }\n    } else {\n      r1 = cursorRow;\n      r2 = grid.rowAt('body', vy);\n      c1 = cursorColumn;\n      c2 = grid.columnAt('body', vx);\n    }\n\n    // Make the selection.\n    model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n  }\n\n  /**\n   * Handle the mouse up event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse up event of interest.\n   */\n  onMouseUp(grid: DataGrid, event: MouseEvent): void {\n    this.release();\n  }\n\n  /**\n   * Handle the mouse double click event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse up event of interest.\n   */\n  onMouseDoubleClick(grid: DataGrid, event: MouseEvent): void {\n    if (!grid.dataModel) {\n      this.release();\n      return;\n    }\n\n    // Unpack the event.\n    let { clientX, clientY } = event;\n\n    // Hit test the grid.\n    let hit = grid.hitTest(clientX, clientY);\n\n    // Unpack the hit test.\n    let { region, row, column } = hit;\n\n    if (region === 'void') {\n      this.release();\n      return;\n    }\n\n    if (region === 'body') {\n      if (grid.editable) {\n        const cell: CellEditor.CellConfig = {\n          grid: grid,\n          row: row,\n          column: column\n        };\n        grid.editorController!.edit(cell);\n      }\n    }\n\n    this.release();\n  }\n\n  /**\n   * Handle the context menu event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The context menu event of interest.\n   */\n  onContextMenu(grid: DataGrid, event: MouseEvent): void {\n    // TODO support user-defined context menus\n  }\n\n  /**\n   * Handle the wheel event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The wheel event of interest.\n   */\n  onWheel(grid: DataGrid, event: WheelEvent): void {\n    // Bail if a mouse press is in progress.\n    if (this._pressData) {\n      return;\n    }\n\n    // Extract the delta X and Y movement.\n    let dx = event.deltaX;\n    let dy = event.deltaY;\n\n    // Convert the delta values to pixel values.\n    switch (event.deltaMode) {\n      case 0: // DOM_DELTA_PIXEL\n        break;\n      case 1: // DOM_DELTA_LINE\n        let ds = grid.defaultSizes;\n        dx *= ds.columnWidth;\n        dy *= ds.rowHeight;\n        break;\n      case 2: // DOM_DELTA_PAGE\n        dx *= grid.pageWidth;\n        dy *= grid.pageHeight;\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Scroll by the desired amount.\n    grid.scrollBy(dx, dy);\n  }\n\n  /**\n   * Convert a resize handle into a cursor.\n   */\n  cursorForHandle(handle: ResizeHandle): string {\n    return Private.cursorMap[handle];\n  }\n\n  /**\n   * Get the current pressData\n   */\n  get pressData(): PressData.PressData | null {\n    return this._pressData;\n  }\n\n  private _disposed = false;\n  protected _pressData: PressData.PressData | null = null;\n}\n\n/**\n * A type alias for the resize handle types.\n */\nexport type ResizeHandle =\n  | 'top'\n  | 'left'\n  | 'right'\n  | 'bottom'\n  | 'none'\n  | 'hyperlink';\n\n/**\n * The namespace for the pressdata.\n */\nexport namespace PressData {\n  /**\n   * A type alias for the row resize data.\n   */\n  export type RowResizeData = {\n    /**\n     * The descriminated type for the data.\n     */\n    readonly type: 'row-resize';\n\n    /**\n     * The row region which holds the section being resized.\n     */\n    readonly region: DataModel.RowRegion;\n\n    /**\n     * The index of the section being resized.\n     */\n    readonly index: number;\n\n    /**\n     * The original size of the section.\n     */\n    readonly size: number;\n\n    /**\n     * The original client Y position of the mouse.\n     */\n    readonly clientY: number;\n\n    /**\n     * The disposable to clear the cursor override.\n     */\n    readonly override: IDisposable;\n  };\n\n  /**\n   * A type alias for the column resize data.\n   */\n  export type ColumnResizeData = {\n    /**\n     * The descriminated type for the data.\n     */\n    readonly type: 'column-resize';\n\n    /**\n     * The column region which holds the section being resized.\n     */\n    readonly region: DataModel.ColumnRegion;\n\n    /**\n     * The index of the section being resized.\n     */\n    readonly index: number;\n\n    /**\n     * The original size of the section.\n     */\n    readonly size: number;\n\n    /**\n     * The original client X position of the mouse.\n     */\n    readonly clientX: number;\n\n    /**\n     * The disposable to clear the cursor override.\n     */\n    readonly override: IDisposable;\n  };\n\n  /**\n   * A type alias for the select data.\n   */\n  export type SelectData = {\n    /**\n     * The descriminated type for the data.\n     */\n    readonly type: 'select';\n\n    /**\n     * The original region for the mouse press.\n     */\n    readonly region: DataModel.CellRegion;\n\n    /**\n     * The original row that was selected.\n     */\n    readonly row: number;\n\n    /**\n     * The original column that was selected.\n     */\n    readonly column: number;\n\n    /**\n     * The disposable to clear the cursor override.\n     */\n    readonly override: IDisposable;\n\n    /**\n     * The current local X position of the mouse.\n     */\n    localX: number;\n\n    /**\n     * The current local Y position of the mouse.\n     */\n    localY: number;\n\n    /**\n     * The timeout delay for the autoselect loop.\n     */\n    timeout: number;\n  };\n\n  /**\n   * A type alias for the resize handler press data.\n   */\n  export type PressData = RowResizeData | ColumnResizeData | SelectData;\n}\n\n/**\n * The namespace for the module implementation details.\n */\nexport namespace Private {\n  /**\n   * Creates a CellConfig object from a hit region.\n   */\n  export function createCellConfigObject(\n    grid: DataGrid,\n    hit: DataGrid.HitTestResult\n  ): CellRenderer.CellConfig | undefined {\n    const { region, row, column } = hit;\n\n    // Terminate call if region is void.\n    if (region === 'void') {\n      return undefined;\n    }\n\n    // Augment hit region params with value and metadata.\n    const value = grid.dataModel!.data(region, row, column);\n    const metadata = grid.dataModel!.metadata(region, row, column);\n\n    // Create cell config object to retrieve cell renderer.\n    const config = {\n      ...hit,\n      value: value,\n      metadata: metadata\n    } as CellRenderer.CellConfig;\n\n    return config;\n  }\n\n  /**\n   * Get the resize handle for a grid hit test.\n   */\n  export function resizeHandleForHitTest(\n    hit: DataGrid.HitTestResult\n  ): ResizeHandle {\n    // Fetch the row and column.\n    let r = hit.row;\n    let c = hit.column;\n\n    // Fetch the leading and trailing sizes.\n    let lw = hit.x;\n    let lh = hit.y;\n    let tw = hit.width - hit.x;\n    let th = hit.height - hit.y;\n\n    // Set up the result variable.\n    let result: ResizeHandle;\n\n    // Dispatch based on hit test region.\n    switch (hit.region) {\n      case 'corner-header':\n        if (c > 0 && lw <= 5) {\n          result = 'left';\n        } else if (tw <= 6) {\n          result = 'right';\n        } else if (r > 0 && lh <= 5) {\n          result = 'top';\n        } else if (th <= 6) {\n          result = 'bottom';\n        } else {\n          result = 'none';\n        }\n        break;\n      case 'column-header':\n        if (c > 0 && lw <= 5) {\n          result = 'left';\n        } else if (tw <= 6) {\n          result = 'right';\n        } else if (r > 0 && lh <= 5) {\n          result = 'top';\n        } else if (th <= 6) {\n          result = 'bottom';\n        } else {\n          result = 'none';\n        }\n        break;\n      case 'row-header':\n        if (c > 0 && lw <= 5) {\n          result = 'left';\n        } else if (tw <= 6) {\n          result = 'right';\n        } else if (r > 0 && lh <= 5) {\n          result = 'top';\n        } else if (th <= 6) {\n          result = 'bottom';\n        } else {\n          result = 'none';\n        }\n        break;\n      case 'body':\n        result = 'none';\n        break;\n      case 'void':\n        result = 'none';\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Return the result.\n    return result;\n  }\n\n  /**\n   * A timer callback for the autoselect loop.\n   *\n   * @param grid - The datagrid of interest.\n   *\n   * @param data - The select data of interest.\n   */\n  export function autoselect(grid: DataGrid, data: PressData.SelectData): void {\n    // Bail early if the timeout has been reset.\n    if (data.timeout < 0) {\n      return;\n    }\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Bail early if the selection model has been removed.\n    if (!model) {\n      return;\n    }\n\n    // Fetch the current selection.\n    let cs = model.currentSelection();\n\n    // Bail early if there is no current selection.\n    if (!cs) {\n      return;\n    }\n\n    // Fetch local X and Y coordinates of the mouse.\n    let lx = data.localX;\n    let ly = data.localY;\n\n    // Set up the selection variables.\n    let r1 = cs.r1;\n    let c1 = cs.c1;\n    let r2 = cs.r2;\n    let c2 = cs.c2;\n    let cursorRow = model.cursorRow;\n    let cursorColumn = model.cursorColumn;\n    let clear: SelectionModel.ClearMode = 'current';\n\n    // Fetch the grid geometry.\n    let hw = grid.headerWidth;\n    let hh = grid.headerHeight;\n    let vpw = grid.viewportWidth;\n    let vph = grid.viewportHeight;\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Update the selection based on the hit region.\n    if (data.region === 'row-header' || mode === 'row') {\n      r2 += ly <= hh ? -1 : ly >= vph ? 1 : 0;\n    } else if (data.region === 'column-header' || mode === 'column') {\n      c2 += lx <= hw ? -1 : lx >= vpw ? 1 : 0;\n    } else {\n      r2 += ly <= hh ? -1 : ly >= vph ? 1 : 0;\n      c2 += lx <= hw ? -1 : lx >= vpw ? 1 : 0;\n    }\n\n    // Update the current selection.\n    model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid based on the hit region.\n    if (data.region === 'row-header' || mode === 'row') {\n      grid.scrollToRow(cs.r2);\n    } else if (data.region === 'column-header' || mode == 'column') {\n      grid.scrollToColumn(cs.c2);\n    } else if (mode === 'cell') {\n      grid.scrollToCell(cs.r2, cs.c2);\n    }\n\n    // Schedule the next call with the current timeout.\n    setTimeout(() => {\n      autoselect(grid, data);\n    }, data.timeout);\n  }\n\n  /**\n   * Compute the scroll timeout for the given delta distance.\n   *\n   * @param delta - The delta pixels from the origin.\n   *\n   * @returns The scaled timeout in milliseconds.\n   */\n  export function computeTimeout(delta: number): number {\n    return 5 + 120 * (1 - Math.min(128, Math.abs(delta)) / 128);\n  }\n\n  /**\n   * A mapping of resize handle to cursor.\n   */\n  export const cursorMap = {\n    top: 'ns-resize',\n    left: 'ew-resize',\n    right: 'ew-resize',\n    bottom: 'ns-resize',\n    hyperlink: 'pointer',\n    none: 'default'\n  };\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { IIterator, some } from '@lumino/algorithm';\n\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport { DataModel } from './datamodel';\n\n/**\n * A base class for creating data grid selection models.\n *\n * #### Notes\n * If the predefined selection models are insufficient for a particular\n * use case, a custom model can be defined which derives from this class.\n */\nexport abstract class SelectionModel {\n  /**\n   * Construct a new selection model.\n   *\n   * @param options - The options for initializing the model.\n   */\n  constructor(options: SelectionModel.IOptions) {\n    this.dataModel = options.dataModel;\n    this._selectionMode = options.selectionMode || 'cell';\n    this.dataModel.changed.connect(this.onDataModelChanged, this);\n  }\n\n  /**\n   * Whether the selection model is empty.\n   *\n   * #### Notes\n   * An empty selection model will yield an empty `selections` iterator.\n   */\n  abstract readonly isEmpty: boolean;\n\n  /**\n   * The row index of the cursor.\n   *\n   * This is `-1` if the selection model is empty.\n   */\n  abstract readonly cursorRow: number;\n\n  /**\n   * The column index of the cursor.\n   *\n   * This is `-1` if the selection model is empty.\n   */\n  abstract readonly cursorColumn: number;\n\n  /**\n   * Move cursor down/up/left/right while making sure it remains\n   * within the bounds of selected rectangles\n   *\n   * @param direction - The direction of the movement.\n   */\n  abstract moveCursorWithinSelections(\n    direction: SelectionModel.CursorMoveDirection\n  ): void;\n\n  /**\n   * Get the current selection in the selection model.\n   *\n   * @returns The current selection or `null`.\n   *\n   * #### Notes\n   * This is the selection which holds the cursor.\n   */\n  abstract currentSelection(): SelectionModel.Selection | null;\n\n  /**\n   * Get an iterator of the selections in the model.\n   *\n   * @returns A new iterator of the selections in the model.\n   *\n   * #### Notes\n   * The data grid will render the selections in order.\n   */\n  abstract selections(): IIterator<SelectionModel.Selection>;\n\n  /**\n   * Select the specified cells.\n   *\n   * @param args - The arguments for the selection.\n   */\n  abstract select(args: SelectionModel.SelectArgs): void;\n\n  /**\n   * Clear all selections in the selection model.\n   */\n  abstract clear(): void;\n\n  /**\n   * A signal emitted when the selection model has changed.\n   */\n  get changed(): ISignal<this, void> {\n    return this._changed;\n  }\n\n  /**\n   * The data model associated with the selection model.\n   */\n  readonly dataModel: DataModel;\n\n  /**\n   * Get the selection mode for the model.\n   */\n  get selectionMode(): SelectionModel.SelectionMode {\n    return this._selectionMode;\n  }\n\n  /**\n   * Set the selection mode for the model.\n   *\n   * #### Notes\n   * This will clear the selection model.\n   */\n  set selectionMode(value: SelectionModel.SelectionMode) {\n    // Bail early if the mode does not change.\n    if (this._selectionMode === value) {\n      return;\n    }\n\n    // Update the internal mode.\n    this._selectionMode = value;\n\n    // Clear the current selections.\n    this.clear();\n  }\n\n  /**\n   * Test whether any selection intersects a row.\n   *\n   * @param index - The row index of interest.\n   *\n   * @returns Whether any selection intersects the row.\n   *\n   * #### Notes\n   * This method may be reimplemented in a subclass.\n   */\n  isRowSelected(index: number): boolean {\n    return some(this.selections(), s => Private.containsRow(s, index));\n  }\n\n  /**\n   * Test whether any selection intersects a column.\n   *\n   * @param index - The column index of interest.\n   *\n   * @returns Whether any selection intersects the column.\n   *\n   * #### Notes\n   * This method may be reimplemented in a subclass.\n   */\n  isColumnSelected(index: number): boolean {\n    return some(this.selections(), s => Private.containsColumn(s, index));\n  }\n\n  /**\n   * Test whether any selection intersects a cell.\n   *\n   * @param row - The row index of interest.\n   *\n   * @param column - The column index of interest.\n   *\n   * @returns Whether any selection intersects the cell.\n   *\n   * #### Notes\n   * This method may be reimplemented in a subclass.\n   */\n  isCellSelected(row: number, column: number): boolean {\n    return some(this.selections(), s => Private.containsCell(s, row, column));\n  }\n\n  /**\n   * A signal handler for the data model `changed` signal.\n   *\n   * @param args - The arguments for the signal.\n   *\n   * #### Notes\n   * Selection model implementations should update their selections\n   * in a manner that is relevant for the changes to the data model.\n   *\n   * The default implementation of this method is a no-op.\n   */\n  protected onDataModelChanged(\n    sender: DataModel,\n    args: DataModel.ChangedArgs\n  ): void {\n    // pass\n  }\n\n  /**\n   * Emit the `changed` signal for the selection model.\n   *\n   * #### Notes\n   * Subclasses should call this method whenever the selection model\n   * has changed so that attached data grids can update themselves.\n   */\n  protected emitChanged(): void {\n    this._changed.emit(undefined);\n  }\n\n  private _changed = new Signal<this, void>(this);\n  private _selectionMode: SelectionModel.SelectionMode = 'cell';\n}\n\n/**\n * The namespace for the `SelectionModel` class statics.\n */\nexport namespace SelectionModel {\n  /**\n   * A type alias for the selection mode.\n   */\n  export type SelectionMode = 'row' | 'column' | 'cell';\n\n  /**\n   * A type alias for the cursor move direction.\n   */\n  export type CursorMoveDirection = 'up' | 'down' | 'left' | 'right' | 'none';\n\n  /**\n   * A type alias for the clear mode.\n   */\n  export type ClearMode = 'all' | 'current' | 'none';\n\n  /**\n   * A type alias for the select args.\n   */\n  export type SelectArgs = {\n    /**\n     * The first row of the selection.\n     *\n     * This may be greater than `r2`.\n     */\n    r1: number;\n\n    /**\n     * The first column of the selection.\n     *\n     * This may be greater than `c2`.\n     */\n    c1: number;\n\n    /**\n     * The last row of the selection.\n     *\n     * This may be less than `r1`.\n     */\n    r2: number;\n\n    /**\n     * The last column of the selection.\n     *\n     * This may be less than `c1`.\n     */\n    c2: number;\n\n    /**\n     * The row index for the cursor.\n     *\n     * This should be contained within the selection.\n     */\n    cursorRow: number;\n\n    /**\n     * The column index for the cursor.\n     *\n     * This should be contained within the selection.\n     */\n    cursorColumn: number;\n\n    /**\n     * Which of the existing selections to clear.\n     */\n    clear: ClearMode;\n  };\n\n  /**\n   * A type alias for a selection in a selection model.\n   */\n  export type Selection = {\n    /**\n     * The first row of the selection.\n     *\n     * This may be greater than `r2`.\n     */\n    readonly r1: number;\n\n    /**\n     * The first column of the selection.\n     *\n     * This may be greater than `c2`.\n     */\n    readonly c1: number;\n\n    /**\n     * The last row of the selection.\n     *\n     * This may be less than `r1`.\n     */\n    readonly r2: number;\n\n    /**\n     * The last column of the selection.\n     *\n     * This may be less than `c1`.\n     */\n    readonly c2: number;\n  };\n\n  /**\n   * An options object for initializing a selection model.\n   */\n  export interface IOptions {\n    /**\n     * The data model for the selection model.\n     */\n    dataModel: DataModel;\n\n    /**\n     * The selection mode for the model.\n     *\n     * The default is `'cell'`.\n     */\n    selectionMode?: SelectionMode;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * Test whether a selection contains a given row.\n   */\n  export function containsRow(\n    selection: SelectionModel.Selection,\n    row: number\n  ): boolean {\n    let { r1, r2 } = selection;\n    return (row >= r1 && row <= r2) || (row >= r2 && row <= r1);\n  }\n\n  /**\n   * Test whether a selection contains a given column.\n   */\n  export function containsColumn(\n    selection: SelectionModel.Selection,\n    column: number\n  ): boolean {\n    let { c1, c2 } = selection;\n    return (column >= c1 && column <= c2) || (column >= c2 && column <= c1);\n  }\n\n  /**\n   * Test whether a selection contains a given cell.\n   */\n  export function containsCell(\n    selection: SelectionModel.Selection,\n    row: number,\n    column: number\n  ): boolean {\n    return containsRow(selection, row) && containsColumn(selection, column);\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n\nimport { Message } from '@lumino/messaging';\n\nimport { Widget } from '@lumino/widgets';\n\n/**\n * A widget which implements a notification popup.\n */\nexport class Notification extends Widget {\n  /**\n   * Construct a new notification.\n   *\n   * @param options - The options for initializing the notification.\n   */\n  constructor(options: Notification.IOptions) {\n    super({ node: Private.createNode() });\n    this.addClass('lm-DataGrid-notification');\n    this.setFlag(Widget.Flag.DisallowLayout);\n\n    this._target = options.target;\n    this._message = options.message || '';\n    this._placement = options.placement || 'bottom';\n\n    Widget.attach(this, document.body);\n\n    if (options.timeout && options.timeout > 0) {\n      setTimeout(() => {\n        this.close();\n      }, options.timeout);\n    }\n  }\n\n  /**\n   * Handle the DOM events for the notification.\n   *\n   * @param event - The DOM event sent to the notification.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events on the notification's DOM node.\n   *\n   * This should not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'mousedown':\n        this._evtMouseDown(event as MouseEvent);\n        break;\n      case 'contextmenu':\n        event.preventDefault();\n        event.stopPropagation();\n        break;\n    }\n  }\n\n  /**\n   * Get the placement of the notification.\n   */\n  get placement(): Notification.Placement {\n    return this._placement;\n  }\n\n  /**\n   * Set the placement of the notification.\n   */\n  set placement(value: Notification.Placement) {\n    // Do nothing if the placement does not change.\n    if (this._placement === value) {\n      return;\n    }\n\n    // Update the internal placement.\n    this._placement = value;\n\n    // Schedule an update for notification.\n    this.update();\n  }\n\n  /**\n   * Get the current value of the message.\n   */\n  get message(): string {\n    return this._message;\n  }\n\n  /**\n   * Set the current value of the message.\n   *\n   */\n  set message(value: string) {\n    // Do nothing if the value does not change.\n    if (this._message === value) {\n      return;\n    }\n\n    // Update the internal value.\n    this._message = value;\n\n    // Schedule an update for notification.\n    this.update();\n  }\n\n  /**\n   * Get the node presenting the message.\n   */\n  get messageNode(): HTMLSpanElement {\n    return this.node.getElementsByClassName(\n      'lm-DataGrid-notificationMessage'\n    )[0] as HTMLSpanElement;\n  }\n\n  /**\n   * A method invoked on a 'before-attach' message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    this.node.addEventListener('mousedown', this);\n    this.update();\n  }\n\n  /**\n   * A method invoked on an 'after-detach' message.\n   */\n  protected onAfterDetach(msg: Message): void {\n    this.node.removeEventListener('mousedown', this);\n  }\n\n  /**\n   * A method invoked on an 'update-request' message.\n   */\n  protected onUpdateRequest(msg: Message): void {\n    const targetRect = this._target.getBoundingClientRect();\n    const style = this.node.style;\n\n    switch (this._placement) {\n      case 'bottom':\n        style.left = targetRect.left + 'px';\n        style.top = targetRect.bottom + 'px';\n        break;\n      case 'top':\n        style.left = targetRect.left + 'px';\n        style.height = targetRect.top + 'px';\n        style.top = '0';\n        style.alignItems = 'flex-end';\n        style.justifyContent = 'flex-end';\n        break;\n      case 'left':\n        style.left = '0';\n        style.width = targetRect.left + 'px';\n        style.top = targetRect.top + 'px';\n        style.alignItems = 'flex-end';\n        style.justifyContent = 'flex-end';\n        break;\n      case 'right':\n        style.left = targetRect.right + 'px';\n        style.top = targetRect.top + 'px';\n        break;\n    }\n\n    this.messageNode.innerHTML = this._message;\n  }\n\n  /**\n   * Handle the `'mousedown'` event for the notification.\n   */\n  private _evtMouseDown(event: MouseEvent): void {\n    // Do nothing if it's not a left mouse press.\n    if (event.button !== 0) {\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n    this.close();\n  }\n\n  private _target: HTMLElement;\n  private _message: string = '';\n  private _placement: Notification.Placement;\n}\n\n/**\n * The namespace for the `Notification` class statics.\n */\nexport namespace Notification {\n  /**\n   * A type alias for a notification placement.\n   */\n  export type Placement = 'top' | 'bottom' | 'left' | 'right';\n\n  /**\n   * An options object for creating a notification.\n   */\n  export interface IOptions {\n    /**\n     * Target element to attach notification to.\n     *\n     */\n    target: HTMLElement;\n\n    /**\n     * The message to show on notification.\n     */\n    message?: string;\n\n    /**\n     * The placement of the notification.\n     *\n     * The default is `'bottom'`.\n     */\n    placement?: Placement;\n\n    /**\n     * Duration in ms after which to close notification popup.\n     *\n     * The default is undefined, and notification is kept visible\n     * Timeout value needs to be greater than zero\n     */\n    timeout?: number;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * Create the DOM node for notification.\n   */\n  export function createNode(): HTMLElement {\n    const node = document.createElement('div');\n    const container = document.createElement('div');\n    container.className = 'lm-DataGrid-notificationContainer';\n    const message = document.createElement('span');\n    message.className = 'lm-DataGrid-notificationMessage';\n    container.appendChild(message);\n    node.appendChild(container);\n\n    return node;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { IIterator, iter } from '@lumino/algorithm';\n\nimport { DataModel } from './datamodel';\n\nimport { SelectionModel } from './selectionmodel';\n\n/**\n * A basic selection model implementation.\n *\n * #### Notes\n * This selection model is sufficient for most use cases where\n * structural knowledge of the data source is *not* required.\n */\nexport class BasicSelectionModel extends SelectionModel {\n  /**\n   * Whether the selection model is empty.\n   */\n  get isEmpty(): boolean {\n    return this._selections.length === 0;\n  }\n\n  /**\n   * The row index of the cursor.\n   */\n  get cursorRow(): number {\n    return this._cursorRow;\n  }\n\n  /**\n   * The column index of the cursor.\n   */\n  get cursorColumn(): number {\n    return this._cursorColumn;\n  }\n\n  /**\n   * Move cursor down/up/left/right while making sure it remains\n   * within the bounds of selected rectangles\n   *\n   * @param direction - The direction of the movement.\n   */\n  moveCursorWithinSelections(\n    direction: SelectionModel.CursorMoveDirection\n  ): void {\n    // Bail early if there are no selections or no existing cursor\n    if (this.isEmpty || this.cursorRow === -1 || this._cursorColumn === -1) {\n      return;\n    }\n\n    // Bail early if only single cell is selected\n    const firstSelection = this._selections[0];\n    if (\n      this._selections.length === 1 &&\n      firstSelection.r1 === firstSelection.r2 &&\n      firstSelection.c1 === firstSelection.c2\n    ) {\n      return;\n    }\n\n    // start from last selection rectangle\n    if (this._cursorRectIndex === -1) {\n      this._cursorRectIndex = this._selections.length - 1;\n    }\n\n    let cursorRect = this._selections[this._cursorRectIndex];\n    const dr = direction === 'down' ? 1 : direction === 'up' ? -1 : 0;\n    const dc = direction === 'right' ? 1 : direction === 'left' ? -1 : 0;\n    let newRow = this._cursorRow + dr;\n    let newColumn = this._cursorColumn + dc;\n    const r1 = Math.min(cursorRect.r1, cursorRect.r2);\n    const r2 = Math.max(cursorRect.r1, cursorRect.r2);\n    const c1 = Math.min(cursorRect.c1, cursorRect.c2);\n    const c2 = Math.max(cursorRect.c1, cursorRect.c2);\n\n    const moveToNextRect = () => {\n      this._cursorRectIndex =\n        (this._cursorRectIndex + 1) % this._selections.length;\n      cursorRect = this._selections[this._cursorRectIndex];\n      newRow = Math.min(cursorRect.r1, cursorRect.r2);\n      newColumn = Math.min(cursorRect.c1, cursorRect.c2);\n    };\n\n    const moveToPreviousRect = () => {\n      this._cursorRectIndex =\n        this._cursorRectIndex === 0\n          ? this._selections.length - 1\n          : this._cursorRectIndex - 1;\n      cursorRect = this._selections[this._cursorRectIndex];\n      newRow = Math.max(cursorRect.r1, cursorRect.r2);\n      newColumn = Math.max(cursorRect.c1, cursorRect.c2);\n    };\n\n    if (newRow > r2) {\n      newRow = r1;\n      newColumn += 1;\n      if (newColumn > c2) {\n        moveToNextRect();\n      }\n    } else if (newRow < r1) {\n      newRow = r2;\n      newColumn -= 1;\n      if (newColumn < c1) {\n        moveToPreviousRect();\n      }\n    } else if (newColumn > c2) {\n      newColumn = c1;\n      newRow += 1;\n      if (newRow > r2) {\n        moveToNextRect();\n      }\n    } else if (newColumn < c1) {\n      newColumn = c2;\n      newRow -= 1;\n      if (newRow < r1) {\n        moveToPreviousRect();\n      }\n    }\n\n    this._cursorRow = newRow;\n    this._cursorColumn = newColumn;\n\n    // Emit the changed signal.\n    this.emitChanged();\n  }\n\n  /**\n   * Get the current selection in the selection model.\n   *\n   * @returns The current selection or `null`.\n   *\n   * #### Notes\n   * This is the selection which holds the cursor.\n   */\n  currentSelection(): SelectionModel.Selection | null {\n    return this._selections[this._selections.length - 1] || null;\n  }\n\n  /**\n   * Get an iterator of the selections in the model.\n   *\n   * @returns A new iterator of the current selections.\n   *\n   * #### Notes\n   * The data grid will render the selections in order.\n   */\n  selections(): IIterator<SelectionModel.Selection> {\n    return iter(this._selections);\n  }\n\n  /**\n   * Select the specified cells.\n   *\n   * @param args - The arguments for the selection.\n   */\n  select(args: SelectionModel.SelectArgs): void {\n    // Fetch the current row and column counts;\n    let rowCount = this.dataModel.rowCount('body');\n    let columnCount = this.dataModel.columnCount('body');\n\n    // Bail early if there is no content.\n    if (rowCount <= 0 || columnCount <= 0) {\n      return;\n    }\n\n    // Unpack the arguments.\n    let { r1, c1, r2, c2, cursorRow, cursorColumn, clear } = args;\n\n    // Clear the necessary selections.\n    if (clear === 'all') {\n      this._selections.length = 0;\n    } else if (clear === 'current') {\n      this._selections.pop();\n    }\n\n    // Clamp to the data model bounds.\n    r1 = Math.max(0, Math.min(r1, rowCount - 1));\n    r2 = Math.max(0, Math.min(r2, rowCount - 1));\n    c1 = Math.max(0, Math.min(c1, columnCount - 1));\n    c2 = Math.max(0, Math.min(c2, columnCount - 1));\n\n    // Indicate if a row/column has already been selected.\n    let alreadySelected = false;\n\n    // Handle the selection mode.\n    if (this.selectionMode === 'row') {\n      c1 = 0;\n      c2 = columnCount - 1;\n      alreadySelected =\n        this._selections.filter(selection => selection.r1 === r1).length !== 0;\n      // Remove from selections if already selected.\n      this._selections = alreadySelected\n        ? this._selections.filter(selection => selection.r1 !== r1)\n        : this._selections;\n    } else if (this.selectionMode === 'column') {\n      r1 = 0;\n      r2 = rowCount - 1;\n      alreadySelected =\n        this._selections.filter(selection => selection.c1 === c1).length !== 0;\n      // Remove from selections if already selected.\n      this._selections = alreadySelected\n        ? this._selections.filter(selection => selection.c1 !== c1)\n        : this._selections;\n    }\n\n    // Alias the cursor row and column.\n    let cr = cursorRow;\n    let cc = cursorColumn;\n\n    // Compute the new cursor location.\n    if (cr < 0 || (cr < r1 && cr < r2) || (cr > r1 && cr > r2)) {\n      cr = r1;\n    }\n    if (cc < 0 || (cc < c1 && cc < c2) || (cc > c1 && cc > c2)) {\n      cc = c1;\n    }\n\n    // Update the cursor.\n    this._cursorRow = cr;\n    this._cursorColumn = cc;\n    this._cursorRectIndex = this._selections.length;\n\n    // Add the new selection if it wasn't already selected.\n    if (!alreadySelected) {\n      this._selections.push({ r1, c1, r2, c2 });\n    }\n\n    // Emit the changed signal.\n    this.emitChanged();\n  }\n\n  /**\n   * Clear all selections in the selection model.\n   */\n  clear(): void {\n    // Bail early if there are no selections.\n    if (this._selections.length === 0) {\n      return;\n    }\n\n    // Reset the internal state.\n    this._cursorRow = -1;\n    this._cursorColumn = -1;\n    this._cursorRectIndex = -1;\n    this._selections.length = 0;\n\n    // Emit the changed signal.\n    this.emitChanged();\n  }\n\n  /**\n   * A signal handler for the data model `changed` signal.\n   *\n   * @param args - The arguments for the signal.\n   */\n  protected onDataModelChanged(\n    sender: DataModel,\n    args: DataModel.ChangedArgs\n  ): void {\n    // Bail early if the model has no current selections.\n    if (this._selections.length === 0) {\n      return;\n    }\n\n    // Bail early if the cells have changed in place.\n    if (args.type === 'cells-changed') {\n      return;\n    }\n\n    // Bail early if there is no change to the row or column count.\n    if (args.type === 'rows-moved' || args.type === 'columns-moved') {\n      return;\n    }\n\n    // Fetch the last row and column index.\n    let lr = sender.rowCount('body') - 1;\n    let lc = sender.columnCount('body') - 1;\n\n    // Bail early if the data model is empty.\n    if (lr < 0 || lc < 0) {\n      this._selections.length = 0;\n      this.emitChanged();\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = this.selectionMode;\n\n    // Set up the assignment index variable.\n    let j = 0;\n\n    // Iterate over the current selections.\n    for (let i = 0, n = this._selections.length; i < n; ++i) {\n      // Unpack the selection.\n      let { r1, c1, r2, c2 } = this._selections[i];\n\n      // Skip the selection if it will disappear.\n      if ((lr < r1 && lr < r2) || (lc < c1 && lc < c2)) {\n        continue;\n      }\n\n      // Modify the bounds based on the selection mode.\n      if (mode === 'row') {\n        r1 = Math.max(0, Math.min(r1, lr));\n        r2 = Math.max(0, Math.min(r2, lr));\n        c1 = 0;\n        c2 = lc;\n      } else if (mode === 'column') {\n        r1 = 0;\n        r2 = lr;\n        c1 = Math.max(0, Math.min(c1, lc));\n        c2 = Math.max(0, Math.min(c2, lc));\n      } else {\n        r1 = Math.max(0, Math.min(r1, lr));\n        r2 = Math.max(0, Math.min(r2, lr));\n        c1 = Math.max(0, Math.min(c1, lc));\n        c2 = Math.max(0, Math.min(c2, lc));\n      }\n\n      // Assign the modified selection to the array.\n      this._selections[j++] = { r1, c1, r2, c2 };\n    }\n\n    // Remove the stale selections.\n    this._selections.length = j;\n\n    // Emit the changed signal.\n    this.emitChanged();\n  }\n\n  private _cursorRow = -1;\n  private _cursorColumn = -1;\n  private _cursorRectIndex = -1;\n  private _selections: SelectionModel.Selection[] = [];\n}\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { IDisposable } from '@lumino/disposable';\n\nimport { DataGrid } from './datagrid';\n\nimport { SelectionModel } from './selectionmodel';\n\nimport { getKeyboardLayout } from '@lumino/keyboard';\n\nimport { Signal } from '@lumino/signaling';\n\nimport { Notification } from './notification';\n\nimport { CellGroup } from './cellgroup';\n\n/**\n * A response object returned from cell input validator\n */\nexport interface ICellInputValidatorResponse {\n  /**\n   * Flag indicating cell input is valid or not\n   */\n  valid: boolean;\n  /**\n   * Validation error message. Set only when input is invalid\n   */\n  message?: string;\n}\n\n/**\n * An object which validates cell input values.\n */\nexport interface ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(\n    cell: CellEditor.CellConfig,\n    value: any\n  ): ICellInputValidatorResponse;\n}\n\n/**\n * An object returned from cell editor after a successful edit.\n */\nexport interface ICellEditResponse {\n  /**\n   * An object which holds the configuration data for a cell.\n   */\n  cell: CellEditor.CellConfig;\n  /**\n   * Value input.\n   */\n  value: any;\n  /**\n   * Cursor move direction based on keys pressed to end the edit.\n   */\n  cursorMovement: SelectionModel.CursorMoveDirection;\n}\n\n/**\n * An object implementing cell editing.\n */\nexport interface ICellEditor {\n  /**\n   * Start editing the cell.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param options - The cell editing options.\n   */\n  edit(cell: CellEditor.CellConfig, options?: ICellEditOptions): void;\n  /**\n   * Cancel editing the cell.\n   */\n  cancel(): void;\n}\n\n// default validation error message\nconst DEFAULT_INVALID_INPUT_MESSAGE = 'Invalid input!';\n\n// A type alias for available cell data types\nexport type CellDataType =\n  | 'string'\n  | 'number'\n  | 'integer'\n  | 'boolean'\n  | 'date'\n  | 'string:option'\n  | 'number:option'\n  | 'integer:option'\n  | 'date:option'\n  | 'string:dynamic-option'\n  | 'number:dynamic-option'\n  | 'integer:dynamic-option'\n  | 'date:dynamic-option';\n\n/**\n * An object containing cell editing options.\n */\nexport interface ICellEditOptions {\n  /**\n   * Cell editor to use for editing.\n   *\n   * #### Notes\n   * This object is only used by cell editor controller.\n   * If not set, controller picks the most suitable editor\n   * for the particular cell configuration.\n   */\n  editor?: ICellEditor;\n  /**\n   * Cell input validator to use for value validation.\n   */\n  validator?: ICellInputValidator;\n  /**\n   * Callback method to call on cell edit commit.\n   */\n  onCommit?: (response: ICellEditResponse) => void;\n  /**\n   * Callback method to call on cell edit cancel.\n   */\n  onCancel?: () => void;\n}\n\n/**\n * A cell input validator object which always returns valid.\n */\nexport class PassInputValidator implements ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(\n    cell: CellEditor.CellConfig,\n    value: any\n  ): ICellInputValidatorResponse {\n    return { valid: true };\n  }\n}\n\n/**\n * Text cell input validator.\n */\nexport class TextInputValidator implements ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(\n    cell: CellEditor.CellConfig,\n    value: string\n  ): ICellInputValidatorResponse {\n    if (value === null) {\n      return { valid: true };\n    }\n\n    if (typeof value !== 'string') {\n      return {\n        valid: false,\n        message: 'Input must be valid text'\n      };\n    }\n\n    if (!isNaN(this.minLength) && value.length < this.minLength) {\n      return {\n        valid: false,\n        message: `Text length must be greater than ${this.minLength}`\n      };\n    }\n\n    if (!isNaN(this.maxLength) && value.length > this.maxLength) {\n      return {\n        valid: false,\n        message: `Text length must be less than ${this.maxLength}`\n      };\n    }\n\n    if (this.pattern && !this.pattern.test(value)) {\n      return {\n        valid: false,\n        message: `Text doesn't match the required pattern`\n      };\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Minimum text length\n   *\n   * The default is Number.NaN, meaning no minimum constraint\n   */\n  minLength: number = Number.NaN;\n  /**\n   * Maximum text length\n   *\n   * The default is Number.NaN, meaning no maximum constraint\n   */\n  maxLength: number = Number.NaN;\n  /**\n   * Required text pattern as regular expression\n   *\n   * The default is null, meaning no pattern constraint\n   */\n  pattern: RegExp | null = null;\n}\n\n/**\n * Integer cell input validator.\n */\nexport class IntegerInputValidator implements ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(\n    cell: CellEditor.CellConfig,\n    value: number\n  ): ICellInputValidatorResponse {\n    if (value === null) {\n      return { valid: true };\n    }\n\n    if (isNaN(value) || value % 1 !== 0) {\n      return {\n        valid: false,\n        message: 'Input must be valid integer'\n      };\n    }\n\n    if (!isNaN(this.min) && value < this.min) {\n      return {\n        valid: false,\n        message: `Input must be greater than ${this.min}`\n      };\n    }\n\n    if (!isNaN(this.max) && value > this.max) {\n      return {\n        valid: false,\n        message: `Input must be less than ${this.max}`\n      };\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Minimum value\n   *\n   * The default is Number.NaN, meaning no minimum constraint\n   */\n  min: number = Number.NaN;\n  /**\n   * Maximum value\n   *\n   * The default is Number.NaN, meaning no maximum constraint\n   */\n  max: number = Number.NaN;\n}\n\n/**\n * Real number cell input validator.\n */\nexport class NumberInputValidator implements ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(\n    cell: CellEditor.CellConfig,\n    value: number\n  ): ICellInputValidatorResponse {\n    if (value === null) {\n      return { valid: true };\n    }\n\n    if (isNaN(value)) {\n      return {\n        valid: false,\n        message: 'Input must be valid number'\n      };\n    }\n\n    if (!isNaN(this.min) && value < this.min) {\n      return {\n        valid: false,\n        message: `Input must be greater than ${this.min}`\n      };\n    }\n\n    if (!isNaN(this.max) && value > this.max) {\n      return {\n        valid: false,\n        message: `Input must be less than ${this.max}`\n      };\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Minimum value\n   *\n   * The default is Number.NaN, meaning no minimum constraint\n   */\n  min: number = Number.NaN;\n  /**\n   * Maximum value\n   *\n   * The default is Number.NaN, meaning no maximum constraint\n   */\n  max: number = Number.NaN;\n}\n\n/**\n * An abstract base class that provides the most of the functionality\n * needed by a cell editor. All of the built-in cell editors\n * for various cell types are derived from this base class. Custom cell editors\n * can be easily implemented by extending this class.\n */\nexport abstract class CellEditor implements ICellEditor, IDisposable {\n  /**\n   * Construct a new cell editor.\n   */\n  constructor() {\n    this.inputChanged.connect(() => {\n      this.validate();\n    });\n  }\n\n  /**\n   * Whether the cell editor is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._disposed;\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose(): void {\n    if (this._disposed) {\n      return;\n    }\n\n    if (this._gridWheelEventHandler) {\n      this.cell.grid.node.removeEventListener(\n        'wheel',\n        this._gridWheelEventHandler\n      );\n      this._gridWheelEventHandler = null;\n    }\n\n    this._closeValidityNotification();\n\n    this._disposed = true;\n    this.cell.grid.node.removeChild(this.viewportOccluder);\n  }\n\n  /**\n   * Start editing the cell.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param options - The cell editing options.\n   */\n  edit(cell: CellEditor.CellConfig, options?: ICellEditOptions): void {\n    this.cell = cell;\n    this.onCommit = options && options.onCommit;\n    this.onCancel = options && options.onCancel;\n\n    this.validator =\n      options && options.validator\n        ? options.validator\n        : this.createValidatorBasedOnType();\n\n    this._gridWheelEventHandler = () => {\n      this._closeValidityNotification();\n      this.updatePosition();\n    };\n\n    cell.grid.node.addEventListener('wheel', this._gridWheelEventHandler);\n\n    this._addContainer();\n\n    this.updatePosition();\n    this.startEditing();\n  }\n\n  /**\n   * Cancel editing the cell.\n   */\n  cancel() {\n    if (this._disposed) {\n      return;\n    }\n\n    this.dispose();\n    if (this.onCancel) {\n      this.onCancel();\n    }\n  }\n\n  /**\n   * Start editing the cell. Usually an editor widget is created and\n   *  added to `editorContainer`\n   */\n  protected abstract startEditing(): void;\n  /**\n   * Return the current input entered. This method throws exceptions\n   * if input is invalid. Error message in exception is shown as notification.\n   */\n  protected abstract getInput(): any;\n\n  /**\n   * Whether the value input is valid.\n   */\n  protected get validInput(): boolean {\n    return this._validInput;\n  }\n\n  /**\n   * Validate the cell input. Shows validation error notification when input is invalid.\n   */\n  protected validate() {\n    let value;\n    try {\n      value = this.getInput();\n    } catch (error) {\n      console.log(`Input error: ${error.message}`);\n      this.setValidity(false, error.message || DEFAULT_INVALID_INPUT_MESSAGE);\n      return;\n    }\n\n    if (this.validator) {\n      const result = this.validator.validate(this.cell, value);\n      if (result.valid) {\n        this.setValidity(true);\n      } else {\n        this.setValidity(\n          false,\n          result.message || DEFAULT_INVALID_INPUT_MESSAGE\n        );\n      }\n    } else {\n      this.setValidity(true);\n    }\n  }\n\n  /**\n   * Set validity flag.\n   *\n   * @param valid - Whether the input is valid.\n   *\n   * @param message - Notification message to show.\n   *\n   * If message is set to empty string (which is the default)\n   * existing notification popup is removed if any.\n   */\n  protected setValidity(valid: boolean, message: string = '') {\n    this._validInput = valid;\n\n    this._closeValidityNotification();\n\n    if (valid) {\n      this.editorContainer.classList.remove('lm-mod-invalid');\n    } else {\n      this.editorContainer.classList.add('lm-mod-invalid');\n\n      // show a notification popup\n      if (message !== '') {\n        this.validityNotification = new Notification({\n          target: this.editorContainer,\n          message: message,\n          placement: 'bottom',\n          timeout: 5000\n        });\n        this.validityNotification.show();\n      }\n    }\n  }\n\n  /**\n   * Create and return a cell input validator based on configuration of the\n   * cell being edited. If no suitable validator can be found, it returns undefined.\n   */\n  protected createValidatorBasedOnType(): ICellInputValidator | undefined {\n    const cell = this.cell;\n    const metadata = cell.grid.dataModel!.metadata(\n      'body',\n      cell.row,\n      cell.column\n    );\n\n    switch (metadata && metadata.type) {\n      case 'string':\n        {\n          const validator = new TextInputValidator();\n          if (typeof metadata!.format === 'string') {\n            const format = metadata!.format;\n            switch (format) {\n              case 'email':\n                validator.pattern = new RegExp(\n                  '^([a-z0-9_.-]+)@([da-z.-]+).([a-z.]{2,6})$'\n                );\n                break;\n              case 'uuid':\n                validator.pattern = new RegExp(\n                  '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'\n                );\n                break;\n              case 'uri':\n                // TODO\n                break;\n              case 'binary':\n                // TODO\n                break;\n            }\n          }\n\n          if (metadata!.constraint) {\n            if (metadata!.constraint.minLength !== undefined) {\n              validator.minLength = metadata!.constraint.minLength;\n            }\n            if (metadata!.constraint.maxLength !== undefined) {\n              validator.maxLength = metadata!.constraint.maxLength;\n            }\n            if (typeof metadata!.constraint.pattern === 'string') {\n              validator.pattern = new RegExp(metadata!.constraint.pattern);\n            }\n          }\n          return validator;\n        }\n        break;\n      case 'number':\n        {\n          const validator = new NumberInputValidator();\n          if (metadata!.constraint) {\n            if (metadata!.constraint.minimum !== undefined) {\n              validator.min = metadata!.constraint.minimum;\n            }\n            if (metadata!.constraint.maximum !== undefined) {\n              validator.max = metadata!.constraint.maximum;\n            }\n          }\n          return validator;\n        }\n        break;\n      case 'integer':\n        {\n          const validator = new IntegerInputValidator();\n          if (metadata!.constraint) {\n            if (metadata!.constraint.minimum !== undefined) {\n              validator.min = metadata!.constraint.minimum;\n            }\n            if (metadata!.constraint.maximum !== undefined) {\n              validator.max = metadata!.constraint.maximum;\n            }\n          }\n          return validator;\n        }\n        break;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Compute cell rectangle and return with other cell properties.\n   */\n  protected getCellInfo(cell: CellEditor.CellConfig): Private.ICellInfo {\n    const { grid, row, column } = cell;\n    let data, columnX, rowY, width, height;\n    const cellGroup = CellGroup.getGroup(grid.dataModel!, 'body', row, column);\n\n    if (cellGroup) {\n      columnX =\n        grid.headerWidth -\n        grid.scrollX +\n        grid.columnOffset('body', cellGroup.c1);\n      rowY =\n        grid.headerHeight - grid.scrollY + grid.rowOffset('body', cellGroup.r1);\n      width = 0;\n      height = 0;\n\n      for (let r = cellGroup.r1; r <= cellGroup.r2; r++) {\n        height += grid.rowSize('body', r);\n      }\n\n      for (let c = cellGroup.c1; c <= cellGroup.c2; c++) {\n        width += grid.columnSize('body', c);\n      }\n\n      data = grid.dataModel!.data('body', cellGroup.r1, cellGroup.c1);\n    } else {\n      columnX =\n        grid.headerWidth - grid.scrollX + grid.columnOffset('body', column);\n      rowY = grid.headerHeight - grid.scrollY + grid.rowOffset('body', row);\n      width = grid.columnSize('body', column);\n      height = grid.rowSize('body', row);\n      data = grid.dataModel!.data('body', row, column);\n    }\n\n    return {\n      grid: grid,\n      row: row,\n      column: column,\n      data: data,\n      x: columnX,\n      y: rowY,\n      width: width,\n      height: height\n    };\n  }\n\n  /**\n   * Reposition cell editor by moving viewport occluder and cell editor container.\n   */\n  protected updatePosition(): void {\n    const grid = this.cell.grid;\n    const cellInfo = this.getCellInfo(this.cell);\n    const headerHeight = grid.headerHeight;\n    const headerWidth = grid.headerWidth;\n\n    this.viewportOccluder.style.top = headerHeight + 'px';\n    this.viewportOccluder.style.left = headerWidth + 'px';\n    this.viewportOccluder.style.width = grid.viewportWidth - headerWidth + 'px';\n    this.viewportOccluder.style.height =\n      grid.viewportHeight - headerHeight + 'px';\n    this.viewportOccluder.style.position = 'absolute';\n\n    this.editorContainer.style.left = cellInfo.x - 1 - headerWidth + 'px';\n    this.editorContainer.style.top = cellInfo.y - 1 - headerHeight + 'px';\n    this.editorContainer.style.width = cellInfo.width + 1 + 'px';\n    this.editorContainer.style.height = cellInfo.height + 1 + 'px';\n    this.editorContainer.style.visibility = 'visible';\n    this.editorContainer.style.position = 'absolute';\n  }\n\n  /**\n   * Commit the edited value.\n   *\n   * @param cursorMovement - Cursor move direction based on keys pressed to end the edit.\n   *\n   * @returns true on valid input, false otherwise.\n   */\n  protected commit(\n    cursorMovement: SelectionModel.CursorMoveDirection = 'none'\n  ): boolean {\n    this.validate();\n\n    if (!this._validInput) {\n      return false;\n    }\n\n    let value;\n    try {\n      value = this.getInput();\n    } catch (error) {\n      console.log(`Input error: ${error.message}`);\n      return false;\n    }\n\n    this.dispose();\n\n    if (this.onCommit) {\n      this.onCommit({\n        cell: this.cell,\n        value: value,\n        cursorMovement: cursorMovement\n      });\n    }\n\n    return true;\n  }\n\n  /**\n   * Create container elements needed to prevent editor widget overflow\n   * beyond viewport and to position cell editor widget.\n   */\n  private _addContainer() {\n    this.viewportOccluder = document.createElement('div');\n    this.viewportOccluder.className = 'lm-DataGrid-cellEditorOccluder';\n    this.cell.grid.node.appendChild(this.viewportOccluder);\n\n    this.editorContainer = document.createElement('div');\n    this.editorContainer.className = 'lm-DataGrid-cellEditorContainer';\n    this.viewportOccluder.appendChild(this.editorContainer);\n\n    // update mouse event pass-through state based on input validity\n    this.editorContainer.addEventListener('mouseleave', (event: MouseEvent) => {\n      this.viewportOccluder.style.pointerEvents = this._validInput\n        ? 'none'\n        : 'auto';\n    });\n    this.editorContainer.addEventListener('mouseenter', (event: MouseEvent) => {\n      this.viewportOccluder.style.pointerEvents = 'none';\n    });\n  }\n\n  /**\n   * Remove validity notification popup.\n   */\n  private _closeValidityNotification() {\n    if (this.validityNotification) {\n      this.validityNotification.close();\n      this.validityNotification = null;\n    }\n  }\n\n  /**\n   * A signal emitted when input changes.\n   */\n  protected inputChanged = new Signal<this, void>(this);\n  /**\n   * Callback method to call on cell edit commit.\n   */\n  protected onCommit?: (response: ICellEditResponse) => void;\n  /**\n   * Callback method to call on cell edit cancel.\n   */\n  protected onCancel?: () => void;\n  /**\n   * Cell configuration data for the cell being edited.\n   */\n  protected cell: CellEditor.CellConfig;\n  /**\n   * Cell input validator to use for the cell being edited.\n   */\n  protected validator: ICellInputValidator | undefined;\n  /**\n   * The div element used to prevent editor widget overflow beyond grid viewport.\n   */\n  protected viewportOccluder: HTMLDivElement;\n  /**\n   * The div element used to contain and position editor widget.\n   */\n  protected editorContainer: HTMLDivElement;\n  /**\n   * Notification popup used to show validation error messages.\n   */\n  protected validityNotification: Notification | null = null;\n  /**\n   * Whether the cell editor is disposed.\n   */\n  private _disposed = false;\n  /**\n   * Whether the value input is valid.\n   */\n  private _validInput: boolean = true;\n  /**\n   * Grid wheel event handler.\n   */\n  private _gridWheelEventHandler:\n    | ((this: HTMLElement, ev: WheelEvent) => any)\n    | null = null;\n}\n\n/**\n * Abstract base class with shared functionality\n * for cell editors which use HTML Input widget as editor.\n */\nexport abstract class InputCellEditor extends CellEditor {\n  /**\n   * Handle the DOM events for the editor.\n   *\n   * @param event - The DOM event sent to the editor.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._onKeyDown(event as KeyboardEvent);\n        break;\n      case 'blur':\n        this._onBlur(event as FocusEvent);\n        break;\n      case 'input':\n        this._onInput(event);\n        break;\n    }\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n\n    this._unbindEvents();\n\n    super.dispose();\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    this.createWidget();\n\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    this.input.value = this.deserialize(cellInfo.data);\n    this.editorContainer.appendChild(this.input);\n    this.input.focus();\n    this.input.select();\n\n    this.bindEvents();\n  }\n\n  protected deserialize(value: any): any {\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    return value.toString();\n  }\n\n  protected createWidget() {\n    const input = document.createElement('input');\n    input.classList.add('lm-DataGrid-cellEditorWidget');\n    input.classList.add('lm-DataGrid-cellEditorInput');\n    input.spellcheck = false;\n    input.type = this.inputType;\n\n    this.input = input;\n  }\n\n  protected bindEvents() {\n    this.input.addEventListener('keydown', this);\n    this.input.addEventListener('blur', this);\n    this.input.addEventListener('input', this);\n  }\n\n  private _unbindEvents() {\n    this.input.removeEventListener('keydown', this);\n    this.input.removeEventListener('blur', this);\n    this.input.removeEventListener('input', this);\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.input.focus();\n    }\n  }\n\n  private _onInput(event: Event) {\n    this.inputChanged.emit(void 0);\n  }\n\n  protected input: HTMLInputElement;\n  protected abstract inputType: string;\n}\n\n/**\n * Cell editor for text cells.\n */\nexport class TextCellEditor extends InputCellEditor {\n  /**\n   * Return the current text input entered.\n   */\n  protected getInput(): string | null {\n    return this.input.value;\n  }\n\n  protected inputType: string = 'text';\n}\n\n/**\n * Cell editor for real number cells.\n */\nexport class NumberCellEditor extends InputCellEditor {\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    super.startEditing();\n\n    this.input.step = 'any';\n\n    const cell = this.cell;\n\n    const metadata = cell.grid.dataModel!.metadata(\n      'body',\n      cell.row,\n      cell.column\n    );\n    const constraint = metadata.constraint;\n    if (constraint) {\n      if (constraint.minimum) {\n        this.input.min = constraint.minimum;\n      }\n      if (constraint.maximum) {\n        this.input.max = constraint.maximum;\n      }\n    }\n  }\n\n  /**\n   * Return the current number input entered. This method throws exception\n   * if input is invalid.\n   */\n  protected getInput(): number | null {\n    let value = this.input.value;\n    if (value.trim() === '') {\n      return null;\n    }\n\n    const floatValue = parseFloat(value);\n    if (isNaN(floatValue)) {\n      throw new Error('Invalid input');\n    }\n\n    return floatValue;\n  }\n\n  protected inputType: string = 'number';\n}\n\n/**\n * Cell editor for integer cells.\n */\nexport class IntegerCellEditor extends InputCellEditor {\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    super.startEditing();\n\n    this.input.step = '1';\n\n    const cell = this.cell;\n\n    const metadata = cell.grid.dataModel!.metadata(\n      'body',\n      cell.row,\n      cell.column\n    );\n    const constraint = metadata.constraint;\n    if (constraint) {\n      if (constraint.minimum) {\n        this.input.min = constraint.minimum;\n      }\n      if (constraint.maximum) {\n        this.input.max = constraint.maximum;\n      }\n    }\n  }\n\n  /**\n   * Return the current integer input entered. This method throws exception\n   * if input is invalid.\n   */\n  protected getInput(): number | null {\n    let value = this.input.value;\n    if (value.trim() === '') {\n      return null;\n    }\n\n    let intValue = parseInt(value);\n    if (isNaN(intValue)) {\n      throw new Error('Invalid input');\n    }\n\n    return intValue;\n  }\n\n  protected inputType: string = 'number';\n}\n\n/**\n * Cell editor for date cells.\n */\nexport class DateCellEditor extends CellEditor {\n  /**\n   * Handle the DOM events for the editor.\n   *\n   * @param event - The DOM event sent to the editor.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._onKeyDown(event as KeyboardEvent);\n        break;\n      case 'blur':\n        this._onBlur(event as FocusEvent);\n        break;\n    }\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n\n    this._unbindEvents();\n\n    super.dispose();\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    this._createWidget();\n\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    this._input.value = this._deserialize(cellInfo.data);\n    this.editorContainer.appendChild(this._input);\n    this._input.focus();\n\n    this._bindEvents();\n  }\n\n  /**\n   * Return the current date input entered.\n   */\n  protected getInput(): string | null {\n    return this._input.value;\n  }\n\n  private _deserialize(value: any): any {\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    return value.toString();\n  }\n\n  private _createWidget() {\n    const input = document.createElement('input');\n    input.type = 'date';\n    input.pattern = 'd{4}-d{2}-d{2}';\n    input.classList.add('lm-DataGrid-cellEditorWidget');\n    input.classList.add('lm-DataGrid-cellEditorInput');\n\n    this._input = input;\n  }\n\n  private _bindEvents() {\n    this._input.addEventListener('keydown', this);\n    this._input.addEventListener('blur', this);\n  }\n\n  private _unbindEvents() {\n    this._input.removeEventListener('keydown', this);\n    this._input.removeEventListener('blur', this);\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this._input.focus();\n    }\n  }\n\n  private _input: HTMLInputElement;\n}\n\n/**\n * Cell editor for boolean cells.\n */\nexport class BooleanCellEditor extends CellEditor {\n  /**\n   * Handle the DOM events for the editor.\n   *\n   * @param event - The DOM event sent to the editor.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._onKeyDown(event as KeyboardEvent);\n        break;\n      case 'mousedown':\n        // fix focus loss problem in Safari and Firefox\n        this._input.focus();\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'blur':\n        this._onBlur(event as FocusEvent);\n        break;\n    }\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n\n    this._unbindEvents();\n\n    super.dispose();\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    this._createWidget();\n\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    this._input.checked = this._deserialize(cellInfo.data);\n    this.editorContainer.appendChild(this._input);\n    this._input.focus();\n\n    this._bindEvents();\n  }\n\n  /**\n   * Return the current boolean input entered.\n   */\n  protected getInput(): boolean | null {\n    return this._input.checked;\n  }\n\n  private _deserialize(value: any): any {\n    if (value === null || value === undefined) {\n      return false;\n    }\n\n    return value == true;\n  }\n\n  private _createWidget() {\n    const input = document.createElement('input');\n    input.classList.add('lm-DataGrid-cellEditorWidget');\n    input.classList.add('lm-DataGrid-cellEditorCheckbox');\n    input.type = 'checkbox';\n    input.spellcheck = false;\n\n    this._input = input;\n  }\n\n  private _bindEvents() {\n    this._input.addEventListener('keydown', this);\n    this._input.addEventListener('mousedown', this);\n    this._input.addEventListener('blur', this);\n  }\n\n  private _unbindEvents() {\n    this._input.removeEventListener('keydown', this);\n    this._input.removeEventListener('mousedown', this);\n    this._input.removeEventListener('blur', this);\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this._input.focus();\n    }\n  }\n\n  private _input: HTMLInputElement;\n}\n\n/**\n * Cell editor for option cells.\n *\n * It supports multiple option selection. If cell metadata contains\n * type attribute 'array', then it behaves as a multi select.\n * In that case cell data is expected to be list of string values.\n */\nexport class OptionCellEditor extends CellEditor {\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n\n    super.dispose();\n\n    if (this._isMultiSelect) {\n      document.body.removeChild(this._select);\n    }\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    const metadata = cell.grid.dataModel!.metadata(\n      'body',\n      cell.row,\n      cell.column\n    );\n    this._isMultiSelect = metadata.type === 'array';\n    this._createWidget();\n\n    if (this._isMultiSelect) {\n      this._select.multiple = true;\n      const values = this._deserialize(cellInfo.data) as string[];\n      for (let i = 0; i < this._select.options.length; ++i) {\n        const option = this._select.options.item(i);\n        option!.selected = values.indexOf(option!.value) !== -1;\n      }\n      document.body.appendChild(this._select);\n    } else {\n      this._select.value = this._deserialize(cellInfo.data) as string;\n      this.editorContainer.appendChild(this._select);\n    }\n\n    this._select.focus();\n\n    this._bindEvents();\n\n    this.updatePosition();\n  }\n\n  /**\n   * Return the current option input.\n   */\n  protected getInput(): string | string[] | null {\n    if (this._isMultiSelect) {\n      const input: string[] = [];\n      for (let i = 0; i < this._select.selectedOptions.length; ++i) {\n        input.push(this._select.selectedOptions.item(i)!.value);\n      }\n      return input;\n    } else {\n      return this._select.value;\n    }\n  }\n\n  /**\n   * Reposition cell editor.\n   */\n  protected updatePosition(): void {\n    super.updatePosition();\n\n    if (!this._isMultiSelect) {\n      return;\n    }\n\n    const cellInfo = this.getCellInfo(this.cell);\n\n    this._select.style.position = 'absolute';\n    const editorContainerRect = this.editorContainer.getBoundingClientRect();\n\n    this._select.style.left = editorContainerRect.left + 'px';\n    this._select.style.top = editorContainerRect.top + cellInfo.height + 'px';\n    this._select.style.width = editorContainerRect.width + 'px';\n    this._select.style.maxHeight = '60px';\n\n    this.editorContainer.style.visibility = 'hidden';\n  }\n\n  private _deserialize(value: any): string | string[] {\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    if (this._isMultiSelect) {\n      const values: string[] = [];\n      if (Array.isArray(value)) {\n        for (let item of value) {\n          values.push(item.toString());\n        }\n      }\n      return values;\n    } else {\n      return value.toString();\n    }\n  }\n\n  private _createWidget() {\n    const cell = this.cell;\n    const metadata = cell.grid.dataModel!.metadata(\n      'body',\n      cell.row,\n      cell.column\n    );\n    const items = metadata.constraint.enum;\n\n    const select = document.createElement('select');\n    select.classList.add('lm-DataGrid-cellEditorWidget');\n    for (let item of items) {\n      const option = document.createElement('option');\n      option.value = item;\n      option.text = item;\n      select.appendChild(option);\n    }\n\n    this._select = select;\n  }\n\n  private _bindEvents() {\n    this._select.addEventListener('keydown', this._onKeyDown.bind(this));\n    this._select.addEventListener('blur', this._onBlur.bind(this));\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this._select.focus();\n    }\n  }\n\n  private _select: HTMLSelectElement;\n  private _isMultiSelect: boolean = false;\n}\n\n/**\n * Cell editor for option cells whose value can be any value\n * from set of pre-defined options or values that can be input by user.\n */\nexport class DynamicOptionCellEditor extends CellEditor {\n  /**\n   * Handle the DOM events for the editor.\n   *\n   * @param event - The DOM event sent to the editor.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._onKeyDown(event as KeyboardEvent);\n        break;\n      case 'blur':\n        this._onBlur(event as FocusEvent);\n        break;\n    }\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n\n    this._unbindEvents();\n\n    super.dispose();\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    this._createWidget();\n\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    this._input.value = this._deserialize(cellInfo.data);\n    this.editorContainer.appendChild(this._input);\n    this._input.focus();\n    this._input.select();\n\n    this._bindEvents();\n  }\n\n  /**\n   * Return the current option input.\n   */\n  protected getInput(): string | null {\n    return this._input.value;\n  }\n\n  private _deserialize(value: any): any {\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    return value.toString();\n  }\n\n  private _createWidget() {\n    const cell = this.cell;\n    const grid = cell.grid;\n    const dataModel = grid.dataModel!;\n    const rowCount = dataModel.rowCount('body');\n\n    const listId = 'cell-editor-list';\n    const list = document.createElement('datalist');\n    list.id = listId;\n    const input = document.createElement('input');\n    input.classList.add('lm-DataGrid-cellEditorWidget');\n    input.classList.add('lm-DataGrid-cellEditorInput');\n    const valueSet = new Set<string>();\n    for (let r = 0; r < rowCount; ++r) {\n      const data = dataModel.data('body', r, cell.column);\n      if (data) {\n        valueSet.add(data);\n      }\n    }\n    valueSet.forEach((value: string) => {\n      const option = document.createElement('option');\n      option.value = value;\n      option.text = value;\n      list.appendChild(option);\n    });\n    this.editorContainer.appendChild(list);\n    input.setAttribute('list', listId);\n\n    this._input = input;\n  }\n\n  private _bindEvents() {\n    this._input.addEventListener('keydown', this);\n    this._input.addEventListener('blur', this);\n  }\n\n  private _unbindEvents() {\n    this._input.removeEventListener('keydown', this);\n    this._input.removeEventListener('blur', this);\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this._input.focus();\n    }\n  }\n\n  private _input: HTMLInputElement;\n}\n\n/**\n * The namespace for the `CellEditor` class statics.\n */\nexport namespace CellEditor {\n  /**\n   * An object which holds the configuration data for a cell.\n   */\n  export type CellConfig = {\n    /**\n     * The grid containing the cell.\n     */\n    readonly grid: DataGrid;\n    /**\n     * The row index of the cell.\n     */\n    readonly row: number;\n\n    /**\n     * The column index of the cell.\n     */\n    readonly column: number;\n  };\n}\n\n/**\n * A namespace for module-private functionality.\n */\nnamespace Private {\n  /**\n   * A type alias for cell properties.\n   */\n  export type ICellInfo = {\n    grid: DataGrid;\n    row: number;\n    column: number;\n    data: any;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  };\n}\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  BooleanCellEditor,\n  CellDataType,\n  CellEditor,\n  DateCellEditor,\n  DynamicOptionCellEditor,\n  ICellEditOptions,\n  ICellEditor,\n  ICellEditResponse,\n  IntegerCellEditor,\n  NumberCellEditor,\n  OptionCellEditor,\n  TextCellEditor\n} from './celleditor';\n\nimport { CellGroup } from './cellgroup';\n\nimport { DataModel, MutableDataModel } from './datamodel';\n\n/**\n * A type alias for cell editor override identifier.\n */\nexport type EditorOverrideIdentifier =\n  | CellDataType\n  | DataModel.Metadata\n  | 'default';\n\n/**\n * An object which manages cell editing.\n */\nexport interface ICellEditorController {\n  /**\n   * Override cell editor for the cells matching the identifier.\n   *\n   * @param identifier - Cell identifier to use when matching cells.\n   * if identifier is a CellDataType, then cell matching is done using data type of the cell,\n   * if identifier is a Metadata, then partial match of the cell metadata with identifier is used for match,\n   * if identifier is 'default' then override is used as default editor when no other editor is found suitable\n   *\n   * @param editor - The cell editor to use or resolver to use to get an editor for matching cells.\n   */\n  setEditor(\n    identifier: EditorOverrideIdentifier,\n    editor: ICellEditor | Resolver\n  ): void;\n  /**\n   * Start editing a cell.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param options - The cell editing options.\n   */\n  edit(cell: CellEditor.CellConfig, options?: ICellEditOptions): boolean;\n  /**\n   * Cancel editing.\n   */\n  cancel(): void;\n}\n\n/**\n * A type alias for a cell editor config function.\n *\n * This type is used to compute a value from a cell config object.\n */\nexport type ConfigFunc<T> = (config: CellEditor.CellConfig) => T;\n\n/**\n * A type alias for a cell editor config option.\n *\n * A config option can be a static value or a config function.\n */\nexport type ConfigOption<T> = T | ConfigFunc<T>;\n\n/**\n * A type alias for a cell editor resolver function.\n */\nexport type Resolver = ConfigFunc<ICellEditor | undefined>;\n\n/**\n * Resolve a config option for a cell editor.\n *\n * @param option - The config option to resolve.\n *\n * @param config - The cell config object.\n *\n * @returns The resolved value for the option.\n */\nexport function resolveOption<T>(\n  option: ConfigOption<T>,\n  config: CellEditor.CellConfig\n): T {\n  return typeof option === 'function'\n    ? (option as ConfigFunc<T>)(config)\n    : option;\n}\n\n/**\n * An object which manages cell editing. It stores editor overrides,\n * decides which editor to use for a cell, makes sure there is only one editor active.\n */\nexport class CellEditorController implements ICellEditorController {\n  /**\n   * Override cell editor for the cells matching the identifier.\n   *\n   * @param identifier - Cell identifier to use when matching cells.\n   * if identifier is a CellDataType, then cell matching is done using data type of the cell,\n   * if identifier is a Metadata, then partial match of the cell metadata with identifier is used for match,\n   * if identifier is 'default' then override is used as default editor when no other editor is found suitable\n   *\n   * @param editor - The cell editor to use or resolver to use to get an editor for matching cells.\n   */\n  setEditor(\n    identifier: EditorOverrideIdentifier,\n    editor: ICellEditor | Resolver\n  ) {\n    if (typeof identifier === 'string') {\n      this._typeBasedOverrides.set(identifier, editor);\n    } else {\n      const key = this._metadataIdentifierToKey(identifier);\n      this._metadataBasedOverrides.set(key, [identifier, editor]);\n    }\n  }\n\n  /**\n   * Start editing a cell.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param options - The cell editing options.\n   */\n  edit(cell: CellEditor.CellConfig, options?: ICellEditOptions): boolean {\n    const grid = cell.grid;\n\n    if (!grid.editable) {\n      console.error('Grid cannot be edited!');\n      return false;\n    }\n\n    this.cancel();\n\n    this._cell = cell;\n\n    options = options || {};\n    options.onCommit = options.onCommit || this._onCommit.bind(this);\n    options.onCancel = options.onCancel || this._onCancel.bind(this);\n\n    // if an editor is passed in with options, then use it for editing\n    if (options.editor) {\n      this._editor = options.editor;\n      options.editor.edit(cell, options);\n      return true;\n    }\n\n    // choose an editor based on overrides / cell data type\n    const editor = this._getEditor(cell);\n    if (editor) {\n      this._editor = editor;\n      editor.edit(cell, options);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Cancel editing.\n   */\n  cancel(): void {\n    if (this._editor) {\n      this._editor.cancel();\n      this._editor = null;\n    }\n\n    this._cell = null;\n  }\n\n  private _onCommit(response: ICellEditResponse): void {\n    const cell = this._cell;\n\n    if (!cell) {\n      return;\n    }\n\n    const grid = cell.grid;\n    const dataModel = grid.dataModel as MutableDataModel;\n    let row = cell.row;\n    let column = cell.column;\n\n    const cellGroup = CellGroup.getGroup(grid.dataModel!, 'body', row, column);\n    if (cellGroup) {\n      row = cellGroup.r1;\n      column = cellGroup.c1;\n    }\n\n    dataModel.setData('body', row, column, response.value);\n    grid.viewport.node.focus();\n    if (response.cursorMovement !== 'none') {\n      grid.moveCursor(response.cursorMovement);\n      grid.scrollToCursor();\n    }\n  }\n\n  private _onCancel(): void {\n    if (!this._cell) {\n      return;\n    }\n\n    this._cell.grid.viewport.node.focus();\n  }\n\n  private _getDataTypeKey(cell: CellEditor.CellConfig): string {\n    const metadata = cell.grid.dataModel\n      ? cell.grid.dataModel.metadata('body', cell.row, cell.column)\n      : null;\n\n    if (!metadata) {\n      return 'default';\n    }\n\n    let key = '';\n\n    if (metadata) {\n      key = metadata.type;\n    }\n\n    if (metadata.constraint && metadata.constraint.enum) {\n      if (metadata.constraint.enum === 'dynamic') {\n        key += ':dynamic-option';\n      } else {\n        key += ':option';\n      }\n    }\n\n    return key;\n  }\n\n  private _objectToKey(object: any): string {\n    let str = '';\n    for (let key in object) {\n      const value = object[key];\n      if (typeof value === 'object') {\n        str += `${key}:${this._objectToKey(value)}`;\n      } else {\n        str += `[${key}:${value}]`;\n      }\n    }\n\n    return str;\n  }\n\n  private _metadataIdentifierToKey(metadata: DataModel.Metadata): string {\n    return this._objectToKey(metadata);\n  }\n\n  private _metadataMatchesIdentifier(\n    metadata: DataModel.Metadata,\n    identifier: DataModel.Metadata\n  ): boolean {\n    for (let key in identifier) {\n      if (!metadata.hasOwnProperty(key)) {\n        return false;\n      }\n\n      const identifierValue = identifier[key];\n      const metadataValue = metadata[key];\n      if (typeof identifierValue === 'object') {\n        if (!this._metadataMatchesIdentifier(metadataValue, identifierValue)) {\n          return false;\n        }\n      } else if (metadataValue !== identifierValue) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private _getMetadataBasedEditor(\n    cell: CellEditor.CellConfig\n  ): ICellEditor | undefined {\n    let editorMatched: ICellEditor | undefined;\n    const metadata = cell.grid.dataModel!.metadata(\n      'body',\n      cell.row,\n      cell.column\n    );\n    if (metadata) {\n      this._metadataBasedOverrides.forEach(value => {\n        if (!editorMatched) {\n          let [identifier, editor] = value;\n          if (this._metadataMatchesIdentifier(metadata, identifier)) {\n            editorMatched = resolveOption(editor, cell);\n          }\n        }\n      });\n    }\n\n    return editorMatched;\n  }\n\n  /**\n   * Choose the most appropriate cell editor to use based on overrides / cell data type.\n   *\n   * If no match is found in overrides or based on cell data type, and if cell has a primitive\n   * data type then TextCellEditor is used as default cell editor. If 'default' cell editor\n   * is overridden, then it is used instead of TextCellEditor for default.\n   */\n  private _getEditor(cell: CellEditor.CellConfig): ICellEditor | undefined {\n    const dtKey = this._getDataTypeKey(cell);\n\n    // find an editor based on data type based override\n    if (this._typeBasedOverrides.has(dtKey)) {\n      const editor = this._typeBasedOverrides.get(dtKey);\n      return resolveOption(editor!, cell);\n    } // find an editor based on metadata match based override\n    else if (this._metadataBasedOverrides.size > 0) {\n      const editor = this._getMetadataBasedEditor(cell);\n      if (editor) {\n        return editor;\n      }\n    }\n\n    // choose an editor based on data type\n    switch (dtKey) {\n      case 'string':\n        return new TextCellEditor();\n      case 'number':\n        return new NumberCellEditor();\n      case 'integer':\n        return new IntegerCellEditor();\n      case 'boolean':\n        return new BooleanCellEditor();\n      case 'date':\n        return new DateCellEditor();\n      case 'string:option':\n      case 'number:option':\n      case 'integer:option':\n      case 'date:option':\n      case 'array:option':\n        return new OptionCellEditor();\n      case 'string:dynamic-option':\n      case 'number:dynamic-option':\n      case 'integer:dynamic-option':\n      case 'date:dynamic-option':\n        return new DynamicOptionCellEditor();\n    }\n\n    // if an override exists for 'default', then use it\n    if (this._typeBasedOverrides.has('default')) {\n      const editor = this._typeBasedOverrides.get('default');\n      return resolveOption(editor!, cell);\n    }\n\n    // if cell has a primitive data type then use TextCellEditor\n    const data = cell.grid.dataModel!.data('body', cell.row, cell.column);\n    if (!data || typeof data !== 'object') {\n      return new TextCellEditor();\n    }\n\n    // no suitable editor found for the cell\n    return undefined;\n  }\n\n  // active cell editor\n  private _editor: ICellEditor | null = null;\n  // active cell being edited\n  private _cell: CellEditor.CellConfig | null = null;\n  // cell editor overrides based on cell data type identifier\n  private _typeBasedOverrides: Map<string, ICellEditor | Resolver> = new Map();\n  // cell editor overrides based on partial metadata match\n  private _metadataBasedOverrides: Map<\n    string,\n    [DataModel.Metadata, ICellEditor | Resolver]\n  > = new Map();\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport { CellGroup } from './cellgroup';\n/**\n * An object which provides the data for a data grid.\n *\n * #### Notes\n * If the predefined data models are insufficient for a particular use\n * case, a custom model can be defined which derives from this class.\n */\nexport abstract class DataModel {\n  /**\n   * A signal emitted when the data model has changed.\n   */\n  get changed(): ISignal<this, DataModel.ChangedArgs> {\n    return this._changed;\n  }\n\n  /**\n   * Get the row count for a region in the data model.\n   *\n   * @param region - The row region of interest.\n   *\n   * @returns - The row count for the region.\n   *\n   * #### Notes\n   * This method is called often, and so should be efficient.\n   */\n  abstract rowCount(region: DataModel.RowRegion): number;\n\n  /**\n   * Get the column count for a region in the data model.\n   *\n   * @param region - The column region of interest.\n   *\n   * @returns - The column count for the region.\n   *\n   * #### Notes\n   * This method is called often, and so should be efficient.\n   */\n  abstract columnCount(region: DataModel.ColumnRegion): number;\n\n  /**\n   * Get the data value for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns The data value for the specified cell.\n   *\n   * #### Notes\n   * The returned data should be treated as immutable.\n   *\n   * This method is called often, and so should be efficient.\n   */\n  abstract data(region: DataModel.CellRegion, row: number, column: number): any;\n\n  /**\n   * Get the count of merged cell groups pertaining to a given\n   * cell region.\n   * @param region the target cell region.\n   */\n  groupCount(region: DataModel.CellRegion): number {\n    return 0;\n  }\n\n  /**\n   * Get the metadata for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns The metadata for the specified cell.\n   *\n   * #### Notes\n   * The returned metadata should be treated as immutable.\n   *\n   * This method is called often, and so should be efficient.\n   *\n   * The default implementation returns `{}`.\n   */\n  metadata(\n    region: DataModel.CellRegion,\n    row: number,\n    column: number\n  ): DataModel.Metadata {\n    return DataModel.emptyMetadata;\n  }\n\n  /**\n   * Get the merged cell group corresponding to a region and index number.\n   * @param region the cell region of cell group.\n   * @param groupIndex the group index of the cell group.\n   * @returns a cell group.\n   */\n  group(region: DataModel.CellRegion, groupIndex: number): CellGroup | null {\n    return null;\n  }\n\n  /**\n   * Emit the `changed` signal for the data model.\n   *\n   * #### Notes\n   * Subclasses should call this method whenever the data model has\n   * changed so that attached data grids can update themselves.\n   */\n  protected emitChanged(args: DataModel.ChangedArgs): void {\n    this._changed.emit(args);\n  }\n\n  private _changed = new Signal<this, DataModel.ChangedArgs>(this);\n}\n\n/**\n * An object which provides the mutable data for a data grid.\n *\n * #### Notes\n * This object is an extension to `DataModel` and it only adds ability to\n * change data for cells.\n */\nexport abstract class MutableDataModel extends DataModel {\n  /**\n   * Set the data value for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns true if succeeds, false otherwise.\n   *\n   */\n  abstract setData(\n    region: DataModel.CellRegion,\n    row: number,\n    column: number,\n    value: any\n  ): boolean;\n}\n\n/**\n * The namespace for the `DataModel` class statics.\n */\nexport namespace DataModel {\n  /**\n   * A type alias for the data model row regions.\n   */\n  export type RowRegion = 'body' | 'column-header';\n\n  /**\n   * A type alias for the data model column regions.\n   */\n  export type ColumnRegion = 'body' | 'row-header';\n\n  /**\n   * A type alias for the data model cell regions.\n   */\n  export type CellRegion =\n    | 'body'\n    | 'row-header'\n    | 'column-header'\n    | 'corner-header';\n\n  /**\n   * The metadata for a column in a data model.\n   */\n  export type Metadata = { [key: string]: any };\n\n  /**\n   * A singleton empty metadata object.\n   */\n  export const emptyMetadata: Metadata = Object.freeze({});\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when rows are inserted or removed.\n   */\n  export type RowsChangedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'rows-inserted' | 'rows-removed';\n\n    /**\n     * The region which contains the modified rows.\n     */\n    readonly region: RowRegion;\n\n    /**\n     * The index of the first modified row.\n     */\n    readonly index: number;\n\n    /**\n     * The number of modified rows.\n     */\n    readonly span: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when columns are inserted or removed.\n   */\n  export type ColumnsChangedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'columns-inserted' | 'columns-removed';\n\n    /**\n     * The region which contains the modified columns.\n     */\n    readonly region: ColumnRegion;\n\n    /**\n     * The index of the first modified column.\n     */\n    readonly index: number;\n\n    /**\n     * The number of modified columns.\n     */\n    readonly span: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when rows are moved.\n   */\n  export type RowsMovedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'rows-moved';\n\n    /**\n     * The region which contains the modified rows.\n     */\n    readonly region: RowRegion;\n\n    /**\n     * The starting index of the first modified row.\n     */\n    readonly index: number;\n\n    /**\n     * The number of modified rows.\n     */\n    readonly span: number;\n\n    /**\n     * The ending index of the first modified row.\n     */\n    readonly destination: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when columns are moved.\n   */\n  export type ColumnsMovedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'columns-moved';\n\n    /**\n     * The region which contains the modified columns.\n     */\n    readonly region: ColumnRegion;\n\n    /**\n     * The starting index of the first modified column.\n     */\n    readonly index: number;\n\n    /**\n     * The number of modified columns.\n     */\n    readonly span: number;\n\n    /**\n     * The ending index of the first modified column.\n     */\n    readonly destination: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when cells are changed in-place.\n   */\n  export type CellsChangedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'cells-changed';\n\n    /**\n     * The region which contains the modified cells.\n     */\n    readonly region: CellRegion;\n\n    /**\n     * The row index of the first modified cell.\n     */\n    readonly row: number;\n\n    /**\n     * The column index of the first modified cell.\n     */\n    readonly column: number;\n\n    /**\n     * The number of rows in the modified cell range.\n     */\n    readonly rowSpan: number;\n\n    /**\n     * The number of columns in the modified cell range.\n     */\n    readonly columnSpan: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when the model has changed in a fashion that cannot be easily\n   * expressed by the other args object types.\n   *\n   * This is the \"big hammer\" approach, and will cause any associated\n   * data grid to perform a full reset. The other changed args types\n   * should be used whenever possible.\n   */\n  export type ModelResetArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'model-reset';\n  };\n\n  /**\n   * A type alias for the args objects of the `changed` signal.\n   */\n  export type ChangedArgs =\n    | RowsChangedArgs\n    | ColumnsChangedArgs\n    | RowsMovedArgs\n    | ColumnsMovedArgs\n    | CellsChangedArgs\n    | ModelResetArgs;\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { IDisposable } from '@lumino/disposable';\n\n/**\n * A thin caching wrapper around a 2D canvas rendering context.\n *\n * #### Notes\n * This class is mostly a transparent wrapper around a canvas rendering\n * context which improves performance when writing context state.\n *\n * For best performance, avoid reading state from the `gc`. Writes are\n * cached based on the previously written value.\n *\n * Unless otherwise specified, the API and semantics of this class are\n * identical to the builtin 2D canvas rendering context:\n * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D\n *\n * The wrapped canvas context should not be manipulated externally\n * until the wrapping `GraphicsContext` object is disposed.\n */\nexport class GraphicsContext implements IDisposable {\n  /**\n   * Create a new graphics context object.\n   *\n   * @param context - The 2D canvas rendering context to wrap.\n   */\n  constructor(context: CanvasRenderingContext2D) {\n    this._context = context;\n    this._state = Private.State.create(context);\n  }\n\n  dispose(): void {\n    // Bail if the gc is already disposed.\n    if (this._disposed) {\n      return;\n    }\n\n    // Mark the gc as disposed.\n    this._disposed = true;\n\n    // Pop any unrestored saves.\n    while (this._state.next) {\n      this._state = this._state.next;\n      this._context.restore();\n    }\n  }\n\n  get isDisposed(): boolean {\n    return this._disposed;\n  }\n\n  get fillStyle(): string | CanvasGradient | CanvasPattern {\n    return this._context.fillStyle;\n  }\n\n  set fillStyle(value: string | CanvasGradient | CanvasPattern) {\n    if (this._state.fillStyle !== value) {\n      this._state.fillStyle = value;\n      this._context.fillStyle = value;\n    }\n  }\n\n  get strokeStyle(): string | CanvasGradient | CanvasPattern {\n    return this._context.strokeStyle;\n  }\n\n  set strokeStyle(value: string | CanvasGradient | CanvasPattern) {\n    if (this._state.strokeStyle !== value) {\n      this._state.strokeStyle = value;\n      this._context.strokeStyle = value;\n    }\n  }\n\n  get font(): string {\n    return this._context.font;\n  }\n\n  set font(value: string) {\n    if (this._state.font !== value) {\n      this._state.font = value;\n      this._context.font = value;\n    }\n  }\n\n  get textAlign(): CanvasTextAlign {\n    return this._context.textAlign;\n  }\n\n  set textAlign(value: CanvasTextAlign) {\n    if (this._state.textAlign !== value) {\n      this._state.textAlign = value;\n      this._context.textAlign = value;\n    }\n  }\n\n  get textBaseline(): CanvasTextBaseline {\n    return this._context.textBaseline;\n  }\n\n  set textBaseline(value: CanvasTextBaseline) {\n    if (this._state.textBaseline !== value) {\n      this._state.textBaseline = value;\n      this._context.textBaseline = value;\n    }\n  }\n\n  get lineCap(): CanvasLineCap {\n    return this._context.lineCap;\n  }\n\n  set lineCap(value: CanvasLineCap) {\n    if (this._state.lineCap !== value) {\n      this._state.lineCap = value;\n      this._context.lineCap = value;\n    }\n  }\n\n  get lineDashOffset(): number {\n    return this._context.lineDashOffset;\n  }\n\n  set lineDashOffset(value: number) {\n    if (this._state.lineDashOffset !== value) {\n      this._state.lineDashOffset = value;\n      this._context.lineDashOffset = value;\n    }\n  }\n\n  get lineJoin(): CanvasLineJoin {\n    return this._context.lineJoin;\n  }\n\n  set lineJoin(value: CanvasLineJoin) {\n    if (this._state.lineJoin !== value) {\n      this._state.lineJoin = value;\n      this._context.lineJoin = value;\n    }\n  }\n\n  get lineWidth(): number {\n    return this._context.lineWidth;\n  }\n\n  set lineWidth(value: number) {\n    if (this._state.lineWidth !== value) {\n      this._state.lineWidth = value;\n      this._context.lineWidth = value;\n    }\n  }\n\n  get miterLimit(): number {\n    return this._context.miterLimit;\n  }\n\n  set miterLimit(value: number) {\n    if (this._state.miterLimit !== value) {\n      this._state.miterLimit = value;\n      this._context.miterLimit = value;\n    }\n  }\n\n  get shadowBlur(): number {\n    return this._context.shadowBlur;\n  }\n\n  set shadowBlur(value: number) {\n    if (this._state.shadowBlur !== value) {\n      this._state.shadowBlur = value;\n      this._context.shadowBlur = value;\n    }\n  }\n\n  get shadowColor(): string {\n    return this._context.shadowColor;\n  }\n\n  set shadowColor(value: string) {\n    if (this._state.shadowColor !== value) {\n      this._state.shadowColor = value;\n      this._context.shadowColor = value;\n    }\n  }\n\n  get shadowOffsetX(): number {\n    return this._context.shadowOffsetX;\n  }\n\n  set shadowOffsetX(value: number) {\n    if (this._state.shadowOffsetX !== value) {\n      this._state.shadowOffsetX = value;\n      this._context.shadowOffsetX = value;\n    }\n  }\n\n  get shadowOffsetY(): number {\n    return this._context.shadowOffsetY;\n  }\n\n  set shadowOffsetY(value: number) {\n    if (this._state.shadowOffsetY !== value) {\n      this._state.shadowOffsetY = value;\n      this._context.shadowOffsetY = value;\n    }\n  }\n\n  get imageSmoothingEnabled(): boolean {\n    return this._context.imageSmoothingEnabled;\n  }\n\n  set imageSmoothingEnabled(value: boolean) {\n    if (this._state.imageSmoothingEnabled !== value) {\n      this._state.imageSmoothingEnabled = value;\n      this._context.imageSmoothingEnabled = value;\n    }\n  }\n\n  get globalAlpha(): number {\n    return this._context.globalAlpha;\n  }\n\n  set globalAlpha(value: number) {\n    if (this._state.globalAlpha !== value) {\n      this._state.globalAlpha = value;\n      this._context.globalAlpha = value;\n    }\n  }\n\n  get globalCompositeOperation(): string {\n    return this._context.globalCompositeOperation;\n  }\n\n  set globalCompositeOperation(value: string) {\n    if (this._state.globalCompositeOperation !== value) {\n      this._state.globalCompositeOperation = value;\n      this._context.globalCompositeOperation = value;\n    }\n  }\n\n  getLineDash(): number[] {\n    return this._context.getLineDash();\n  }\n\n  setLineDash(segments: number[]): void {\n    this._context.setLineDash(segments);\n  }\n\n  rotate(angle: number): void {\n    this._context.rotate(angle);\n  }\n\n  scale(x: number, y: number): void {\n    this._context.scale(x, y);\n  }\n\n  transform(\n    m11: number,\n    m12: number,\n    m21: number,\n    m22: number,\n    dx: number,\n    dy: number\n  ): void {\n    this._context.transform(m11, m12, m21, m22, dx, dy);\n  }\n\n  translate(x: number, y: number): void {\n    this._context.translate(x, y);\n  }\n\n  setTransform(\n    m11: number,\n    m12: number,\n    m21: number,\n    m22: number,\n    dx: number,\n    dy: number\n  ): void {\n    this._context.setTransform(m11, m12, m21, m22, dx, dy);\n  }\n\n  save(): void {\n    // Clone an push the current state to the stack.\n    this._state = Private.State.push(this._state);\n\n    // Save the wrapped context state.\n    this._context.save();\n  }\n\n  restore(): void {\n    // Bail if there is no state to restore.\n    if (!this._state.next) {\n      return;\n    }\n\n    // Pop the saved state from the stack.\n    this._state = Private.State.pop(this._state);\n\n    // Restore the wrapped context state.\n    this._context.restore();\n  }\n\n  beginPath(): void {\n    return this._context.beginPath();\n  }\n\n  closePath(): void {\n    this._context.closePath();\n  }\n\n  isPointInPath(x: number, y: number, fillRule?: CanvasFillRule): boolean {\n    let result: boolean;\n    if (arguments.length === 2) {\n      result = this._context.isPointInPath(x, y);\n    } else {\n      result = this._context.isPointInPath(x, y, fillRule);\n    }\n    return result;\n  }\n\n  arc(\n    x: number,\n    y: number,\n    radius: number,\n    startAngle: number,\n    endAngle: number,\n    anticlockwise?: boolean\n  ): void {\n    if (arguments.length === 5) {\n      this._context.arc(x, y, radius, startAngle, endAngle);\n    } else {\n      this._context.arc(x, y, radius, startAngle, endAngle, anticlockwise);\n    }\n  }\n\n  arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void {\n    this._context.arcTo(x1, y1, x2, y2, radius);\n  }\n\n  bezierCurveTo(\n    cp1x: number,\n    cp1y: number,\n    cp2x: number,\n    cp2y: number,\n    x: number,\n    y: number\n  ): void {\n    this._context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n  }\n\n  ellipse(\n    x: number,\n    y: number,\n    radiusX: number,\n    radiusY: number,\n    rotation: number,\n    startAngle: number,\n    endAngle: number,\n    anticlockwise?: boolean\n  ): void {\n    if (arguments.length === 7) {\n      this._context.ellipse(\n        x,\n        y,\n        radiusX,\n        radiusY,\n        rotation,\n        startAngle,\n        endAngle\n      );\n    } else {\n      this._context.ellipse(\n        x,\n        y,\n        radiusX,\n        radiusY,\n        rotation,\n        startAngle,\n        endAngle,\n        anticlockwise\n      );\n    }\n  }\n\n  lineTo(x: number, y: number): void {\n    this._context.lineTo(x, y);\n  }\n\n  moveTo(x: number, y: number): void {\n    this._context.moveTo(x, y);\n  }\n\n  quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void {\n    this._context.quadraticCurveTo(cpx, cpy, x, y);\n  }\n\n  rect(x: number, y: number, w: number, h: number): void {\n    this._context.rect(x, y, w, h);\n  }\n\n  clip(fillRule?: CanvasFillRule): void {\n    if (arguments.length === 0) {\n      this._context.clip();\n    } else {\n      this._context.clip(fillRule);\n    }\n  }\n\n  fill(fillRule?: CanvasFillRule): void {\n    if (arguments.length === 0) {\n      this._context.fill();\n    } else {\n      this._context.fill(fillRule);\n    }\n  }\n\n  stroke(): void {\n    this._context.stroke();\n  }\n\n  clearRect(x: number, y: number, w: number, h: number): void {\n    return this._context.clearRect(x, y, w, h);\n  }\n\n  fillRect(x: number, y: number, w: number, h: number): void {\n    this._context.fillRect(x, y, w, h);\n  }\n\n  fillText(text: string, x: number, y: number, maxWidth?: number): void {\n    if (arguments.length === 3) {\n      this._context.fillText(text, x, y);\n    } else {\n      this._context.fillText(text, x, y, maxWidth);\n    }\n  }\n\n  strokeRect(x: number, y: number, w: number, h: number): void {\n    this._context.strokeRect(x, y, w, h);\n  }\n\n  strokeText(text: string, x: number, y: number, maxWidth?: number): void {\n    if (arguments.length === 3) {\n      this._context.strokeText(text, x, y);\n    } else {\n      this._context.strokeText(text, x, y, maxWidth);\n    }\n  }\n\n  measureText(text: string): TextMetrics {\n    return this._context.measureText(text);\n  }\n\n  createLinearGradient(\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number\n  ): CanvasGradient {\n    return this._context.createLinearGradient(x0, y0, x1, y1);\n  }\n\n  createRadialGradient(\n    x0: number,\n    y0: number,\n    r0: number,\n    x1: number,\n    y1: number,\n    r1: number\n  ): CanvasGradient {\n    return this._context.createRadialGradient(x0, y0, r0, x1, y1, r1);\n  }\n\n  createPattern(\n    image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement,\n    repetition: string\n  ): CanvasPattern | null {\n    return this._context.createPattern(image, repetition);\n  }\n\n  createImageData(imageData: ImageData): ImageData;\n  createImageData(sw: number, sh: number): ImageData;\n  createImageData() {\n    // eslint-disable-next-line prefer-spread, prefer-rest-params\n    return this._context.createImageData.apply(this._context, arguments);\n  }\n\n  getImageData(sx: number, sy: number, sw: number, sh: number): ImageData {\n    return this._context.getImageData(sx, sy, sw, sh);\n  }\n\n  putImageData(imagedata: ImageData, dx: number, dy: number): void;\n  putImageData(\n    imagedata: ImageData,\n    dx: number,\n    dy: number,\n    dirtyX: number,\n    dirtyY: number,\n    dirtyWidth: number,\n    dirtyHeight: number\n  ): void;\n  putImageData(): void {\n    // eslint-disable-next-line prefer-spread, prefer-rest-params\n    this._context.putImageData.apply(this._context, arguments);\n  }\n\n  drawImage(\n    image:\n      | HTMLImageElement\n      | HTMLCanvasElement\n      | HTMLVideoElement\n      | ImageBitmap,\n    dstX: number,\n    dstY: number\n  ): void;\n  drawImage(\n    image:\n      | HTMLImageElement\n      | HTMLCanvasElement\n      | HTMLVideoElement\n      | ImageBitmap,\n    dstX: number,\n    dstY: number,\n    dstW: number,\n    dstH: number\n  ): void;\n  drawImage(\n    image:\n      | HTMLImageElement\n      | HTMLCanvasElement\n      | HTMLVideoElement\n      | ImageBitmap,\n    srcX: number,\n    srcY: number,\n    srcW: number,\n    srcH: number,\n    dstX: number,\n    dstY: number,\n    dstW: number,\n    dstH: number\n  ): void;\n  drawImage(): void {\n    // eslint-disable-next-line prefer-spread, prefer-rest-params\n    this._context.drawImage.apply(this._context, arguments);\n  }\n\n  drawFocusIfNeeded(element: Element): void {\n    this._context.drawFocusIfNeeded(element);\n  }\n\n  private _disposed = false;\n  private _state: Private.State;\n  private _context: CanvasRenderingContext2D;\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * The index of next valid pool object.\n   */\n  let pi = -1;\n\n  /**\n   * A state object allocation pool.\n   */\n  const pool: State[] = [];\n\n  /**\n   * An object which holds the state for a gc.\n   */\n  export class State {\n    /**\n     * Create a gc state object from a 2D canvas context.\n     */\n    static create(context: CanvasRenderingContext2D): State {\n      let state = pi < 0 ? new State() : pool[pi--];\n      state.next = null;\n      state.fillStyle = context.fillStyle;\n      state.font = context.font;\n      state.globalAlpha = context.globalAlpha;\n      state.globalCompositeOperation = context.globalCompositeOperation;\n      state.imageSmoothingEnabled = context.imageSmoothingEnabled;\n      state.lineCap = context.lineCap;\n      state.lineDashOffset = context.lineDashOffset;\n      state.lineJoin = context.lineJoin;\n      state.lineWidth = context.lineWidth;\n      state.miterLimit = context.miterLimit;\n      state.shadowBlur = context.shadowBlur;\n      state.shadowColor = context.shadowColor;\n      state.shadowOffsetX = context.shadowOffsetX;\n      state.shadowOffsetY = context.shadowOffsetY;\n      state.strokeStyle = context.strokeStyle;\n      state.textAlign = context.textAlign;\n      state.textBaseline = context.textBaseline;\n      return state;\n    }\n\n    /**\n     * Clone an existing gc state object and add it to the state stack.\n     */\n    static push(other: State): State {\n      let state = pi < 0 ? new State() : pool[pi--];\n      state.next = other;\n      state.fillStyle = other.fillStyle;\n      state.font = other.font;\n      state.globalAlpha = other.globalAlpha;\n      state.globalCompositeOperation = other.globalCompositeOperation;\n      state.imageSmoothingEnabled = other.imageSmoothingEnabled;\n      state.lineCap = other.lineCap;\n      state.lineDashOffset = other.lineDashOffset;\n      state.lineJoin = other.lineJoin;\n      state.lineWidth = other.lineWidth;\n      state.miterLimit = other.miterLimit;\n      state.shadowBlur = other.shadowBlur;\n      state.shadowColor = other.shadowColor;\n      state.shadowOffsetX = other.shadowOffsetX;\n      state.shadowOffsetY = other.shadowOffsetY;\n      state.strokeStyle = other.strokeStyle;\n      state.textAlign = other.textAlign;\n      state.textBaseline = other.textBaseline;\n      return state;\n    }\n\n    /**\n     * Pop the next state object and return the current to the pool\n     */\n    static pop(state: State): State {\n      state.fillStyle = '';\n      state.strokeStyle = '';\n      pool[++pi] = state;\n      return state.next!;\n    }\n\n    next: State | null;\n\n    fillStyle: string | CanvasGradient | CanvasPattern;\n    font: string;\n    globalAlpha: number;\n    globalCompositeOperation: string;\n    imageSmoothingEnabled: boolean;\n    lineCap: string;\n    lineDashOffset: number;\n    lineJoin: string;\n    lineWidth: number;\n    miterLimit: number;\n    shadowBlur: number;\n    shadowColor: string;\n    shadowOffsetX: number;\n    shadowOffsetY: number;\n    strokeStyle: string | CanvasGradient | CanvasPattern;\n    textAlign: string;\n    textBaseline: string;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ArrayExt } from '@lumino/algorithm';\n\n/**\n * An object which manages a collection of variable sized sections.\n *\n * #### Notes\n * This class is an implementation detail. It is designed to manage\n * the variable row and column sizes for a data grid. User code will\n * not interact with this class directly.\n */\nexport class SectionList {\n  /**\n   * Construct a new section list.\n   *\n   * @param options - The options for initializing the list.\n   */\n  constructor(options: SectionList.IOptions) {\n    this._minimumSize = options.minimumSize || 2;\n    this._defaultSize = Math.max(\n      this._minimumSize,\n      Math.floor(options.defaultSize)\n    );\n  }\n\n  /**\n   * The total size of all sections in the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get length(): number {\n    return this._length;\n  }\n\n  /**\n   * The total number of sections in the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get count(): number {\n    return this._count;\n  }\n\n  /**\n   * Get the minimum size of sections in the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get minimumSize(): number {\n    return this._minimumSize;\n  }\n\n  /**\n   * Set the minimum size of sections in the list.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  set minimumSize(value: number) {\n    // Normalize the value.\n    value = Math.max(2, Math.floor(value));\n\n    // Bail early if the value does not change.\n    if (this._minimumSize === value) {\n      return;\n    }\n\n    // Update the internal minimum size.\n    this._minimumSize = value;\n\n    // Update default size if larger than minimum size\n    if (value > this._defaultSize) {\n      this.defaultSize = value;\n    }\n  }\n\n  /**\n   * Get the default size of sections in the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get defaultSize(): number {\n    return this._defaultSize;\n  }\n\n  /**\n   * Set the default size of sections in the list.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  set defaultSize(value: number) {\n    // Normalize the value.\n    value = Math.max(this._minimumSize, Math.floor(value));\n\n    // Bail early if the value does not change.\n    if (this._defaultSize === value) {\n      return;\n    }\n\n    // Compute the delta default size.\n    let delta = value - this._defaultSize;\n\n    // Update the internal default size.\n    this._defaultSize = value;\n\n    // Update the length.\n    this._length += delta * (this._count - this._sections.length);\n\n    // Bail early if there are no modified sections.\n    if (this._sections.length === 0) {\n      return;\n    }\n\n    // Recompute the offsets of the modified sections.\n    for (let i = 0, n = this._sections.length; i < n; ++i) {\n      // Look up the previous and current modified sections.\n      let prev = this._sections[i - 1];\n      let curr = this._sections[i];\n\n      // Adjust the offset for the current section.\n      if (prev) {\n        let count = curr.index - prev.index - 1;\n        curr.offset = prev.offset + prev.size + count * value;\n      } else {\n        curr.offset = curr.index * value;\n      }\n    }\n  }\n\n  /**\n   * Clamp a size to the minimum section size\n   *\n   * @param size - The size to clamp.\n   *\n   * @returns The size or the section minimum size, whichever is larger\n   */\n  clampSize(size: number): number {\n    return Math.max(this._minimumSize, Math.floor(size));\n  }\n\n  /**\n   * Find the index of the section which covers the given offset.\n   *\n   * @param offset - The offset of the section of interest.\n   *\n   * @returns The index of the section which covers the given offset,\n   *   or `-1` if the offset is out of range.\n   *\n   * #### Complexity\n   * Logarithmic on the number of resized sections.\n   */\n  indexOf(offset: number): number {\n    // Bail early if the offset is out of range.\n    if (offset < 0 || offset >= this._length || this._count === 0) {\n      return -1;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return Math.floor(offset / this._defaultSize);\n    }\n\n    // Find the modified section for the given offset.\n    let i = ArrayExt.lowerBound(this._sections, offset, Private.offsetCmp);\n\n    // Return the index of an exact match.\n    if (i < this._sections.length && this._sections[i].offset <= offset) {\n      return this._sections[i].index;\n    }\n\n    // Handle the case of no modified sections before the offset.\n    if (i === 0) {\n      return Math.floor(offset / this._defaultSize);\n    }\n\n    // Compute the index from the previous modified section.\n    let section = this._sections[i - 1];\n    let span = offset - (section.offset + section.size);\n    return section.index + Math.floor(span / this._defaultSize) + 1;\n  }\n\n  /**\n   * Find the offset of the section at the given index.\n   *\n   * @param index - The index of the section of interest.\n   *\n   * @returns The offset of the section at the given index, or `-1`\n   *   if the index is out of range.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   *\n   * #### Complexity\n   * Logarithmic on the number of resized sections.\n   */\n  offsetOf(index: number): number {\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= this._count) {\n      return -1;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return index * this._defaultSize;\n    }\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Return the offset of an exact match.\n    if (i < this._sections.length && this._sections[i].index === index) {\n      return this._sections[i].offset;\n    }\n\n    // Handle the case of no modified sections before the index.\n    if (i === 0) {\n      return index * this._defaultSize;\n    }\n\n    // Compute the offset from the previous modified section.\n    let section = this._sections[i - 1];\n    let span = index - section.index - 1;\n    return section.offset + section.size + span * this._defaultSize;\n  }\n\n  /**\n   * Find the extent of the section at the given index.\n   *\n   * @param index - The index of the section of interest.\n   *\n   * @returns The extent of the section at the given index, or `-1`\n   *   if the index is out of range.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   *\n   * #### Complexity\n   * Logarithmic on the number of resized sections.\n   */\n  extentOf(index: number): number {\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= this._count) {\n      return -1;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return (index + 1) * this._defaultSize - 1;\n    }\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Return the offset of an exact match.\n    if (i < this._sections.length && this._sections[i].index === index) {\n      return this._sections[i].offset + this._sections[i].size - 1;\n    }\n\n    // Handle the case of no modified sections before the index.\n    if (i === 0) {\n      return (index + 1) * this._defaultSize - 1;\n    }\n\n    // Compute the offset from the previous modified section.\n    let section = this._sections[i - 1];\n    let span = index - section.index;\n    return section.offset + section.size + span * this._defaultSize - 1;\n  }\n\n  /**\n   * Find the size of the section at the given index.\n   *\n   * @param index - The index of the section of interest.\n   *\n   * @returns The size of the section at the given index, or `-1`\n   *   if the index is out of range.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   *\n   * #### Complexity\n   * Logarithmic on the number of resized sections.\n   */\n  sizeOf(index: number): number {\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= this._count) {\n      return -1;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return this._defaultSize;\n    }\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Return the size of an exact match.\n    if (i < this._sections.length && this._sections[i].index === index) {\n      return this._sections[i].size;\n    }\n\n    // Return the default size for all other cases.\n    return this._defaultSize;\n  }\n\n  /**\n   * Resize a section in the list.\n   *\n   * @param index - The index of the section to resize. This method\n   *   is a no-op if this value is out of range.\n   *\n   * @param size - The new size of the section. This value will be\n   *   clamped to an integer `>= 0`.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  resize(index: number, size: number): void {\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= this._count) {\n      return;\n    }\n\n    // Clamp the size to an integer >= minimum size.\n    size = Math.max(this._minimumSize, Math.floor(size));\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Update or create the modified section as needed.\n    let delta: number;\n    if (i < this._sections.length && this._sections[i].index === index) {\n      let section = this._sections[i];\n      delta = size - section.size;\n      section.size = size;\n    } else if (i === 0) {\n      let offset = index * this._defaultSize;\n      ArrayExt.insert(this._sections, i, { index, offset, size });\n      delta = size - this._defaultSize;\n    } else {\n      let section = this._sections[i - 1];\n      let span = index - section.index - 1;\n      let offset = section.offset + section.size + span * this._defaultSize;\n      ArrayExt.insert(this._sections, i, { index, offset, size });\n      delta = size - this._defaultSize;\n    }\n\n    // Adjust the length.\n    this._length += delta;\n\n    // Update all modified sections after the resized section.\n    for (let j = i + 1, n = this._sections.length; j < n; ++j) {\n      this._sections[j].offset += delta;\n    }\n  }\n\n  /**\n   * Insert sections into the list.\n   *\n   * @param index - The index at which to insert the sections. This\n   *   value will be clamped to the bounds of the list.\n   *\n   * @param count - The number of sections to insert. This method\n   *   is a no-op if this value is `<= 0`.\n   *\n   * #### Undefined Behavior\n   * An `index` or `count` which is non-integral.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  insert(index: number, count: number): void {\n    // Bail early if there are no sections to insert.\n    if (count <= 0) {\n      return;\n    }\n\n    // Clamp the index to the bounds of the list.\n    index = Math.max(0, Math.min(index, this._count));\n\n    // Add the new sections to the totals.\n    let span = count * this._defaultSize;\n    this._count += count;\n    this._length += span;\n\n    // Bail early if there are no modified sections to update.\n    if (this._sections.length === 0) {\n      return;\n    }\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Update all modified sections after the insert location.\n    for (let n = this._sections.length; i < n; ++i) {\n      let section = this._sections[i];\n      section.index += count;\n      section.offset += span;\n    }\n  }\n\n  /**\n   * Remove sections from the list.\n   *\n   * @param index - The index of the first section to remove. This\n   *   method is a no-op if this value is out of range.\n   *\n   * @param count - The number of sections to remove. This method\n   *   is a no-op if this value is `<= 0`.\n   *\n   * #### Undefined Behavior\n   * An `index` or `count` which is non-integral.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  remove(index: number, count: number): void {\n    // Bail early if there is nothing to remove.\n    if (index < 0 || index >= this._count || count <= 0) {\n      return;\n    }\n\n    // Clamp the count to the bounds of the list.\n    count = Math.min(this._count - index, count);\n\n    // Handle the simple case of no modified sections to update.\n    if (this._sections.length === 0) {\n      this._count -= count;\n      this._length -= count * this._defaultSize;\n      return;\n    }\n\n    // Handle the simple case of removing all sections.\n    if (count === this._count) {\n      this._length = 0;\n      this._count = 0;\n      this._sections.length = 0;\n      return;\n    }\n\n    // Find the modified section for the start index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Find the modified section for the end index.\n    let j = ArrayExt.lowerBound(\n      this._sections,\n      index + count,\n      Private.indexCmp\n    );\n\n    // Remove the relevant modified sections.\n    let removed = this._sections.splice(i, j - i);\n\n    // Compute the total removed span.\n    let span = (count - removed.length) * this._defaultSize;\n    for (let k = 0, n = removed.length; k < n; ++k) {\n      span += removed[k].size;\n    }\n\n    // Adjust the totals.\n    this._count -= count;\n    this._length -= span;\n\n    // Update all modified sections after the removed span.\n    for (let k = i, n = this._sections.length; k < n; ++k) {\n      let section = this._sections[k];\n      section.index -= count;\n      section.offset -= span;\n    }\n  }\n\n  /**\n   * Move sections within the list.\n   *\n   * @param index - The index of the first section to move. This method\n   *   is a no-op if this value is out of range.\n   *\n   * @param count - The number of sections to move. This method is a\n   *   no-op if this value is `<= 0`.\n   *\n   * @param destination - The destination index for the first section.\n   *   This value will be clamped to the allowable range.\n   *\n   * #### Undefined Behavior\n   * An `index`, `count`, or `destination` which is non-integral.\n   *\n   * #### Complexity\n   * Linear on the number of moved resized sections.\n   */\n  move(index: number, count: number, destination: number): void {\n    // Bail early if there is nothing to move.\n    if (index < 0 || index >= this._count || count <= 0) {\n      return;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return;\n    }\n\n    // Clamp the move count to the limit.\n    count = Math.min(count, this._count - index);\n\n    // Clamp the destination index to the limit.\n    destination = Math.min(Math.max(0, destination), this._count - count);\n\n    // Bail early if there is no effective move.\n    if (index === destination) {\n      return;\n    }\n\n    // Compute the first affected index.\n    let i1 = Math.min(index, destination);\n\n    // Look up the first affected modified section.\n    let k1 = ArrayExt.lowerBound(this._sections, i1, Private.indexCmp);\n\n    // Bail early if there are no affected modified sections.\n    if (k1 === this._sections.length) {\n      return;\n    }\n\n    // Compute the last affected index.\n    let i2 = Math.max(index + count - 1, destination + count - 1);\n\n    // Look up the last affected modified section.\n    let k2 = ArrayExt.upperBound(this._sections, i2, Private.indexCmp) - 1;\n\n    // Bail early if there are no affected modified sections.\n    if (k2 < k1) {\n      return;\n    }\n\n    // Compute the pivot index.\n    let pivot = destination < index ? index : index + count;\n\n    // Compute the count for each side of the pivot.\n    let count1 = pivot - i1;\n    let count2 = i2 - pivot + 1;\n\n    // Compute the span for each side of the pivot.\n    let span1 = count1 * this._defaultSize;\n    let span2 = count2 * this._defaultSize;\n\n    // Adjust the spans for the modified sections.\n    for (let j = k1; j <= k2; ++j) {\n      let section = this._sections[j];\n      if (section.index < pivot) {\n        span1 += section.size - this._defaultSize;\n      } else {\n        span2 += section.size - this._defaultSize;\n      }\n    }\n\n    // Look up the pivot section.\n    let k3 = ArrayExt.lowerBound(this._sections, pivot, Private.indexCmp);\n\n    // Rotate the modified sections if needed.\n    if (k1 <= k3 && k3 <= k2) {\n      ArrayExt.rotate(this._sections, k3 - k1, k1, k2);\n    }\n\n    // Adjust the modified section indices and offsets.\n    for (let j = k1; j <= k2; ++j) {\n      let section = this._sections[j];\n      if (section.index < pivot) {\n        section.index += count2;\n        section.offset += span2;\n      } else {\n        section.index -= count1;\n        section.offset -= span1;\n      }\n    }\n  }\n\n  /**\n   * Reset all modified sections to the default size.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  reset(): void {\n    this._sections.length = 0;\n    this._length = this._count * this._defaultSize;\n  }\n\n  /**\n   * Remove all sections from the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  clear(): void {\n    this._count = 0;\n    this._length = 0;\n    this._sections.length = 0;\n  }\n\n  private _count = 0;\n  private _length = 0;\n  private _minimumSize: number;\n  private _defaultSize: number;\n  private _sections: Private.Section[] = [];\n}\n\n/**\n * The namespace for the `SectionList` class statics.\n */\nexport namespace SectionList {\n  /**\n   * An options object for initializing a section list.\n   */\n  export interface IOptions {\n    /**\n     * The size of new sections added to the list.\n     */\n    defaultSize: number;\n\n    /**\n     * The minimum size of the section list.\n     */\n    minimumSize?: number;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * An object which represents a modified section.\n   */\n  export type Section = {\n    /**\n     * The index of the section.\n     *\n     * This is always `>= 0`.\n     */\n    index: number;\n\n    /**\n     * The offset of the section.\n     */\n    offset: number;\n\n    /**\n     * The size of the section.\n     *\n     * This is always `>= 0`.\n     */\n    size: number;\n  };\n\n  /**\n   * A comparison function for searching by offset.\n   */\n  export function offsetCmp(section: Section, offset: number): number {\n    if (offset < section.offset) {\n      return 1;\n    }\n    if (section.offset + section.size <= offset) {\n      return -1;\n    }\n    return 0;\n  }\n\n  /**\n   * A comparison function for searching by index.\n   */\n  export function indexCmp(section: Section, index: number): number {\n    return section.index - index;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport { CellRenderer } from './cellrenderer';\n\nimport { DataModel } from './datamodel';\n\nimport { TextRenderer } from './textrenderer';\n\n/**\n * A class which manages the mapping of cell renderers.\n */\nexport class RendererMap {\n  /**\n   * Construct a new renderer map.\n   *\n   * @param values - The initial values for the map.\n   *\n   * @param fallback - The renderer of last resort.\n   */\n  constructor(values: RendererMap.Values = {}, fallback?: CellRenderer) {\n    this._values = { ...values };\n    this._fallback = fallback || new TextRenderer();\n  }\n\n  /**\n   * A signal emitted when the renderer map has changed.\n   */\n  get changed(): ISignal<this, void> {\n    return this._changed;\n  }\n\n  /**\n   * Get the cell renderer to use for the given cell config.\n   *\n   * @param config - The cell config of interest.\n   *\n   * @returns The renderer to use for the cell.\n   */\n  get(config: CellRenderer.CellConfig): CellRenderer {\n    // Fetch the renderer from the values map.\n    let renderer = this._values[config.region];\n\n    // Execute a resolver function if necessary.\n    if (typeof renderer === 'function') {\n      try {\n        renderer = renderer(config);\n      } catch (err) {\n        renderer = undefined;\n        console.error(err);\n      }\n    }\n\n    // Return the renderer or the fallback.\n    return renderer || this._fallback;\n  }\n\n  /**\n   * Update the renderer map with new values\n   *\n   * @param values - The updated values for the map.\n   *\n   * @param fallback - The renderer of last resort.\n   *\n   * #### Notes\n   * This method always emits the `changed` signal.\n   */\n  update(values: RendererMap.Values = {}, fallback?: CellRenderer): void {\n    this._values = { ...this._values, ...values };\n    this._fallback = fallback || this._fallback;\n    this._changed.emit(undefined);\n  }\n\n  private _fallback: CellRenderer;\n  private _values: RendererMap.Values;\n  private _changed = new Signal<this, void>(this);\n}\n\n/**\n * The namespace for the `RendererMap` class statics.\n */\nexport namespace RendererMap {\n  /**\n   * A type alias for a cell renderer resolver function.\n   */\n  export type Resolver = CellRenderer.ConfigFunc<CellRenderer | undefined>;\n\n  /**\n   * A type alias for a `RendererMap` values type.\n   */\n  export type Values = {\n    [R in DataModel.CellRegion]?: Resolver | CellRenderer | undefined;\n  };\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { toArray } from '@lumino/algorithm';\n\nimport { IDisposable } from '@lumino/disposable';\n\nimport { ClipboardExt, ElementExt, Platform } from '@lumino/domutils';\n\nimport {\n  ConflatableMessage,\n  IMessageHandler,\n  Message,\n  MessageLoop\n} from '@lumino/messaging';\n\nimport { GridLayout, ScrollBar, Widget } from '@lumino/widgets';\n\nimport { CellRenderer } from './cellrenderer';\n\nimport { DataModel, MutableDataModel } from './datamodel';\n\nimport { CellGroup } from './cellgroup';\n\nimport { GraphicsContext } from './graphicscontext';\n\nimport { RendererMap } from './renderermap';\n\nimport { SectionList } from './sectionlist';\n\nimport { SelectionModel } from './selectionmodel';\n\nimport {\n  CellEditorController,\n  ICellEditorController\n} from './celleditorcontroller';\n\nimport { JSONExt } from '@lumino/coreutils';\n\nimport { TextRenderer } from './textrenderer';\n\n/**\n * A widget which implements a high-performance tabular data grid.\n *\n * #### Notes\n * A data grid is implemented as a composition of child widgets. These\n * child widgets are considered an implementation detail. Manipulating\n * the child widgets of a data grid directly is undefined behavior.\n *\n * This class is not designed to be subclassed.\n */\nexport class DataGrid extends Widget {\n  /**\n   * Construct a new data grid.\n   *\n   * @param options - The options for initializing the data grid.\n   */\n  constructor(options: DataGrid.IOptions = {}) {\n    super();\n    this.addClass('lm-DataGrid');\n    /* <DEPRECATED> */\n    this.addClass('p-DataGrid');\n    /* </DEPRECATED> */\n\n    // Parse the simple options.\n    this._style = options.style || DataGrid.defaultStyle;\n    this._stretchLastRow = options.stretchLastRow || false;\n    this._stretchLastColumn = options.stretchLastColumn || false;\n    this._headerVisibility = options.headerVisibility || 'all';\n    this._cellRenderers = options.cellRenderers || new RendererMap();\n    this._copyConfig = options.copyConfig || DataGrid.defaultCopyConfig;\n\n    // Connect to the renderer map changed signal.\n    this._cellRenderers.changed.connect(this._onRenderersChanged, this);\n\n    // Parse the default sizes.\n    let defaultSizes = options.defaultSizes || DataGrid.defaultSizes;\n    let minimumSizes = options.minimumSizes || DataGrid.minimumSizes;\n\n    // Set up the sections lists.\n    this._rowSections = new SectionList({\n      defaultSize: defaultSizes.rowHeight,\n      minimumSize: minimumSizes.rowHeight\n    });\n    this._columnSections = new SectionList({\n      defaultSize: defaultSizes.columnWidth,\n      minimumSize: minimumSizes.columnWidth\n    });\n    this._rowHeaderSections = new SectionList({\n      defaultSize: defaultSizes.rowHeaderWidth,\n      minimumSize: minimumSizes.rowHeaderWidth\n    });\n    this._columnHeaderSections = new SectionList({\n      defaultSize: defaultSizes.columnHeaderHeight,\n      minimumSize: minimumSizes.columnHeaderHeight\n    });\n\n    // Create the canvas, buffer, and overlay objects.\n    this._canvas = Private.createCanvas();\n    this._buffer = Private.createCanvas();\n    this._overlay = Private.createCanvas();\n\n    // Get the graphics contexts for the canvases.\n    this._canvasGC = this._canvas.getContext('2d')!;\n    this._bufferGC = this._buffer.getContext('2d')!;\n    this._overlayGC = this._overlay.getContext('2d')!;\n\n    // Set up the on-screen canvas.\n    this._canvas.style.position = 'absolute';\n    this._canvas.style.top = '0px';\n    this._canvas.style.left = '0px';\n    this._canvas.style.width = '0px';\n    this._canvas.style.height = '0px';\n\n    // Set up the on-screen overlay.\n    this._overlay.style.position = 'absolute';\n    this._overlay.style.top = '0px';\n    this._overlay.style.left = '0px';\n    this._overlay.style.width = '0px';\n    this._overlay.style.height = '0px';\n\n    // Create the internal widgets for the data grid.\n    this._viewport = new Widget();\n    this._viewport.node.tabIndex = -1;\n    this._viewport.node.style.outline = 'none';\n    this._vScrollBar = new ScrollBar({ orientation: 'vertical' });\n    this._hScrollBar = new ScrollBar({ orientation: 'horizontal' });\n    this._scrollCorner = new Widget();\n\n    this._editorController = new CellEditorController();\n\n    // Add the extra class names to the child widgets.\n    this._viewport.addClass('lm-DataGrid-viewport');\n    this._vScrollBar.addClass('lm-DataGrid-scrollBar');\n    this._hScrollBar.addClass('lm-DataGrid-scrollBar');\n    this._scrollCorner.addClass('lm-DataGrid-scrollCorner');\n    /* <DEPRECATED> */\n    this._viewport.addClass('p-DataGrid-viewport');\n    this._vScrollBar.addClass('p-DataGrid-scrollBar');\n    this._hScrollBar.addClass('p-DataGrid-scrollBar');\n    this._scrollCorner.addClass('p-DataGrid-scrollCorner');\n    /* </DEPRECATED> */\n\n    // Add the on-screen canvas to the viewport node.\n    this._viewport.node.appendChild(this._canvas);\n\n    // Add the on-screen overlay to the viewport node.\n    this._viewport.node.appendChild(this._overlay);\n\n    // Install the message hooks.\n    MessageLoop.installMessageHook(this._viewport, this);\n    MessageLoop.installMessageHook(this._hScrollBar, this);\n    MessageLoop.installMessageHook(this._vScrollBar, this);\n\n    // Hide the scroll bars and corner from the outset.\n    this._vScrollBar.hide();\n    this._hScrollBar.hide();\n    this._scrollCorner.hide();\n\n    // Connect to the scroll bar signals.\n    this._vScrollBar.thumbMoved.connect(this._onThumbMoved, this);\n    this._hScrollBar.thumbMoved.connect(this._onThumbMoved, this);\n    this._vScrollBar.pageRequested.connect(this._onPageRequested, this);\n    this._hScrollBar.pageRequested.connect(this._onPageRequested, this);\n    this._vScrollBar.stepRequested.connect(this._onStepRequested, this);\n    this._hScrollBar.stepRequested.connect(this._onStepRequested, this);\n\n    // Set the layout cell config for the child widgets.\n    GridLayout.setCellConfig(this._viewport, { row: 0, column: 0 });\n    GridLayout.setCellConfig(this._vScrollBar, { row: 0, column: 1 });\n    GridLayout.setCellConfig(this._hScrollBar, { row: 1, column: 0 });\n    GridLayout.setCellConfig(this._scrollCorner, { row: 1, column: 1 });\n\n    // Create the layout for the data grid.\n    let layout = new GridLayout({\n      rowCount: 2,\n      columnCount: 2,\n      rowSpacing: 0,\n      columnSpacing: 0,\n      fitPolicy: 'set-no-constraint'\n    });\n\n    // Set the stretch factors for the grid.\n    layout.setRowStretch(0, 1);\n    layout.setRowStretch(1, 0);\n    layout.setColumnStretch(0, 1);\n    layout.setColumnStretch(1, 0);\n\n    // Add the child widgets to the layout.\n    layout.addWidget(this._viewport);\n    layout.addWidget(this._vScrollBar);\n    layout.addWidget(this._hScrollBar);\n    layout.addWidget(this._scrollCorner);\n\n    // Install the layout on the data grid.\n    this.layout = layout;\n  }\n\n  /**\n   * Dispose of the resources held by the widgets.\n   */\n  dispose(): void {\n    // Release the mouse.\n    this._releaseMouse();\n\n    // Dispose of the handlers.\n    if (this._keyHandler) {\n      this._keyHandler.dispose();\n    }\n    if (this._mouseHandler) {\n      this._mouseHandler.dispose();\n    }\n    this._keyHandler = null;\n    this._mouseHandler = null;\n\n    // Clear the models.\n    this._dataModel = null;\n    this._selectionModel = null;\n\n    // Clear the section lists.\n    this._rowSections.clear();\n    this._columnSections.clear();\n    this._rowHeaderSections.clear();\n    this._columnHeaderSections.clear();\n\n    // Dispose of the base class.\n    super.dispose();\n  }\n\n  /**\n   * Get the data model for the data grid.\n   */\n  get dataModel(): DataModel | null {\n    return this._dataModel;\n  }\n\n  /**\n   * Set the data model for the data grid.\n   *\n   * #### Notes\n   * This will automatically remove the current selection model.\n   */\n  set dataModel(value: DataModel | null) {\n    // Do nothing if the model does not change.\n    if (this._dataModel === value) {\n      return;\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n\n    // Clear the selection model.\n    this.selectionModel = null;\n\n    // Disconnect the change handler from the old model.\n    if (this._dataModel) {\n      this._dataModel.changed.disconnect(this._onDataModelChanged, this);\n    }\n\n    // Connect the change handler for the new model.\n    if (value) {\n      value.changed.connect(this._onDataModelChanged, this);\n    }\n\n    // Update the internal model reference.\n    this._dataModel = value;\n\n    // Clear the section lists.\n    this._rowSections.clear();\n    this._columnSections.clear();\n    this._rowHeaderSections.clear();\n    this._columnHeaderSections.clear();\n\n    // Populate the section lists.\n    if (value) {\n      this._rowSections.insert(0, value.rowCount('body'));\n      this._columnSections.insert(0, value.columnCount('body'));\n      this._rowHeaderSections.insert(0, value.columnCount('row-header'));\n      this._columnHeaderSections.insert(0, value.rowCount('column-header'));\n    }\n\n    // Reset the scroll position.\n    this._scrollX = 0;\n    this._scrollY = 0;\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Get the selection model for the data grid.\n   */\n  get selectionModel(): SelectionModel | null {\n    return this._selectionModel;\n  }\n\n  /**\n   * Set the selection model for the data grid.\n   */\n  set selectionModel(value: SelectionModel | null) {\n    // Do nothing if the selection model does not change.\n    if (this._selectionModel === value) {\n      return;\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n\n    // Ensure the data models are a match.\n    if (value && value.dataModel !== this._dataModel) {\n      throw new Error('SelectionModel.dataModel !== DataGrid.dataModel');\n    }\n\n    // Disconnect the change handler from the old model.\n    if (this._selectionModel) {\n      this._selectionModel.changed.disconnect(this._onSelectionsChanged, this);\n    }\n\n    // Connect the change handler for the new model.\n    if (value) {\n      value.changed.connect(this._onSelectionsChanged, this);\n    }\n\n    // Update the internal selection model reference.\n    this._selectionModel = value;\n\n    // Schedule a repaint of the overlay.\n    this.repaintOverlay();\n  }\n\n  /**\n   * Get the key handler for the data grid.\n   */\n  get keyHandler(): DataGrid.IKeyHandler | null {\n    return this._keyHandler;\n  }\n\n  /**\n   * Set the key handler for the data grid.\n   */\n  set keyHandler(value: DataGrid.IKeyHandler | null) {\n    this._keyHandler = value;\n  }\n\n  /**\n   * Get the mouse handler for the data grid.\n   */\n  get mouseHandler(): DataGrid.IMouseHandler | null {\n    return this._mouseHandler;\n  }\n\n  /**\n   * Set the mouse handler for the data grid.\n   */\n  set mouseHandler(value: DataGrid.IMouseHandler | null) {\n    // Bail early if the mouse handler does not change.\n    if (this._mouseHandler === value) {\n      return;\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n\n    // Update the internal mouse handler.\n    this._mouseHandler = value;\n  }\n\n  /**\n   * Get the style for the data grid.\n   */\n  get style(): DataGrid.Style {\n    return this._style;\n  }\n\n  /**\n   * Set the style for the data grid.\n   */\n  set style(value: DataGrid.Style) {\n    // Bail if the style does not change.\n    if (this._style === value) {\n      return;\n    }\n\n    // Update the internal style.\n    this._style = { ...value };\n\n    // Schedule a repaint of the content.\n    this.repaintContent();\n\n    // Schedule a repaint of the overlay.\n    this.repaintOverlay();\n  }\n\n  /**\n   * Get the cell renderer map for the data grid.\n   */\n  get cellRenderers(): RendererMap {\n    return this._cellRenderers;\n  }\n\n  /**\n   * Set the cell renderer map for the data grid.\n   */\n  set cellRenderers(value: RendererMap) {\n    // Bail if the renderer map does not change.\n    if (this._cellRenderers === value) {\n      return;\n    }\n\n    // Disconnect the old map.\n    this._cellRenderers.changed.disconnect(this._onRenderersChanged, this);\n\n    // Connect the new map.\n    value.changed.connect(this._onRenderersChanged, this);\n\n    // Update the internal renderer map.\n    this._cellRenderers = value;\n\n    // Schedule a repaint of the grid content.\n    this.repaintContent();\n  }\n\n  /**\n   * Get the header visibility for the data grid.\n   */\n  get headerVisibility(): DataGrid.HeaderVisibility {\n    return this._headerVisibility;\n  }\n\n  /**\n   * Set the header visibility for the data grid.\n   */\n  set headerVisibility(value: DataGrid.HeaderVisibility) {\n    // Bail if the visibility does not change.\n    if (this._headerVisibility === value) {\n      return;\n    }\n\n    // Update the internal visibility.\n    this._headerVisibility = value;\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Get the default sizes for the various sections of the data grid.\n   */\n  get defaultSizes(): DataGrid.DefaultSizes {\n    let rowHeight = this._rowSections.defaultSize;\n    let columnWidth = this._columnSections.defaultSize;\n    let rowHeaderWidth = this._rowHeaderSections.defaultSize;\n    let columnHeaderHeight = this._columnHeaderSections.defaultSize;\n    return { rowHeight, columnWidth, rowHeaderWidth, columnHeaderHeight };\n  }\n\n  /**\n   * Set the default sizes for the various sections of the data grid.\n   */\n  set defaultSizes(value: DataGrid.DefaultSizes) {\n    // Update the section default sizes.\n    this._rowSections.defaultSize = value.rowHeight;\n    this._columnSections.defaultSize = value.columnWidth;\n    this._rowHeaderSections.defaultSize = value.rowHeaderWidth;\n    this._columnHeaderSections.defaultSize = value.columnHeaderHeight;\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Get the minimum sizes for the various sections of the data grid.\n   */\n  get minimumSizes(): DataGrid.DefaultSizes {\n    let rowHeight = this._rowSections.minimumSize;\n    let columnWidth = this._columnSections.minimumSize;\n    let rowHeaderWidth = this._rowHeaderSections.minimumSize;\n    let columnHeaderHeight = this._columnHeaderSections.minimumSize;\n    return { rowHeight, columnWidth, rowHeaderWidth, columnHeaderHeight };\n  }\n\n  /**\n   * Set the minimum sizes for the various sections of the data grid.\n   */\n  set minimumSizes(value: DataGrid.DefaultSizes) {\n    // Update the section default sizes.\n    this._rowSections.minimumSize = value.rowHeight;\n    this._columnSections.minimumSize = value.columnWidth;\n    this._rowHeaderSections.minimumSize = value.rowHeaderWidth;\n    this._columnHeaderSections.minimumSize = value.columnHeaderHeight;\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Get the copy configuration for the data grid.\n   */\n  get copyConfig(): DataGrid.CopyConfig {\n    return this._copyConfig;\n  }\n\n  /**\n   * Set the copy configuration for the data grid.\n   */\n  set copyConfig(value: DataGrid.CopyConfig) {\n    this._copyConfig = value;\n  }\n\n  /**\n   * Get whether the last row is stretched.\n   */\n  get stretchLastRow(): boolean {\n    return this._stretchLastRow;\n  }\n\n  /**\n   * Set whether the last row is stretched.\n   */\n  set stretchLastRow(value: boolean) {\n    // Bail early if the value does not change.\n    if (value === this._stretchLastRow) {\n      return;\n    }\n\n    // Update the internal value.\n    this._stretchLastRow = value;\n\n    // Sync the viewport\n    this._syncViewport();\n  }\n\n  /**\n   * Get whether the last column is stretched.\n   */\n  get stretchLastColumn(): boolean {\n    return this._stretchLastColumn;\n  }\n\n  /**\n   * Set whether the last column is stretched.\n   */\n  set stretchLastColumn(value: boolean) {\n    // Bail early if the value does not change.\n    if (value === this._stretchLastColumn) {\n      return;\n    }\n\n    // Update the internal value.\n    this._stretchLastColumn = value;\n\n    // Sync the viewport\n    this._syncViewport();\n  }\n\n  /**\n   * The virtual width of the row headers.\n   */\n  get headerWidth(): number {\n    if (this._headerVisibility === 'none') {\n      return 0;\n    }\n    if (this._headerVisibility === 'column') {\n      return 0;\n    }\n    return this._rowHeaderSections.length;\n  }\n\n  /**\n   * The virtual height of the column headers.\n   */\n  get headerHeight(): number {\n    if (this._headerVisibility === 'none') {\n      return 0;\n    }\n    if (this._headerVisibility === 'row') {\n      return 0;\n    }\n    return this._columnHeaderSections.length;\n  }\n\n  /**\n   * The virtual width of the grid body.\n   *\n   * #### Notes\n   * This does *not* account for a stretched last column.\n   */\n  get bodyWidth(): number {\n    return this._columnSections.length;\n  }\n\n  /**\n   * The virtual height of the grid body.\n   *\n   * #### Notes\n   * This does *not* account for a stretched last row.\n   */\n  get bodyHeight(): number {\n    return this._rowSections.length;\n  }\n\n  /**\n   * The virtual width of the entire grid.\n   *\n   * #### Notes\n   * This does *not* account for a stretched last column.\n   */\n  get totalWidth(): number {\n    return this.headerWidth + this.bodyWidth;\n  }\n\n  /**\n   * The virtual height of the entire grid.\n   *\n   * #### Notes\n   * This does *not* account for a stretched last row.\n   */\n  get totalHeight(): number {\n    return this.headerHeight + this.bodyHeight;\n  }\n\n  /**\n   * The actual width of the viewport.\n   */\n  get viewportWidth(): number {\n    return this._viewportWidth;\n  }\n\n  /**\n   * The actual height of the viewport.\n   */\n  get viewportHeight(): number {\n    return this._viewportHeight;\n  }\n\n  /**\n   * The width of the visible portion of the grid body.\n   */\n  get pageWidth(): number {\n    return Math.max(0, this.viewportWidth - this.headerWidth);\n  }\n\n  /**\n   * The height of the visible portion of the grid body.\n   */\n  get pageHeight(): number {\n    return Math.max(0, this.viewportHeight - this.headerHeight);\n  }\n\n  /**\n   * The current scroll X position of the viewport.\n   */\n  get scrollX(): number {\n    return this._hScrollBar.value;\n  }\n\n  /**\n   * The current scroll Y position of the viewport.\n   */\n  get scrollY(): number {\n    return this._vScrollBar.value;\n  }\n\n  /**\n   * The maximum scroll X position for the grid.\n   */\n  get maxScrollX(): number {\n    return Math.max(0, this.bodyWidth - this.pageWidth - 1);\n  }\n\n  /**\n   * The maximum scroll Y position for the grid.\n   */\n  get maxScrollY(): number {\n    return Math.max(0, this.bodyHeight - this.pageHeight - 1);\n  }\n\n  /**\n   * The viewport widget for the data grid.\n   */\n  get viewport(): Widget {\n    return this._viewport;\n  }\n\n  /**\n   * The cell editor controller object for the data grid.\n   */\n  get editorController(): ICellEditorController | null {\n    return this._editorController;\n  }\n\n  set editorController(controller: ICellEditorController | null) {\n    this._editorController = controller;\n  }\n\n  /**\n   * Whether the cell editing is enabled for the data grid.\n   */\n  get editingEnabled(): boolean {\n    return this._editingEnabled;\n  }\n\n  set editingEnabled(enabled: boolean) {\n    this._editingEnabled = enabled;\n  }\n\n  /**\n   * Whether the grid cells are editable.\n   *\n   * `editingEnabled` flag must be on and grid must have required\n   * selection model, editor controller and data model properties.\n   */\n  get editable(): boolean {\n    return (\n      this._editingEnabled &&\n      this._selectionModel !== null &&\n      this._editorController !== null &&\n      this.dataModel instanceof MutableDataModel\n    );\n  }\n\n  /**\n   * The rendering context for painting the data grid.\n   */\n  protected get canvasGC(): CanvasRenderingContext2D {\n    return this._canvasGC;\n  }\n\n  /**\n   * The row sections of the data grid.\n   */\n  protected get rowSections(): SectionList {\n    return this._rowSections;\n  }\n\n  /**\n   * The column sections of the data grid.\n   */\n  protected get columnSections(): SectionList {\n    return this._columnSections;\n  }\n\n  /**\n   * The row header sections of the data grid.\n   */\n  protected get rowHeaderSections(): SectionList {\n    return this._rowHeaderSections;\n  }\n\n  /**\n   * The column header sections of the data grid.\n   */\n  protected get columnHeaderSections(): SectionList {\n    return this._columnHeaderSections;\n  }\n\n  /**\n   * Scroll the grid to the specified row.\n   *\n   * @param row - The row index of the cell.\n   *\n   * #### Notes\n   * This is a no-op if the row is already visible.\n   */\n  scrollToRow(row: number): void {\n    // Fetch the row count.\n    let nr = this._rowSections.count;\n\n    // Bail early if there is no content.\n    if (nr === 0) {\n      return;\n    }\n\n    // Floor the row index.\n    row = Math.floor(row);\n\n    // Clamp the row index.\n    row = Math.max(0, Math.min(row, nr - 1));\n\n    // Get the virtual bounds of the row.\n    let y1 = this._rowSections.offsetOf(row);\n    let y2 = this._rowSections.extentOf(row);\n\n    // Get the virtual bounds of the viewport.\n    let vy1 = this._scrollY;\n    let vy2 = this._scrollY + this.pageHeight - 1;\n\n    // Set up the delta variables.\n    let dy = 0;\n\n    // Compute the delta Y scroll.\n    if (y1 < vy1) {\n      dy = y1 - vy1 - 10;\n    } else if (y2 > vy2) {\n      dy = y2 - vy2 + 10;\n    }\n\n    // Bail early if no scroll is needed.\n    if (dy === 0) {\n      return;\n    }\n\n    // Scroll by the computed delta.\n    this.scrollBy(0, dy);\n  }\n\n  /**\n   * Scroll the grid to the specified column.\n   *\n   * @param column - The column index of the cell.\n   *\n   * #### Notes\n   * This is a no-op if the column is already visible.\n   */\n  scrollToColumn(column: number): void {\n    // Fetch the column count.\n    let nc = this._columnSections.count;\n\n    // Bail early if there is no content.\n    if (nc === 0) {\n      return;\n    }\n\n    // Floor the column index.\n    column = Math.floor(column);\n\n    // Clamp the column index.\n    column = Math.max(0, Math.min(column, nc - 1));\n\n    // Get the virtual bounds of the column.\n    let x1 = this._columnSections.offsetOf(column);\n    let x2 = this._columnSections.extentOf(column);\n\n    // Get the virtual bounds of the viewport.\n    let vx1 = this._scrollX;\n    let vx2 = this._scrollX + this.pageWidth - 1;\n\n    // Set up the delta variables.\n    let dx = 0;\n\n    // Compute the delta X scroll.\n    if (x1 < vx1) {\n      dx = x1 - vx1 - 10;\n    } else if (x2 > vx2) {\n      dx = x2 - vx2 + 10;\n    }\n\n    // Bail early if no scroll is needed.\n    if (dx === 0) {\n      return;\n    }\n\n    // Scroll by the computed delta.\n    this.scrollBy(dx, 0);\n  }\n\n  /**\n   * Scroll the grid to the specified cell.\n   *\n   * @param row - The row index of the cell.\n   *\n   * @param column - The column index of the cell.\n   *\n   * #### Notes\n   * This is a no-op if the cell is already visible.\n   */\n  scrollToCell(row: number, column: number): void {\n    // Fetch the row and column count.\n    let nr = this._rowSections.count;\n    let nc = this._columnSections.count;\n\n    // Bail early if there is no content.\n    if (nr === 0 || nc === 0) {\n      return;\n    }\n\n    // Floor the cell index.\n    row = Math.floor(row);\n    column = Math.floor(column);\n\n    // Clamp the cell index.\n    row = Math.max(0, Math.min(row, nr - 1));\n    column = Math.max(0, Math.min(column, nc - 1));\n\n    // Get the virtual bounds of the cell.\n    let x1 = this._columnSections.offsetOf(column);\n    let x2 = this._columnSections.extentOf(column);\n    let y1 = this._rowSections.offsetOf(row);\n    let y2 = this._rowSections.extentOf(row);\n\n    // Get the virtual bounds of the viewport.\n    let vx1 = this._scrollX;\n    let vx2 = this._scrollX + this.pageWidth - 1;\n    let vy1 = this._scrollY;\n    let vy2 = this._scrollY + this.pageHeight - 1;\n\n    // Set up the delta variables.\n    let dx = 0;\n    let dy = 0;\n\n    // Compute the delta X scroll.\n    if (x1 < vx1) {\n      dx = x1 - vx1 - 10;\n    } else if (x2 > vx2) {\n      dx = x2 - vx2 + 10;\n    }\n\n    // Compute the delta Y scroll.\n    if (y1 < vy1) {\n      dy = y1 - vy1 - 10;\n    } else if (y2 > vy2) {\n      dy = y2 - vy2 + 10;\n    }\n\n    // Bail early if no scroll is needed.\n    if (dx === 0 && dy === 0) {\n      return;\n    }\n\n    // Scroll by the computed delta.\n    this.scrollBy(dx, dy);\n  }\n\n  /**\n   * Move cursor down/up/left/right while making sure it remains\n   * within the bounds of selected rectangles\n   *\n   * @param direction - The direction of the movement.\n   */\n  moveCursor(direction: SelectionModel.CursorMoveDirection): void {\n    // Bail early if there is no selection\n    if (\n      !this.dataModel ||\n      !this._selectionModel ||\n      this._selectionModel.isEmpty\n    ) {\n      return;\n    }\n\n    const iter = this._selectionModel.selections();\n    const onlyOne = iter.next() && !iter.next();\n\n    // if there is a single selection that is a single cell selection\n    // then move the selection and cursor within grid bounds\n    if (onlyOne) {\n      const currentSel = this._selectionModel.currentSelection()!;\n      if (currentSel.r1 === currentSel.r2 && currentSel.c1 === currentSel.c2) {\n        const dr = direction === 'down' ? 1 : direction === 'up' ? -1 : 0;\n        const dc = direction === 'right' ? 1 : direction === 'left' ? -1 : 0;\n        let newRow = currentSel.r1 + dr;\n        let newColumn = currentSel.c1 + dc;\n        const rowCount = this.dataModel.rowCount('body');\n        const columnCount = this.dataModel.columnCount('body');\n        if (newRow >= rowCount) {\n          newRow = 0;\n          newColumn += 1;\n        } else if (newRow === -1) {\n          newRow = rowCount - 1;\n          newColumn -= 1;\n        }\n        if (newColumn >= columnCount) {\n          newColumn = 0;\n          newRow += 1;\n          if (newRow >= rowCount) {\n            newRow = 0;\n          }\n        } else if (newColumn === -1) {\n          newColumn = columnCount - 1;\n          newRow -= 1;\n          if (newRow === -1) {\n            newRow = rowCount - 1;\n          }\n        }\n\n        this._selectionModel.select({\n          r1: newRow,\n          c1: newColumn,\n          r2: newRow,\n          c2: newColumn,\n          cursorRow: newRow,\n          cursorColumn: newColumn,\n          clear: 'all'\n        });\n\n        return;\n      }\n    }\n\n    // if there are multiple selections, move cursor\n    // within selection rectangles\n    this._selectionModel.moveCursorWithinSelections(direction);\n  }\n\n  /**\n   * Scroll the grid to the current cursor position.\n   *\n   * #### Notes\n   * This is a no-op if the cursor is already visible or\n   * if there is no selection model installed on the grid.\n   */\n  scrollToCursor(): void {\n    // Bail early if there is no selection model.\n    if (!this._selectionModel) {\n      return;\n    }\n\n    // Fetch the cursor row and column.\n    let row = this._selectionModel.cursorRow;\n    let column = this._selectionModel.cursorColumn;\n\n    // Scroll to the cursor cell.\n    this.scrollToCell(row, column);\n  }\n\n  /**\n   * Scroll the viewport by the specified amount.\n   *\n   * @param dx - The X scroll amount.\n   *\n   * @param dy - The Y scroll amount.\n   */\n  scrollBy(dx: number, dy: number): void {\n    this.scrollTo(this.scrollX + dx, this.scrollY + dy);\n  }\n\n  /**\n   * Scroll the viewport by one page.\n   *\n   * @param dir - The desired direction of the scroll.\n   */\n  scrollByPage(dir: 'up' | 'down' | 'left' | 'right'): void {\n    let dx = 0;\n    let dy = 0;\n    switch (dir) {\n      case 'up':\n        dy = -this.pageHeight;\n        break;\n      case 'down':\n        dy = this.pageHeight;\n        break;\n      case 'left':\n        dx = -this.pageWidth;\n        break;\n      case 'right':\n        dx = this.pageWidth;\n        break;\n      default:\n        throw 'unreachable';\n    }\n    this.scrollTo(this.scrollX + dx, this.scrollY + dy);\n  }\n\n  /**\n   * Scroll the viewport by one cell-aligned step.\n   *\n   * @param dir - The desired direction of the scroll.\n   */\n  scrollByStep(dir: 'up' | 'down' | 'left' | 'right'): void {\n    let r: number;\n    let c: number;\n    let x = this.scrollX;\n    let y = this.scrollY;\n    let rows = this._rowSections;\n    let columns = this._columnSections;\n    switch (dir) {\n      case 'up':\n        r = rows.indexOf(y - 1);\n        y = r < 0 ? y : rows.offsetOf(r);\n        break;\n      case 'down':\n        r = rows.indexOf(y);\n        y = r < 0 ? y : rows.offsetOf(r) + rows.sizeOf(r);\n        break;\n      case 'left':\n        c = columns.indexOf(x - 1);\n        x = c < 0 ? x : columns.offsetOf(c);\n        break;\n      case 'right':\n        c = columns.indexOf(x);\n        x = c < 0 ? x : columns.offsetOf(c) + columns.sizeOf(c);\n        break;\n      default:\n        throw 'unreachable';\n    }\n    this.scrollTo(x, y);\n  }\n\n  /**\n   * Scroll to the specified offset position.\n   *\n   * @param x - The desired X position.\n   *\n   * @param y - The desired Y position.\n   */\n  scrollTo(x: number, y: number): void {\n    // Floor and clamp the position to the allowable range.\n    x = Math.max(0, Math.min(Math.floor(x), this.maxScrollX));\n    y = Math.max(0, Math.min(Math.floor(y), this.maxScrollY));\n\n    // Update the scroll bar values with the desired position.\n    this._hScrollBar.value = x;\n    this._vScrollBar.value = y;\n\n    // Post a scroll request message to the viewport.\n    MessageLoop.postMessage(this._viewport, Private.ScrollRequest);\n  }\n\n  /**\n   * Get the row count for a particular region in the data grid.\n   *\n   * @param region - The row region of interest.\n   *\n   * @returns The row count for the specified region.\n   */\n  rowCount(region: DataModel.RowRegion): number {\n    let count: number;\n    if (region === 'body') {\n      count = this._rowSections.count;\n    } else {\n      count = this._columnHeaderSections.count;\n    }\n    return count;\n  }\n\n  /**\n   * Get the column count for a particular region in the data grid.\n   *\n   * @param region - The column region of interest.\n   *\n   * @returns The column count for the specified region.\n   */\n  columnCount(region: DataModel.ColumnRegion): number {\n    let count: number;\n    if (region === 'body') {\n      count = this._columnSections.count;\n    } else {\n      count = this._rowHeaderSections.count;\n    }\n    return count;\n  }\n\n  /**\n   * Get the row at a virtual offset in the data grid.\n   *\n   * @param region - The region which holds the row of interest.\n   *\n   * @param offset - The virtual offset of the row of interest.\n   *\n   * @returns The index of the row, or `-1` if the offset is out of range.\n   *\n   * #### Notes\n   * This method accounts for a stretched last row.\n   */\n  rowAt(region: DataModel.RowRegion, offset: number): number {\n    // Bail early if the offset is negative.\n    if (offset < 0) {\n      return -1;\n    }\n\n    // Return early for the column header region.\n    if (region === 'column-header') {\n      return this._columnHeaderSections.indexOf(offset);\n    }\n\n    // Fetch the index.\n    let index = this._rowSections.indexOf(offset);\n\n    // Return early if the section is found.\n    if (index >= 0) {\n      return index;\n    }\n\n    // Bail early if the last row is not stretched.\n    if (!this._stretchLastRow) {\n      return -1;\n    }\n\n    // Fetch the geometry.\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n\n    // Bail early if no row stretching is required.\n    if (ph <= bh) {\n      return -1;\n    }\n\n    // Bail early if the offset is out of bounds.\n    if (offset >= ph) {\n      return -1;\n    }\n\n    // Otherwise, return the last row.\n    return this._rowSections.count - 1;\n  }\n\n  /**\n   * Get the column at a virtual offset in the data grid.\n   *\n   * @param region - The region which holds the column of interest.\n   *\n   * @param offset - The virtual offset of the column of interest.\n   *\n   * @returns The index of the column, or `-1` if the offset is out of range.\n   *\n   * #### Notes\n   * This method accounts for a stretched last column.\n   */\n  columnAt(region: DataModel.ColumnRegion, offset: number): number {\n    if (offset < 0) {\n      return -1;\n    }\n\n    // Return early for the row header region.\n    if (region === 'row-header') {\n      return this._rowHeaderSections.indexOf(offset);\n    }\n\n    // Fetch the index.\n    let index = this._columnSections.indexOf(offset);\n\n    // Return early if the section is found.\n    if (index >= 0) {\n      return index;\n    }\n\n    // Bail early if the last column is not stretched.\n    if (!this._stretchLastColumn) {\n      return -1;\n    }\n\n    // Fetch the geometry.\n    let bw = this.bodyWidth;\n    let pw = this.pageWidth;\n\n    // Bail early if no column stretching is required.\n    if (pw <= bw) {\n      return -1;\n    }\n\n    // Bail early if the offset is out of bounds.\n    if (offset >= pw) {\n      return -1;\n    }\n\n    // Otherwise, return the last column.\n    return this._columnSections.count - 1;\n  }\n\n  /**\n   * Get the offset of a row in the data grid.\n   *\n   * @param region - The region which holds the row of interest.\n   *\n   * @param index - The index of the row of interest.\n   *\n   * @returns The offset of the row, or `-1` if the index is out of range.\n   *\n   * #### Notes\n   * A stretched last row has no effect on the return value.\n   */\n  rowOffset(region: DataModel.RowRegion, index: number): number {\n    let offset: number;\n    if (region === 'body') {\n      offset = this._rowSections.offsetOf(index);\n    } else {\n      offset = this._columnHeaderSections.offsetOf(index);\n    }\n    return offset;\n  }\n\n  /**\n   * Get the offset of a column in the data grid.\n   *\n   * @param region - The region which holds the column of interest.\n   *\n   * @param index - The index of the column of interest.\n   *\n   * @returns The offset of the column, or `-1` if the index is out of range.\n   *\n   * #### Notes\n   * A stretched last column has no effect on the return value.\n   */\n  columnOffset(region: DataModel.ColumnRegion, index: number): number {\n    let offset: number;\n    if (region === 'body') {\n      offset = this._columnSections.offsetOf(index);\n    } else {\n      offset = this._rowHeaderSections.offsetOf(index);\n    }\n    return offset;\n  }\n\n  /**\n   * Get the size of a row in the data grid.\n   *\n   * @param region - The region which holds the row of interest.\n   *\n   * @param index - The index of the row of interest.\n   *\n   * @returns The size of the row, or `-1` if the index is out of range.\n   *\n   * #### Notes\n   * This method accounts for a stretched last row.\n   */\n  rowSize(region: DataModel.RowRegion, index: number): number {\n    // Return early for the column header region.\n    if (region === 'column-header') {\n      return this._columnHeaderSections.sizeOf(index);\n    }\n\n    // Fetch the row size.\n    let size = this._rowSections.sizeOf(index);\n\n    // Bail early if the index is out of bounds.\n    if (size < 0) {\n      return size;\n    }\n\n    // Return early if the last row is not stretched.\n    if (!this._stretchLastRow) {\n      return size;\n    }\n\n    // Return early if its not the last row.\n    if (index < this._rowSections.count - 1) {\n      return size;\n    }\n\n    // Fetch the geometry.\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n\n    // Return early if no stretching is needed.\n    if (ph <= bh) {\n      return size;\n    }\n\n    // Return the adjusted size.\n    return size + (ph - bh);\n  }\n\n  /**\n   * Get the size of a column in the data grid.\n   *\n   * @param region - The region which holds the column of interest.\n   *\n   * @param index - The index of the column of interest.\n   *\n   * @returns The size of the column, or `-1` if the index is out of range.\n   *\n   * #### Notes\n   * This method accounts for a stretched last column.\n   */\n  columnSize(region: DataModel.ColumnRegion, index: number): number {\n    // Return early for the row header region.\n    if (region === 'row-header') {\n      return this._rowHeaderSections.sizeOf(index);\n    }\n\n    // Fetch the column size.\n    let size = this._columnSections.sizeOf(index);\n\n    // Bail early if the index is out of bounds.\n    if (size < 0) {\n      return size;\n    }\n\n    // Return early if the last column is not stretched.\n    if (!this._stretchLastColumn) {\n      return size;\n    }\n\n    // Return early if its not the last column.\n    if (index < this._columnSections.count - 1) {\n      return size;\n    }\n\n    // Fetch the geometry.\n    let bw = this.bodyWidth;\n    let pw = this.pageWidth;\n\n    // Return early if no stretching is needed.\n    if (pw <= bw) {\n      return size;\n    }\n\n    // Return the adjusted size.\n    return size + (pw - bw);\n  }\n\n  /**\n   * Resize a row in the data grid.\n   *\n   * @param region - The region which holds the row of interest.\n   *\n   * @param index - The index of the row of interest.\n   *\n   * @param size - The desired size of the row.\n   */\n  resizeRow(region: DataModel.RowRegion, index: number, size: number): void {\n    let msg = new Private.RowResizeRequest(region, index, size);\n    MessageLoop.postMessage(this._viewport, msg);\n  }\n\n  /**\n   * Resize a column in the data grid.\n   *\n   * @param region - The region which holds the column of interest.\n   *\n   * @param index - The index of the column of interest.\n   *\n   * @param size - The desired size of the column.\n   */\n  resizeColumn(\n    region: DataModel.ColumnRegion,\n    index: number,\n    size: number\n  ): void {\n    let msg = new Private.ColumnResizeRequest(region, index, size);\n    MessageLoop.postMessage(this._viewport, msg);\n  }\n\n  /**\n   * Reset modified rows to their default size.\n   *\n   * @param region - The row region of interest.\n   */\n  resetRows(region: DataModel.RowRegion | 'all'): void {\n    switch (region) {\n      case 'all':\n        this._rowSections.reset();\n        this._columnHeaderSections.reset();\n        break;\n      case 'body':\n        this._rowSections.reset();\n        break;\n      case 'column-header':\n        this._columnHeaderSections.reset();\n        break;\n      default:\n        throw 'unreachable';\n    }\n    this.repaintContent();\n    this.repaintOverlay();\n  }\n\n  /**\n   * Reset modified columns to their default size.\n   *\n   * @param region - The column region of interest.\n   */\n  resetColumns(region: DataModel.ColumnRegion | 'all'): void {\n    switch (region) {\n      case 'all':\n        this._columnSections.reset();\n        this._rowHeaderSections.reset();\n        break;\n      case 'body':\n        this._columnSections.reset();\n        break;\n      case 'row-header':\n        this._rowHeaderSections.reset();\n        break;\n      default:\n        throw 'unreachable';\n    }\n    this.repaintContent();\n    this.repaintOverlay();\n  }\n\n  /**\n   * Auto sizes column widths based on their text content.\n   * @param area which area to resize: 'body', 'row-header' or 'all'.\n   * @param padding padding added to resized columns (pixels).\n   * @param numCols specify cap on the number of column resizes (optional).\n   */\n  fitColumnNames(\n    area: DataGrid.ColumnFitType = 'all',\n    padding: number = 15,\n    numCols?: number\n  ): void {\n    // Attempt resizing only if a data model is present.\n    if (this.dataModel) {\n      // Tracking remaining columns to be resized if numCols arg passed.\n      let colsRemaining =\n        numCols === undefined || numCols < 0 ? undefined : numCols;\n\n      if (area === 'row-header' || area === 'all') {\n        // Respecting any column resize cap, if one has been passed.\n        if (colsRemaining !== undefined) {\n          const rowColumnCount = this.dataModel.columnCount('row-header');\n          /*\n            If we have more row-header columns than columns available\n            for resize, resize only remaining columns as per allowance\n            and set remaining resize allowance number to 0.\n          */\n          if (colsRemaining - rowColumnCount < 0) {\n            this._fitRowColumnHeaders(this.dataModel, padding, colsRemaining);\n            colsRemaining = 0;\n          } else {\n            /*\n              Otherwise the entire row-header column count can be resized.\n              Resize all row-header columns and subtract from remaining\n              column resize allowance.\n            */\n            this._fitRowColumnHeaders(this.dataModel, padding, rowColumnCount);\n            colsRemaining = colsRemaining - rowColumnCount;\n          }\n        } else {\n          // No column resize cap passed - resizing all columns.\n          this._fitRowColumnHeaders(this.dataModel, padding);\n        }\n      }\n\n      if (area === 'body' || area === 'all') {\n        // Respecting any column resize cap, if one has been passed.\n        if (colsRemaining !== undefined) {\n          const bodyColumnCount = this.dataModel.columnCount('body');\n          /*\n            If we have more body columns than columns available\n            for resize, resize only remaining columns as per allowance\n            and set remaining resize allowance number to 0.\n          */\n          if (colsRemaining - bodyColumnCount < 0) {\n            this._fitBodyColumnHeaders(this.dataModel, padding, colsRemaining);\n            colsRemaining = 0;\n          } else {\n            /*\n              Otherwise the entire body column count can be resized.\n              Resize based on the smallest number between remaining\n              resize allowance and body column count.\n            */\n            this._fitBodyColumnHeaders(\n              this.dataModel,\n              padding,\n              Math.min(colsRemaining, bodyColumnCount)\n            );\n          }\n        } else {\n          // No column resize cap passed - resizing all columns.\n          this._fitBodyColumnHeaders(this.dataModel, padding);\n        }\n      }\n    }\n  }\n\n  /**\n   * Map a client position to local viewport coordinates.\n   *\n   * @param clientX - The client X position of the mouse.\n   *\n   * @param clientY - The client Y position of the mouse.\n   *\n   * @returns The local viewport coordinates for the position.\n   */\n  mapToLocal(clientX: number, clientY: number): { lx: number; ly: number } {\n    // Fetch the viewport rect.\n    let rect = this._viewport.node.getBoundingClientRect();\n\n    // Extract the rect coordinates.\n    let { left, top } = rect;\n\n    // Round the rect coordinates for sub-pixel positioning.\n    left = Math.floor(left);\n    top = Math.floor(top);\n\n    // Convert to local coordinates.\n    let lx = clientX - left;\n    let ly = clientY - top;\n\n    // Return the local coordinates.\n    return { lx, ly };\n  }\n\n  /**\n   * Map a client position to virtual grid coordinates.\n   *\n   * @param clientX - The client X position of the mouse.\n   *\n   * @param clientY - The client Y position of the mouse.\n   *\n   * @returns The virtual grid coordinates for the position.\n   */\n  mapToVirtual(clientX: number, clientY: number): { vx: number; vy: number } {\n    // Convert to local coordiates.\n    let { lx, ly } = this.mapToLocal(clientX, clientY);\n\n    // Convert to virtual coordinates.\n    let vx = lx + this.scrollX - this.headerWidth;\n    let vy = ly + this.scrollY - this.headerHeight;\n\n    // Return the local coordinates.\n    return { vx, vy };\n  }\n\n  /**\n   * Hit test the viewport for the given client position.\n   *\n   * @param clientX - The client X position of the mouse.\n   *\n   * @param clientY - The client Y position of the mouse.\n   *\n   * @returns The hit test result, or `null` if the client\n   *   position is out of bounds.\n   *\n   * #### Notes\n   * This method accounts for a stretched last row and/or column.\n   */\n  hitTest(clientX: number, clientY: number): DataGrid.HitTestResult {\n    // Convert the mouse position into local coordinates.\n    let { lx, ly } = this.mapToLocal(clientX, clientY);\n\n    // Fetch the header and body dimensions.\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n    let pw = this.pageWidth;\n\n    // Adjust the body width for a stretched last column.\n    if (this._stretchLastColumn && pw > bw) {\n      bw = pw;\n    }\n\n    // Adjust the body height for a stretched last row.\n    if (this._stretchLastRow && ph > bh) {\n      bh = ph;\n    }\n\n    // Check for a corner header hit.\n    if (lx >= 0 && lx < hw && ly >= 0 && ly < hh) {\n      // Convert to unscrolled virtual coordinates.\n      let vx = lx;\n      let vy = ly;\n\n      // Fetch the row and column index.\n      let row = this.rowAt('column-header', vy);\n      let column = this.columnAt('row-header', vx);\n\n      // Fetch the cell offset position.\n      let ox = this.columnOffset('row-header', column);\n      let oy = this.rowOffset('column-header', row);\n\n      // Fetch cell width and height.\n      let width = this.columnSize('row-header', column);\n      let height = this.rowSize('column-header', row);\n\n      // Compute the leading and trailing positions.\n      let x = vx - ox;\n      let y = vy - oy;\n\n      // Return the hit test result.\n      return { region: 'corner-header', row, column, x, y, width, height };\n    }\n\n    // Check for a column header hit.\n    if (ly >= 0 && ly < hh && lx >= 0 && lx < hw + bw) {\n      // Convert to unscrolled virtual coordinates.\n      let vx = lx + this._scrollX - hw;\n      let vy = ly;\n\n      // Fetch the row and column index.\n      let row = this.rowAt('column-header', vy);\n      let column = this.columnAt('body', vx);\n\n      // Fetch the cell offset position.\n      let ox = this.columnOffset('body', column);\n      let oy = this.rowOffset('column-header', row);\n\n      // Fetch the cell width and height.\n      let width = this.columnSize('body', column);\n      let height = this.rowSize('column-header', row);\n\n      // Compute the leading and trailing positions.\n      let x = vx - ox;\n      let y = vy - oy;\n\n      // Return the hit test result.\n      return { region: 'column-header', row, column, x, y, width, height };\n    }\n\n    // Check for a row header hit.\n    if (lx >= 0 && lx < hw && ly >= 0 && ly < hh + bh) {\n      // Convert to unscrolled virtual coordinates.\n      let vx = lx;\n      let vy = ly + this._scrollY - hh;\n\n      // Fetch the row and column index.\n      let row = this.rowAt('body', vy);\n      let column = this.columnAt('row-header', vx);\n\n      // Fetch the cell offset position.\n      let ox = this.columnOffset('row-header', column);\n      let oy = this.rowOffset('body', row);\n\n      // Fetch the cell width and height.\n      let width = this.columnSize('row-header', column);\n      let height = this.rowSize('body', row);\n\n      // Compute the leading and trailing positions.\n      let x = vx - ox;\n      let y = vy - oy;\n\n      // Return the hit test result.\n      return { region: 'row-header', row, column, x, y, width, height };\n    }\n\n    // Check for a body hit.\n    if (lx >= hw && lx < hw + bw && ly >= hh && ly < hh + bh) {\n      // Convert to unscrolled virtual coordinates.\n      let vx = lx + this._scrollX - hw;\n      let vy = ly + this._scrollY - hh;\n\n      // Fetch the row and column index.\n      let row = this.rowAt('body', vy);\n      let column = this.columnAt('body', vx);\n\n      // Fetch the cell offset position.\n      let ox = this.columnOffset('body', column);\n      let oy = this.rowOffset('body', row);\n\n      // Fetch the cell width and height.\n      let width = this.columnSize('body', column);\n      let height = this.rowSize('body', row);\n\n      // Compute the part coordinates.\n      let x = vx - ox;\n      let y = vy - oy;\n\n      // Return the result.\n      return { region: 'body', row, column, x, y, width, height };\n    }\n\n    // Otherwise, it's a void space hit.\n    let row = -1;\n    let column = -1;\n    let x = -1;\n    let y = -1;\n    let width = -1;\n    let height = -1;\n\n    // Return the hit test result.\n    return { region: 'void', row, column, x, y, width, height };\n  }\n\n  /**\n   * Copy the current selection to the system clipboard.\n   *\n   * #### Notes\n   * The grid must have a data model and a selection model.\n   *\n   * The behavior can be configured via `DataGrid.copyConfig`.\n   */\n  copyToClipboard(): void {\n    // Fetch the data model.\n    let dataModel = this._dataModel;\n\n    // Bail early if there is no data model.\n    if (!dataModel) {\n      return;\n    }\n\n    // Fetch the selection model.\n    let selectionModel = this._selectionModel;\n\n    // Bail early if there is no selection model.\n    if (!selectionModel) {\n      return;\n    }\n\n    // Coerce the selections to an array.\n    let selections = toArray(selectionModel.selections());\n\n    // Bail early if there are no selections.\n    if (selections.length === 0) {\n      return;\n    }\n\n    // Alert that multiple selections cannot be copied.\n    if (selections.length > 1) {\n      alert('Cannot copy multiple grid selections.');\n      return;\n    }\n\n    // Fetch the model counts.\n    let br = dataModel.rowCount('body');\n    let bc = dataModel.columnCount('body');\n\n    // Bail early if there is nothing to copy.\n    if (br === 0 || bc === 0) {\n      return;\n    }\n\n    // Unpack the selection.\n    let { r1, c1, r2, c2 } = selections[0];\n\n    // Clamp the selection to the model bounds.\n    r1 = Math.max(0, Math.min(r1, br - 1));\n    c1 = Math.max(0, Math.min(c1, bc - 1));\n    r2 = Math.max(0, Math.min(r2, br - 1));\n    c2 = Math.max(0, Math.min(c2, bc - 1));\n\n    // Ensure the limits are well-orderd.\n    if (r2 < r1) [r1, r2] = [r2, r1];\n    if (c2 < c1) [c1, c2] = [c2, c1];\n\n    // Fetch the header counts.\n    let rhc = dataModel.columnCount('row-header');\n    let chr = dataModel.rowCount('column-header');\n\n    // Unpack the copy config.\n    let separator = this._copyConfig.separator;\n    let format = this._copyConfig.format;\n    let headers = this._copyConfig.headers;\n    let warningThreshold = this._copyConfig.warningThreshold;\n\n    // Compute the number of cells to be copied.\n    let rowCount = r2 - r1 + 1;\n    let colCount = c2 - c1 + 1;\n    switch (headers) {\n      case 'none':\n        rhc = 0;\n        chr = 0;\n        break;\n      case 'row':\n        chr = 0;\n        colCount += rhc;\n        break;\n      case 'column':\n        rhc = 0;\n        rowCount += chr;\n        break;\n      case 'all':\n        rowCount += chr;\n        colCount += rhc;\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Compute the total cell count.\n    let cellCount = rowCount * colCount;\n\n    // Allow the user to cancel a large copy request.\n    if (cellCount > warningThreshold) {\n      let msg = `Copying ${cellCount} cells may take a while. Continue?`;\n      if (!window.confirm(msg)) {\n        return;\n      }\n    }\n\n    // Set up the format args.\n    let args = {\n      region: 'body' as DataModel.CellRegion,\n      row: 0,\n      column: 0,\n      value: null as any,\n      metadata: {} as DataModel.Metadata\n    };\n\n    // Allocate the array of rows.\n    let rows = new Array<string[]>(rowCount);\n\n    // Iterate over the rows.\n    for (let j = 0; j < rowCount; ++j) {\n      // Allocate the array of cells.\n      let cells = new Array<string>(colCount);\n\n      // Iterate over the columns.\n      for (let i = 0; i < colCount; ++i) {\n        // Set up the format variables.\n        let region: DataModel.CellRegion;\n        let row: number;\n        let column: number;\n\n        // Populate the format variables.\n        if (j < chr && i < rhc) {\n          region = 'corner-header';\n          row = j;\n          column = i;\n        } else if (j < chr) {\n          region = 'column-header';\n          row = j;\n          column = i - rhc + c1;\n        } else if (i < rhc) {\n          region = 'row-header';\n          row = j - chr + r1;\n          column = i;\n        } else {\n          region = 'body';\n          row = j - chr + r1;\n          column = i - rhc + c1;\n        }\n\n        // Populate the format args.\n        args.region = region;\n        args.row = row;\n        args.column = column;\n        args.value = dataModel.data(region, row, column);\n        args.metadata = dataModel.metadata(region, row, column);\n\n        // Format the cell.\n        cells[i] = format(args);\n      }\n\n      // Save the row of cells.\n      rows[j] = cells;\n    }\n\n    // Convert the cells into lines.\n    let lines = rows.map(cells => cells.join(separator));\n\n    // Convert the lines into text.\n    let text = lines.join('\\n');\n\n    // Copy the text to the clipboard.\n    ClipboardExt.copyText(text);\n  }\n\n  /**\n   * Process a message sent to the widget.\n   *\n   * @param msg - The message sent to the widget.\n   */\n  processMessage(msg: Message): void {\n    // Ignore child show/hide messages. The data grid controls the\n    // visibility of its children, and will manually dispatch the\n    // fit-request messages as a result of visibility change.\n    if (msg.type === 'child-shown' || msg.type === 'child-hidden') {\n      return;\n    }\n\n    // Recompute the scroll bar minimums before the layout refits.\n    if (msg.type === 'fit-request') {\n      let vsbLimits = ElementExt.sizeLimits(this._vScrollBar.node);\n      let hsbLimits = ElementExt.sizeLimits(this._hScrollBar.node);\n      this._vScrollBarMinWidth = vsbLimits.minWidth;\n      this._hScrollBarMinHeight = hsbLimits.minHeight;\n    }\n\n    // Process all other messages as normal.\n    super.processMessage(msg);\n  }\n\n  /**\n   * Intercept a message sent to a message handler.\n   *\n   * @param handler - The target handler of the message.\n   *\n   * @param msg - The message to be sent to the handler.\n   *\n   * @returns `true` if the message should continue to be processed\n   *   as normal, or `false` if processing should cease immediately.\n   */\n  messageHook(handler: IMessageHandler, msg: Message): boolean {\n    // Process viewport messages.\n    if (handler === this._viewport) {\n      this._processViewportMessage(msg);\n      return true;\n    }\n\n    // Process horizontal scroll bar messages.\n    if (handler === this._hScrollBar && msg.type === 'activate-request') {\n      this.activate();\n      return false;\n    }\n\n    // Process vertical scroll bar messages.\n    if (handler === this._vScrollBar && msg.type === 'activate-request') {\n      this.activate();\n      return false;\n    }\n\n    // Ignore all other messages.\n    return true;\n  }\n\n  /**\n   * Handle the DOM events for the data grid.\n   *\n   * @param event - The DOM event sent to the data grid.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events on the data grid's DOM node. It\n   * should not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._evtKeyDown(event as KeyboardEvent);\n        break;\n      case 'mousedown':\n        this._evtMouseDown(event as MouseEvent);\n        break;\n      case 'mousemove':\n        this._evtMouseMove(event as MouseEvent);\n        break;\n      case 'mouseup':\n        this._evtMouseUp(event as MouseEvent);\n        break;\n      case 'dblclick':\n        this._evtMouseDoubleClick(event as MouseEvent);\n        break;\n      case 'mouseleave':\n        this._evtMouseLeave(event as MouseEvent);\n        break;\n      case 'contextmenu':\n        this._evtContextMenu(event as MouseEvent);\n        break;\n      case 'wheel':\n        this._evtWheel(event as WheelEvent);\n        break;\n      case 'resize':\n        this._refreshDPI();\n        break;\n    }\n  }\n\n  /**\n   * A message handler invoked on an `'activate-request'` message.\n   */\n  protected onActivateRequest(msg: Message): void {\n    this.viewport.node.focus({ preventScroll: true });\n  }\n\n  /**\n   * A message handler invoked on a `'before-attach'` message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    window.addEventListener('resize', this);\n    this.node.addEventListener('wheel', this);\n    this._viewport.node.addEventListener('keydown', this);\n    this._viewport.node.addEventListener('mousedown', this);\n    this._viewport.node.addEventListener('mousemove', this);\n    this._viewport.node.addEventListener('dblclick', this);\n    this._viewport.node.addEventListener('mouseleave', this);\n    this._viewport.node.addEventListener('contextmenu', this);\n    this.repaintContent();\n    this.repaintOverlay();\n  }\n\n  /**\n   * A message handler invoked on an `'after-detach'` message.\n   */\n  protected onAfterDetach(msg: Message): void {\n    window.removeEventListener('resize', this);\n    this.node.removeEventListener('wheel', this);\n    this._viewport.node.removeEventListener('keydown', this);\n    this._viewport.node.removeEventListener('mousedown', this);\n    this._viewport.node.removeEventListener('mousemove', this);\n    this._viewport.node.removeEventListener('mouseleave', this);\n    this._viewport.node.removeEventListener('dblclick', this);\n    this._viewport.node.removeEventListener('contextmenu', this);\n    this._releaseMouse();\n  }\n\n  /**\n   * A message handler invoked on a `'before-show'` message.\n   */\n  protected onBeforeShow(msg: Message): void {\n    this.repaintContent();\n    this.repaintOverlay();\n  }\n\n  /**\n   * A message handler invoked on a `'resize'` message.\n   */\n  protected onResize(msg: Widget.ResizeMessage): void {\n    if (this._editorController) {\n      this._editorController.cancel();\n    }\n\n    this._syncScrollState();\n  }\n\n  /**\n   * Schedule a repaint of all of the grid content.\n   */\n  protected repaintContent(): void {\n    let msg = new Private.PaintRequest('all', 0, 0, 0, 0);\n    MessageLoop.postMessage(this._viewport, msg);\n  }\n\n  /**\n   * Schedule a repaint of specific grid content.\n   */\n  protected repaintRegion(\n    region: DataModel.CellRegion,\n    r1: number,\n    c1: number,\n    r2: number,\n    c2: number\n  ): void {\n    let msg = new Private.PaintRequest(region, r1, c1, r2, c2);\n    MessageLoop.postMessage(this._viewport, msg);\n  }\n\n  /**\n   * Schedule a repaint of the overlay.\n   */\n  protected repaintOverlay(): void {\n    MessageLoop.postMessage(this._viewport, Private.OverlayPaintRequest);\n  }\n\n  /**\n   * Ensure the canvas is at least the specified size.\n   *\n   * This method will retain the valid canvas content.\n   */\n  private _resizeCanvasIfNeeded(width: number, height: number): void {\n    // Scale the size by the dpi ratio.\n    width = width * this._dpiRatio;\n    height = height * this._dpiRatio;\n\n    // Compute the maximum canvas size for the given width and height.\n    let maxW = (Math.ceil((width + 1) / 512) + 1) * 512;\n    let maxH = (Math.ceil((height + 1) / 512) + 1) * 512;\n\n    // Get the current size of the canvas.\n    let curW = this._canvas.width;\n    let curH = this._canvas.height;\n\n    // Bail early if the canvas size is within bounds.\n    if (curW >= width && curH >= height && curW <= maxW && curH <= maxH) {\n      return;\n    }\n\n    // Compute the expanded canvas size.\n    let expW = maxW - 512;\n    let expH = maxH - 512;\n\n    // Set the transforms to the identity matrix.\n    this._canvasGC.setTransform(1, 0, 0, 1, 0, 0);\n    this._bufferGC.setTransform(1, 0, 0, 1, 0, 0);\n    this._overlayGC.setTransform(1, 0, 0, 1, 0, 0);\n\n    // Resize the buffer if needed.\n    if (curW < width) {\n      this._buffer.width = expW;\n    } else if (curW > maxW) {\n      this._buffer.width = maxW;\n    }\n\n    // Resize the buffer height if needed.\n    if (curH < height) {\n      this._buffer.height = expH;\n    } else if (curH > maxH) {\n      this._buffer.height = maxH;\n    }\n\n    // Test whether there is content to blit.\n    let needBlit = curH > 0 && curH > 0 && width > 0 && height > 0;\n\n    // Copy the valid canvas content into the buffer if needed.\n    if (needBlit) {\n      this._bufferGC.drawImage(this._canvas, 0, 0);\n    }\n\n    // Resize the canvas width if needed.\n    if (curW < width) {\n      this._canvas.width = expW;\n      this._canvas.style.width = `${expW / this._dpiRatio}px`;\n    } else if (curW > maxW) {\n      this._canvas.width = maxW;\n      this._canvas.style.width = `${maxW / this._dpiRatio}px`;\n    }\n\n    // Resize the canvas height if needed.\n    if (curH < height) {\n      this._canvas.height = expH;\n      this._canvas.style.height = `${expH / this._dpiRatio}px`;\n    } else if (curH > maxH) {\n      this._canvas.height = maxH;\n      this._canvas.style.height = `${maxH / this._dpiRatio}px`;\n    }\n\n    // Copy the valid canvas content from the buffer if needed.\n    if (needBlit) {\n      this._canvasGC.drawImage(this._buffer, 0, 0);\n    }\n\n    // Copy the valid overlay content into the buffer if needed.\n    if (needBlit) {\n      this._bufferGC.drawImage(this._overlay, 0, 0);\n    }\n\n    // Resize the overlay width if needed.\n    if (curW < width) {\n      this._overlay.width = expW;\n      this._overlay.style.width = `${expW / this._dpiRatio}px`;\n    } else if (curW > maxW) {\n      this._overlay.width = maxW;\n      this._overlay.style.width = `${maxW / this._dpiRatio}px`;\n    }\n\n    // Resize the overlay height if needed.\n    if (curH < height) {\n      this._overlay.height = expH;\n      this._overlay.style.height = `${expH / this._dpiRatio}px`;\n    } else if (curH > maxH) {\n      this._overlay.height = maxH;\n      this._overlay.style.height = `${maxH / this._dpiRatio}px`;\n    }\n\n    // Copy the valid overlay content from the buffer if needed.\n    if (needBlit) {\n      this._overlayGC.drawImage(this._buffer, 0, 0);\n    }\n  }\n\n  /**\n   * Sync the scroll bars and scroll state with the viewport.\n   *\n   * #### Notes\n   * If the visibility of either scroll bar changes, a synchronous\n   * fit-request will be dispatched to the data grid to immediately\n   * resize the viewport.\n   */\n  private _syncScrollState(): void {\n    // Fetch the viewport dimensions.\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n    let pw = this.pageWidth;\n    let ph = this.pageHeight;\n\n    // Get the current scroll bar visibility.\n    let hasVScroll = !this._vScrollBar.isHidden;\n    let hasHScroll = !this._hScrollBar.isHidden;\n\n    // Get the minimum sizes of the scroll bars.\n    let vsw = this._vScrollBarMinWidth;\n    let hsh = this._hScrollBarMinHeight;\n\n    // Get the page size as if no scroll bars are visible.\n    let apw = pw + (hasVScroll ? vsw : 0);\n    let aph = ph + (hasHScroll ? hsh : 0);\n\n    // Test whether scroll bars are needed for the adjusted size.\n    let needVScroll = aph < bh - 1;\n    let needHScroll = apw < bw - 1;\n\n    // Re-test the horizontal scroll if a vertical scroll is needed.\n    if (needVScroll && !needHScroll) {\n      needHScroll = apw - vsw < bw - 1;\n    }\n\n    // Re-test the vertical scroll if a horizontal scroll is needed.\n    if (needHScroll && !needVScroll) {\n      needVScroll = aph - hsh < bh - 1;\n    }\n\n    // If the visibility changes, immediately refit the grid.\n    if (needVScroll !== hasVScroll || needHScroll !== hasHScroll) {\n      this._vScrollBar.setHidden(!needVScroll);\n      this._hScrollBar.setHidden(!needHScroll);\n      this._scrollCorner.setHidden(!needVScroll || !needHScroll);\n      MessageLoop.sendMessage(this, Widget.Msg.FitRequest);\n    }\n\n    // Update the scroll bar limits.\n    this._vScrollBar.maximum = this.maxScrollY;\n    this._vScrollBar.page = this.pageHeight;\n    this._hScrollBar.maximum = this.maxScrollX;\n    this._hScrollBar.page = this.pageWidth;\n\n    // Re-clamp the scroll position.\n    this._scrollTo(this._scrollX, this._scrollY);\n  }\n\n  /**\n   * Sync the viewport to the given scroll position.\n   *\n   * #### Notes\n   * This schedules a full repaint and syncs the scroll state.\n   */\n  private _syncViewport(): void {\n    this.repaintContent();\n    this.repaintOverlay();\n    this._syncScrollState();\n  }\n\n  /**\n   * Process a message sent to the viewport\n   */\n  private _processViewportMessage(msg: Message): void {\n    switch (msg.type) {\n      case 'resize':\n        this._onViewportResize(msg as Widget.ResizeMessage);\n        break;\n      case 'scroll-request':\n        this._onViewportScrollRequest(msg);\n        break;\n      case 'paint-request':\n        this._onViewportPaintRequest(msg as Private.PaintRequest);\n        break;\n      case 'overlay-paint-request':\n        this._onViewportOverlayPaintRequest(msg);\n        break;\n      case 'row-resize-request':\n        this._onViewportRowResizeRequest(msg as Private.RowResizeRequest);\n        break;\n      case 'column-resize-request':\n        this._onViewportColumnResizeRequest(msg as Private.ColumnResizeRequest);\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * A message hook invoked on a viewport `'resize'` message.\n   */\n  private _onViewportResize(msg: Widget.ResizeMessage): void {\n    // Bail early if the viewport is not visible.\n    if (!this._viewport.isVisible) {\n      return;\n    }\n\n    // Unpack the message data.\n    let { width, height } = msg;\n\n    // Measure the viewport node if the dimensions are unknown.\n    if (width === -1) {\n      width = this._viewport.node.offsetWidth;\n    }\n    if (height === -1) {\n      height = this._viewport.node.offsetHeight;\n    }\n\n    // Round the dimensions to the nearest pixel.\n    width = Math.round(width);\n    height = Math.round(height);\n\n    // Get the current size of the viewport.\n    let oldWidth = this._viewportWidth;\n    let oldHeight = this._viewportHeight;\n\n    // Updated internal viewport size.\n    this._viewportWidth = width;\n    this._viewportHeight = height;\n\n    // Resize the canvas if needed.\n    this._resizeCanvasIfNeeded(width, height);\n\n    // Bail early if there is nothing to paint.\n    if (width === 0 || height === 0) {\n      return;\n    }\n\n    // Paint the whole grid if the old size was zero.\n    if (oldWidth === 0 || oldHeight === 0) {\n      this.paintContent(0, 0, width, height);\n      this._paintOverlay();\n      return;\n    }\n\n    // Paint the right edge as needed.\n    if (this._stretchLastColumn && this.pageWidth > this.bodyWidth) {\n      let bx = this._columnSections.offsetOf(this._columnSections.count - 1);\n      let x = Math.min(this.headerWidth + bx, oldWidth);\n      this.paintContent(x, 0, width - x, height);\n    } else if (width > oldWidth) {\n      this.paintContent(oldWidth, 0, width - oldWidth + 1, height);\n    }\n\n    // Paint the bottom edge as needed.\n    if (this._stretchLastRow && this.pageHeight > this.bodyHeight) {\n      let by = this._rowSections.offsetOf(this._rowSections.count - 1);\n      let y = Math.min(this.headerHeight + by, oldHeight);\n      this.paintContent(0, y, width, height - y);\n    } else if (height > oldHeight) {\n      this.paintContent(0, oldHeight, width, height - oldHeight + 1);\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n  }\n\n  /**\n   * A message hook invoked on a viewport `'scroll-request'` message.\n   */\n  private _onViewportScrollRequest(msg: Message): void {\n    this._scrollTo(this._hScrollBar.value, this._vScrollBar.value);\n  }\n\n  /**\n   * A message hook invoked on a viewport `'paint-request'` message.\n   */\n  private _onViewportPaintRequest(msg: Private.PaintRequest): void {\n    // Bail early if the viewport is not visible.\n    if (!this._viewport.isVisible) {\n      return;\n    }\n\n    // Bail early if the viewport has zero area.\n    if (this._viewportWidth === 0 || this._viewportHeight === 0) {\n      return;\n    }\n\n    // Set up the paint limits.\n    let xMin = 0;\n    let yMin = 0;\n    let xMax = this._viewportWidth - 1;\n    let yMax = this._viewportHeight - 1;\n\n    // Fetch the scroll position.\n    let sx = this._scrollX;\n    let sy = this._scrollY;\n\n    // Fetch the header dimensions.\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n\n    // Fetch the section lists.\n    let rs = this._rowSections;\n    let cs = this._columnSections;\n    let rhs = this._rowHeaderSections;\n    let chs = this._columnHeaderSections;\n\n    // Unpack the message data.\n    let { region, r1, c1, r2, c2 } = msg;\n\n    // Set up the paint variables.\n    let x1: number;\n    let y1: number;\n    let x2: number;\n    let y2: number;\n\n    // Fill the paint variables based on the paint region.\n    switch (region) {\n      case 'all':\n        x1 = xMin;\n        y1 = yMin;\n        x2 = xMax;\n        y2 = yMax;\n        break;\n      case 'body':\n        r1 = Math.max(0, Math.min(r1, rs.count));\n        c1 = Math.max(0, Math.min(c1, cs.count));\n        r2 = Math.max(0, Math.min(r2, rs.count));\n        c2 = Math.max(0, Math.min(c2, cs.count));\n        x1 = cs.offsetOf(c1) - sx + hw;\n        y1 = rs.offsetOf(r1) - sy + hh;\n        x2 = cs.extentOf(c2) - sx + hw;\n        y2 = rs.extentOf(r2) - sy + hh;\n        break;\n      case 'row-header':\n        r1 = Math.max(0, Math.min(r1, rs.count));\n        c1 = Math.max(0, Math.min(c1, rhs.count));\n        r2 = Math.max(0, Math.min(r2, rs.count));\n        c2 = Math.max(0, Math.min(c2, rhs.count));\n        x1 = rhs.offsetOf(c1);\n        y1 = rs.offsetOf(r1) - sy + hh;\n        x2 = rhs.extentOf(c2);\n        y2 = rs.extentOf(r2) - sy + hh;\n        break;\n      case 'column-header':\n        r1 = Math.max(0, Math.min(r1, chs.count));\n        c1 = Math.max(0, Math.min(c1, cs.count));\n        r2 = Math.max(0, Math.min(r2, chs.count));\n        c2 = Math.max(0, Math.min(c2, cs.count));\n        x1 = cs.offsetOf(c1) - sx + hw;\n        y1 = chs.offsetOf(r1);\n        x2 = cs.extentOf(c2) - sx + hw;\n        y2 = chs.extentOf(r2);\n        break;\n      case 'corner-header':\n        r1 = Math.max(0, Math.min(r1, chs.count));\n        c1 = Math.max(0, Math.min(c1, rhs.count));\n        r2 = Math.max(0, Math.min(r2, chs.count));\n        c2 = Math.max(0, Math.min(c2, rhs.count));\n        x1 = rhs.offsetOf(c1);\n        y1 = chs.offsetOf(r1);\n        x2 = rhs.extentOf(c2);\n        y2 = chs.extentOf(r2);\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Bail early if the dirty rect is outside the bounds.\n    if (x2 < xMin || y2 < yMin || x1 > xMax || y1 > yMax) {\n      return;\n    }\n\n    // Clamp the dirty rect to the paint bounds.\n    x1 = Math.max(xMin, Math.min(x1, xMax));\n    y1 = Math.max(yMin, Math.min(y1, yMax));\n    x2 = Math.max(xMin, Math.min(x2, xMax));\n    y2 = Math.max(yMin, Math.min(y2, yMax));\n\n    // Paint the content of the dirty rect.\n    this.paintContent(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n  }\n\n  /**\n   * A message hook invoked on a viewport `'overlay-paint-request'` message.\n   */\n  private _onViewportOverlayPaintRequest(msg: Message): void {\n    // Bail early if the viewport is not visible.\n    if (!this._viewport.isVisible) {\n      return;\n    }\n\n    // Bail early if the viewport has zero area.\n    if (this._viewportWidth === 0 || this._viewportHeight === 0) {\n      return;\n    }\n\n    // Paint the content of the overlay.\n    this._paintOverlay();\n  }\n\n  /**\n   * A message hook invoked on a viewport `'row-resize-request'` message.\n   */\n  private _onViewportRowResizeRequest(msg: Private.RowResizeRequest): void {\n    if (msg.region === 'body') {\n      this._resizeRow(msg.index, msg.size);\n    } else {\n      this._resizeColumnHeader(msg.index, msg.size);\n    }\n  }\n\n  /**\n   * A message hook invoked on a viewport `'column-resize-request'` message.\n   */\n  private _onViewportColumnResizeRequest(\n    msg: Private.ColumnResizeRequest\n  ): void {\n    if (msg.region === 'body') {\n      this._resizeColumn(msg.index, msg.size);\n    } else {\n      this._resizeRowHeader(msg.index, msg.size);\n    }\n  }\n\n  /**\n   * Handle the `thumbMoved` signal from a scroll bar.\n   */\n  private _onThumbMoved(sender: ScrollBar): void {\n    MessageLoop.postMessage(this._viewport, Private.ScrollRequest);\n  }\n\n  /**\n   * Handle the `pageRequested` signal from a scroll bar.\n   */\n  private _onPageRequested(\n    sender: ScrollBar,\n    dir: 'decrement' | 'increment'\n  ): void {\n    if (sender === this._vScrollBar) {\n      this.scrollByPage(dir === 'decrement' ? 'up' : 'down');\n    } else {\n      this.scrollByPage(dir === 'decrement' ? 'left' : 'right');\n    }\n  }\n\n  /**\n   * Handle the `stepRequested` signal from a scroll bar.\n   */\n  private _onStepRequested(\n    sender: ScrollBar,\n    dir: 'decrement' | 'increment'\n  ): void {\n    if (sender === this._vScrollBar) {\n      this.scrollByStep(dir === 'decrement' ? 'up' : 'down');\n    } else {\n      this.scrollByStep(dir === 'decrement' ? 'left' : 'right');\n    }\n  }\n\n  /**\n   * A signal handler for the data model `changed` signal.\n   */\n  private _onDataModelChanged(\n    sender: DataModel,\n    args: DataModel.ChangedArgs\n  ): void {\n    switch (args.type) {\n      case 'rows-inserted':\n        this._onRowsInserted(args);\n        break;\n      case 'columns-inserted':\n        this._onColumnsInserted(args);\n        break;\n      case 'rows-removed':\n        this._onRowsRemoved(args);\n        break;\n      case 'columns-removed':\n        this._onColumnsRemoved(args);\n        break;\n      case 'rows-moved':\n        this._onRowsMoved(args);\n        break;\n      case 'columns-moved':\n        this._onColumnsMoved(args);\n        break;\n      case 'cells-changed':\n        this._onCellsChanged(args);\n        break;\n      case 'model-reset':\n        this._onModelReset(args);\n        break;\n      default:\n        throw 'unreachable';\n    }\n  }\n\n  /**\n   * A signal handler for the selection model `changed` signal.\n   */\n  private _onSelectionsChanged(sender: SelectionModel): void {\n    this.repaintOverlay();\n  }\n\n  /**\n   * Handle rows being inserted in the data model.\n   */\n  private _onRowsInserted(args: DataModel.RowsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span } = args;\n\n    // Bail early if there are no sections to insert.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._rowSections;\n    } else {\n      list = this._columnHeaderSections;\n    }\n\n    // Insert the span, maintaining the scroll position as needed.\n    if (this._scrollY === this.maxScrollY && this.maxScrollY > 0) {\n      list.insert(index, span);\n      this._scrollY = this.maxScrollY;\n    } else {\n      list.insert(index, span);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle columns being inserted into the data model.\n   */\n  private _onColumnsInserted(args: DataModel.ColumnsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span } = args;\n\n    // Bail early if there are no sections to insert.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._columnSections;\n    } else {\n      list = this._rowHeaderSections;\n    }\n\n    // Insert the span, maintaining the scroll position as needed.\n    if (this._scrollX === this.maxScrollX && this.maxScrollX > 0) {\n      list.insert(index, span);\n      this._scrollX = this.maxScrollX;\n    } else {\n      list.insert(index, span);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle rows being removed from the data model.\n   */\n  private _onRowsRemoved(args: DataModel.RowsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span } = args;\n\n    // Bail early if there are no sections to remove.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._rowSections;\n    } else {\n      list = this._columnHeaderSections;\n    }\n\n    // Bail if the index or is invalid\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Remove the span, maintaining the scroll position as needed.\n    if (this._scrollY === this.maxScrollY && this.maxScrollY > 0) {\n      list.remove(index, span);\n      this._scrollY = this.maxScrollY;\n    } else {\n      list.remove(index, span);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle columns being removed from the data model.\n   */\n  private _onColumnsRemoved(args: DataModel.ColumnsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span } = args;\n\n    // Bail early if there are no sections to remove.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._columnSections;\n    } else {\n      list = this._rowHeaderSections;\n    }\n\n    // Bail if the index or is invalid\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Remove the span, maintaining the scroll position as needed.\n    if (this._scrollX === this.maxScrollX && this.maxScrollX > 0) {\n      list.remove(index, span);\n      this._scrollX = this.maxScrollX;\n    } else {\n      list.remove(index, span);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle rows moving in the data model.\n   */\n  private _onRowsMoved(args: DataModel.RowsMovedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span, destination } = args;\n\n    // Bail early if there are no sections to move.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._rowSections;\n    } else {\n      list = this._columnHeaderSections;\n    }\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Clamp the move span to the limit.\n    span = Math.min(span, list.count - index);\n\n    // Clamp the destination index to the limit.\n    destination = Math.min(Math.max(0, destination), list.count - span);\n\n    // Bail early if there is no effective move.\n    if (index === destination) {\n      return;\n    }\n\n    // Compute the first affected index.\n    let r1 = Math.min(index, destination);\n\n    // Compute the last affected index.\n    let r2 = Math.max(index + span - 1, destination + span - 1);\n\n    // Move the sections in the list.\n    list.move(index, span, destination);\n\n    // Schedule a repaint of the dirty cells.\n    if (region === 'body') {\n      this.repaintRegion('body', r1, 0, r2, Infinity);\n      this.repaintRegion('row-header', r1, 0, r2, Infinity);\n    } else {\n      this.repaintRegion('column-header', r1, 0, r2, Infinity);\n      this.repaintRegion('corner-header', r1, 0, r2, Infinity);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle columns moving in the data model.\n   */\n  private _onColumnsMoved(args: DataModel.ColumnsMovedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span, destination } = args;\n\n    // Bail early if there are no sections to move.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._columnSections;\n    } else {\n      list = this._rowHeaderSections;\n    }\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Clamp the move span to the limit.\n    span = Math.min(span, list.count - index);\n\n    // Clamp the destination index to the limit.\n    destination = Math.min(Math.max(0, destination), list.count - span);\n\n    // Bail early if there is no effective move.\n    if (index === destination) {\n      return;\n    }\n\n    // Move the sections in the list.\n    list.move(index, span, destination);\n\n    // Compute the first affected index.\n    let c1 = Math.min(index, destination);\n\n    // Compute the last affected index.\n    let c2 = Math.max(index + span - 1, destination + span - 1);\n\n    // Schedule a repaint of the dirty cells.\n    if (region === 'body') {\n      this.repaintRegion('body', 0, c1, Infinity, c2);\n      this.repaintRegion('column-header', 0, c1, Infinity, c2);\n    } else {\n      this.repaintRegion('row-header', 0, c1, Infinity, c2);\n      this.repaintRegion('corner-header', 0, c1, Infinity, c2);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle cells changing in the data model.\n   */\n  private _onCellsChanged(args: DataModel.CellsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, row, column, rowSpan, columnSpan } = args;\n\n    // Bail early if there are no cells to modify.\n    if (rowSpan <= 0 && columnSpan <= 0) {\n      return;\n    }\n\n    // Compute the changed cell bounds.\n    let r1 = row;\n    let c1 = column;\n    let r2 = r1 + rowSpan - 1;\n    let c2 = c1 + columnSpan - 1;\n\n    // Schedule a repaint of the cell content.\n    this.repaintRegion(region, r1, c1, r2, c2);\n  }\n\n  /**\n   * Handle a full data model reset.\n   */\n  private _onModelReset(args: DataModel.ModelResetArgs): void {\n    // Look up the various current section counts.\n    let nr = this._rowSections.count;\n    let nc = this._columnSections.count;\n    let nrh = this._rowHeaderSections.count;\n    let nch = this._columnHeaderSections.count;\n\n    // Compute the delta count for each region.\n    let dr = this._dataModel!.rowCount('body') - nr;\n    let dc = this._dataModel!.columnCount('body') - nc;\n    let drh = this._dataModel!.columnCount('row-header') - nrh;\n    let dch = this._dataModel!.rowCount('column-header') - nch;\n\n    // Update the row sections, if needed.\n    if (dr > 0) {\n      this._rowSections.insert(nr, dr);\n    } else if (dr < 0) {\n      this._rowSections.remove(nr + dr, -dr);\n    }\n\n    // Update the column sections, if needed.\n    if (dc > 0) {\n      this._columnSections.insert(nc, dc);\n    } else if (dc < 0) {\n      this._columnSections.remove(nc + dc, -dc);\n    }\n\n    // Update the row header sections, if needed.\n    if (drh > 0) {\n      this._rowHeaderSections.insert(nrh, drh);\n    } else if (drh < 0) {\n      this._rowHeaderSections.remove(nrh + drh, -drh);\n    }\n\n    // Update the column header sections, if needed.\n    if (dch > 0) {\n      this._columnHeaderSections.insert(nch, dch);\n    } else if (dch < 0) {\n      this._columnHeaderSections.remove(nch + dch, -dch);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * A signal handler for the renderer map `changed` signal.\n   */\n  private _onRenderersChanged(): void {\n    this.repaintContent();\n  }\n\n  /**\n   * Handle the `'keydown'` event for the data grid.\n   */\n  private _evtKeyDown(event: KeyboardEvent): void {\n    if (this._mousedown) {\n      event.preventDefault();\n      event.stopPropagation();\n    } else if (this._keyHandler) {\n      this._keyHandler.onKeyDown(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'mousedown'` event for the data grid.\n   */\n  private _evtMouseDown(event: MouseEvent): void {\n    // Ignore everything except the left mouse button.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Activate the grid.\n    this.activate();\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Add the extra document listeners.\n    document.addEventListener('keydown', this, true);\n    document.addEventListener('mouseup', this, true);\n    document.addEventListener('mousedown', this, true);\n    document.addEventListener('mousemove', this, true);\n    document.addEventListener('contextmenu', this, true);\n\n    // Flip the mousedown flag.\n    this._mousedown = true;\n\n    // Dispatch to the mouse handler.\n    if (this._mouseHandler) {\n      this._mouseHandler.onMouseDown(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'mousemove'` event for the data grid.\n   */\n  private _evtMouseMove(event: MouseEvent): void {\n    // Stop the event propagation if the mouse is down.\n    if (this._mousedown) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    // Bail if there is no mouse handler.\n    if (!this._mouseHandler) {\n      return;\n    }\n\n    // Dispatch to the mouse handler.\n    if (this._mousedown) {\n      this._mouseHandler.onMouseMove(this, event);\n    } else {\n      this._mouseHandler.onMouseHover(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'mouseup'` event for the data grid.\n   */\n  private _evtMouseUp(event: MouseEvent): void {\n    // Ignore everything except the left mouse button.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Dispatch to the mouse handler.\n    if (this._mouseHandler) {\n      this._mouseHandler.onMouseUp(this, event);\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n  }\n\n  /**\n   * Handle the `'dblclick'` event for the data grid.\n   */\n  private _evtMouseDoubleClick(event: MouseEvent): void {\n    // Ignore everything except the left mouse button.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Dispatch to the mouse handler.\n    if (this._mouseHandler) {\n      this._mouseHandler.onMouseDoubleClick(this, event);\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n  }\n\n  /**\n   * Handle the `'mouseleave'` event for the data grid.\n   */\n  private _evtMouseLeave(event: MouseEvent): void {\n    if (this._mousedown) {\n      event.preventDefault();\n      event.stopPropagation();\n    } else if (this._mouseHandler) {\n      this._mouseHandler.onMouseLeave(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'contextmenu'` event for the data grid.\n   */\n  private _evtContextMenu(event: MouseEvent): void {\n    if (this._mousedown) {\n      event.preventDefault();\n      event.stopPropagation();\n    } else if (this._mouseHandler) {\n      this._mouseHandler.onContextMenu(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'wheel'` event for the data grid.\n   */\n  private _evtWheel(event: WheelEvent): void {\n    // Ignore the event if `accel` is held.\n    if (Platform.accelKey(event)) {\n      return;\n    }\n\n    // Bail early if there is no mouse handler.\n    if (!this._mouseHandler) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Dispatch to the mouse handler.\n    this._mouseHandler.onWheel(this, event);\n  }\n\n  /**\n   * Release the mouse grab.\n   */\n  private _releaseMouse(): void {\n    // Clear the mousedown flag.\n    this._mousedown = false;\n\n    // Relase the mouse handler.\n    if (this._mouseHandler) {\n      this._mouseHandler.release();\n    }\n\n    // Remove the document listeners.\n    document.removeEventListener('keydown', this, true);\n    document.removeEventListener('mouseup', this, true);\n    document.removeEventListener('mousedown', this, true);\n    document.removeEventListener('mousemove', this, true);\n    document.removeEventListener('contextmenu', this, true);\n  }\n\n  /**\n   * Refresh the dpi ratio.\n   */\n  private _refreshDPI(): void {\n    // Get the best integral value for the dpi ratio.\n    let dpiRatio = Math.ceil(window.devicePixelRatio);\n\n    // Bail early if the computed dpi ratio has not changed.\n    if (this._dpiRatio === dpiRatio) {\n      return;\n    }\n\n    // Update the internal dpi ratio.\n    this._dpiRatio = dpiRatio;\n\n    // Schedule a repaint of the content.\n    this.repaintContent();\n\n    // Schedule a repaint of the overlay.\n    this.repaintOverlay();\n\n    // Update the canvas size for the new dpi ratio.\n    this._resizeCanvasIfNeeded(this._viewportWidth, this._viewportHeight);\n\n    // Ensure the canvas style is scaled for the new ratio.\n    this._canvas.style.width = `${this._canvas.width / this._dpiRatio}px`;\n    this._canvas.style.height = `${this._canvas.height / this._dpiRatio}px`;\n\n    // Ensure the overlay style is scaled for the new ratio.\n    this._overlay.style.width = `${this._overlay.width / this._dpiRatio}px`;\n    this._overlay.style.height = `${this._overlay.height / this._dpiRatio}px`;\n  }\n\n  /**\n   * Resize a row section immediately.\n   */\n  private _resizeRow(index: number, size: number): void {\n    // Look up the target section list.\n    let list = this._rowSections;\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Look up the old size of the section.\n    let oldSize = list.sizeOf(index);\n\n    // Normalize the new size of the section.\n    let newSize = list.clampSize(size);\n\n    // Bail early if the size does not change.\n    if (oldSize === newSize) {\n      return;\n    }\n\n    // Resize the section in the list.\n    list.resize(index, newSize);\n\n    // Get the current size of the viewport.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // If there is nothing to paint, sync the scroll state.\n    if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Render entire grid if scrolling merged cells grid\n    const paintEverything = Private.shouldPaintEverything(this._dataModel!);\n\n    if (paintEverything) {\n      this.paintContent(0, 0, vw, vh);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the size delta.\n    let delta = newSize - oldSize;\n\n    // Look up the column header height.\n    let hh = this.headerHeight;\n\n    // Compute the viewport offset of the section.\n    let offset = list.offsetOf(index) + hh - this._scrollY;\n\n    // Bail early if there is nothing to paint.\n    if (hh >= vh || offset >= vh) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Update the scroll position if the section is not visible.\n    if (offset + oldSize <= hh) {\n      this._scrollY += delta;\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the paint origin of the section.\n    let pos = Math.max(hh, offset);\n\n    // Paint from the section onward if it spans the viewport.\n    if (offset + oldSize >= vh || offset + newSize >= vh) {\n      this.paintContent(0, pos, vw, vh - pos);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the X blit dimensions.\n    let sx = 0;\n    let sw = vw;\n    let dx = 0;\n\n    // Compute the Y blit dimensions.\n    let sy: number;\n    let sh: number;\n    let dy: number;\n    if (offset + newSize <= hh) {\n      sy = hh - delta;\n      sh = vh - sy;\n      dy = hh;\n    } else {\n      sy = offset + oldSize;\n      sh = vh - sy;\n      dy = sy + delta;\n    }\n\n    // Blit the valid content to the destination.\n    this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n\n    // Repaint the section if needed.\n    if (newSize > 0 && offset + newSize > hh) {\n      this.paintContent(0, pos, vw, offset + newSize - pos);\n    }\n\n    // Paint the trailing space as needed.\n    if (this._stretchLastRow && this.pageHeight > this.bodyHeight) {\n      let r = this._rowSections.count - 1;\n      let y = hh + this._rowSections.offsetOf(r);\n      this.paintContent(0, y, vw, vh - y);\n    } else if (delta < 0) {\n      this.paintContent(0, vh + delta, vw, -delta);\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Sync the scroll state.\n    this._syncScrollState();\n  }\n\n  /**\n   * Resize a column section immediately.\n   */\n  private _resizeColumn(index: number, size: number): void {\n    // Look up the target section list.\n    let list = this._columnSections;\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Look up the old size of the section.\n    let oldSize = list.sizeOf(index);\n\n    // Normalize the new size of the section.\n    let newSize = list.clampSize(size);\n\n    // Bail early if the size does not change.\n    if (oldSize === newSize) {\n      return;\n    }\n\n    // Resize the section in the list.\n    list.resize(index, newSize);\n\n    // Get the current size of the viewport.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // If there is nothing to paint, sync the scroll state.\n    if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Render entire grid if scrolling merged cells grid\n    const paintEverything = Private.shouldPaintEverything(this._dataModel!);\n\n    if (paintEverything) {\n      this.paintContent(0, 0, vw, vh);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the size delta.\n    let delta = newSize - oldSize;\n\n    // Look up the row header width.\n    let hw = this.headerWidth;\n\n    // Compute the viewport offset of the section.\n    let offset = list.offsetOf(index) + hw - this._scrollX;\n\n    // Bail early if there is nothing to paint.\n    if (hw >= vw || offset >= vw) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Update the scroll position if the section is not visible.\n    if (offset + oldSize <= hw) {\n      this._scrollX += delta;\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the paint origin of the section.\n    let pos = Math.max(hw, offset);\n\n    // Paint from the section onward if it spans the viewport.\n    if (offset + oldSize >= vw || offset + newSize >= vw) {\n      this.paintContent(pos, 0, vw - pos, vh);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the Y blit dimensions.\n    let sy = 0;\n    let sh = vh;\n    let dy = 0;\n\n    // Compute the X blit dimensions.\n    let sx: number;\n    let sw: number;\n    let dx: number;\n    if (offset + newSize <= hw) {\n      sx = hw - delta;\n      sw = vw - sx;\n      dx = hw;\n    } else {\n      sx = offset + oldSize;\n      sw = vw - sx;\n      dx = sx + delta;\n    }\n\n    // Blit the valid content to the destination.\n    this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n\n    // Repaint the section if needed.\n    if (newSize > 0 && offset + newSize > hw) {\n      this.paintContent(pos, 0, offset + newSize - pos, vh);\n    }\n\n    // Paint the trailing space as needed.\n    if (this._stretchLastColumn && this.pageWidth > this.bodyWidth) {\n      let c = this._columnSections.count - 1;\n      let x = hw + this._columnSections.offsetOf(c);\n      this.paintContent(x, 0, vw - x, vh);\n    } else if (delta < 0) {\n      this.paintContent(vw + delta, 0, -delta, vh);\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Sync the scroll state after painting.\n    this._syncScrollState();\n  }\n\n  /**\n   * Resize a row header section immediately.\n   */\n  private _resizeRowHeader(index: number, size: number): void {\n    // Look up the target section list.\n    let list = this._rowHeaderSections;\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Look up the old size of the section.\n    let oldSize = list.sizeOf(index);\n\n    // Normalize the new size of the section.\n    let newSize = list.clampSize(size);\n\n    // Bail early if the size does not change.\n    if (oldSize === newSize) {\n      return;\n    }\n\n    // Resize the section in the list.\n    list.resize(index, newSize);\n\n    // Get the current size of the viewport.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // If there is nothing to paint, sync the scroll state.\n    if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Render entire grid if scrolling merged cells grid\n    const paintEverything = Private.shouldPaintEverything(this._dataModel!);\n\n    if (paintEverything) {\n      this.paintContent(0, 0, vw, vh);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the size delta.\n    let delta = newSize - oldSize;\n\n    // Look up the offset of the section.\n    let offset = list.offsetOf(index);\n\n    // Bail early if the section is fully outside the viewport.\n    if (offset >= vw) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Paint the entire tail if the section spans the viewport.\n    if (offset + oldSize >= vw || offset + newSize >= vw) {\n      this.paintContent(offset, 0, vw - offset, vh);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the blit content dimensions.\n    let sx = offset + oldSize;\n    let sy = 0;\n    let sw = vw - sx;\n    let sh = vh;\n    let dx = sx + delta;\n    let dy = 0;\n\n    // Blit the valid content to the destination.\n    this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n\n    // Repaint the header section if needed.\n    if (newSize > 0) {\n      this.paintContent(offset, 0, newSize, vh);\n    }\n\n    // Paint the trailing space as needed.\n    if (this._stretchLastColumn && this.pageWidth > this.bodyWidth) {\n      let c = this._columnSections.count - 1;\n      let x = this.headerWidth + this._columnSections.offsetOf(c);\n      this.paintContent(x, 0, vw - x, vh);\n    } else if (delta < 0) {\n      this.paintContent(vw + delta, 0, -delta + 1, vh);\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Sync the scroll state after painting.\n    this._syncScrollState();\n  }\n\n  /**\n   * Resize a column header section immediately.\n   */\n  private _resizeColumnHeader(index: number, size: number): void {\n    // Look up the target section list.\n    let list = this._columnHeaderSections;\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Look up the old size of the section.\n    let oldSize = list.sizeOf(index);\n\n    // Normalize the new size of the section.\n    let newSize = list.clampSize(size);\n\n    // Bail early if the size does not change.\n    if (oldSize === newSize) {\n      return;\n    }\n\n    // Resize the section in the list.\n    list.resize(index, newSize);\n\n    // Get the current size of the viewport.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // If there is nothing to paint, sync the scroll state.\n    if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Render entire grid if scrolling merged cells grid\n    const paintEverything = Private.shouldPaintEverything(this._dataModel!);\n\n    if (paintEverything) {\n      this.paintContent(0, 0, vw, vh);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Compute the size delta.\n    let delta = newSize - oldSize;\n\n    // Look up the offset of the section.\n    let offset = list.offsetOf(index);\n\n    // Bail early if the section is fully outside the viewport.\n    if (offset >= vh) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Paint the entire tail if the section spans the viewport.\n    if (offset + oldSize >= vh || offset + newSize >= vh) {\n      this.paintContent(0, offset, vw, vh - offset);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the blit content dimensions.\n    let sx = 0;\n    let sy = offset + oldSize;\n    let sw = vw;\n    let sh = vh - sy;\n    let dx = 0;\n    let dy = sy + delta;\n\n    // Blit the valid contents to the destination.\n    this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n\n    // Repaint the header section if needed.\n    if (newSize > 0) {\n      this.paintContent(0, offset, vw, newSize);\n    }\n\n    // Paint the trailing space as needed.\n    if (this._stretchLastRow && this.pageHeight > this.bodyHeight) {\n      let r = this._rowSections.count - 1;\n      let y = this.headerHeight + this._rowSections.offsetOf(r);\n      this.paintContent(0, y, vw, vh - y);\n    } else if (delta < 0) {\n      this.paintContent(0, vh + delta, vw, -delta + 1);\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Sync the scroll state after painting.\n    this._syncScrollState();\n  }\n\n  /**\n   * Scroll immediately to the specified offset position.\n   */\n  private _scrollTo(x: number, y: number): void {\n    // Bail if no data model found.\n    if (!this.dataModel) {\n      return;\n    }\n\n    // Floor and clamp the position to the allowable range.\n    x = Math.max(0, Math.min(Math.floor(x), this.maxScrollX));\n    y = Math.max(0, Math.min(Math.floor(y), this.maxScrollY));\n\n    // Synchronize the scroll bar values.\n    this._hScrollBar.value = x;\n    this._vScrollBar.value = y;\n\n    // Compute the delta scroll amount.\n    let dx = x - this._scrollX;\n    let dy = y - this._scrollY;\n\n    // Bail early if there is no effective scroll.\n    if (dx === 0 && dy === 0) {\n      return;\n    }\n\n    // Bail early if the viewport is not visible.\n    if (!this._viewport.isVisible) {\n      this._scrollX = x;\n      this._scrollY = y;\n      return;\n    }\n\n    // Get the current size of the viewport.\n    let width = this._viewportWidth;\n    let height = this._viewportHeight;\n\n    // Bail early if the viewport is empty.\n    if (width === 0 || height === 0) {\n      this._scrollX = x;\n      this._scrollY = y;\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = this.headerWidth;\n    let contentY = this.headerHeight;\n\n    // Get the visible content dimensions.\n    let contentWidth = width - contentX;\n    let contentHeight = height - contentY;\n\n    // Bail early if there is no content to draw.\n    if (contentWidth <= 0 && contentHeight <= 0) {\n      this._scrollX = x;\n      this._scrollY = y;\n      return;\n    }\n\n    // Compute the area which needs painting for the `dx` scroll.\n    let dxArea = 0;\n    if (dx !== 0 && contentWidth > 0) {\n      if (Math.abs(dx) >= contentWidth) {\n        dxArea = contentWidth * height;\n      } else {\n        dxArea = Math.abs(dx) * height;\n      }\n    }\n\n    // Compute the area which needs painting for the `dy` scroll.\n    let dyArea = 0;\n    if (dy !== 0 && contentHeight > 0) {\n      if (Math.abs(dy) >= contentHeight) {\n        dyArea = width * contentHeight;\n      } else {\n        dyArea = width * Math.abs(dy);\n      }\n    }\n\n    // If the area sum is larger than the total, paint everything.\n    if (dxArea + dyArea >= width * height) {\n      this._scrollX = x;\n      this._scrollY = y;\n      this.paintContent(0, 0, width, height);\n      this._paintOverlay();\n      return;\n    }\n\n    // Update the internal Y scroll position.\n    this._scrollY = y;\n\n    // Scroll the Y axis if needed. If the scroll distance exceeds\n    // the visible height, paint everything. Otherwise, blit the\n    // valid content and paint the dirty region.\n    if (dy !== 0 && contentHeight > 0) {\n      if (Math.abs(dy) >= contentHeight) {\n        this.paintContent(0, contentY, width, contentHeight);\n      } else {\n        const x = 0;\n        const y = dy < 0 ? contentY : contentY + dy;\n        const w = width;\n        const h = contentHeight - Math.abs(dy);\n        this._blitContent(this._canvas, x, y, w, h, x, y - dy);\n        this.paintContent(\n          0,\n          dy < 0 ? contentY : height - dy,\n          width,\n          Math.abs(dy)\n        );\n      }\n    }\n\n    // Update the internal X scroll position.\n    this._scrollX = x;\n\n    // Scroll the X axis if needed. If the scroll distance exceeds\n    // the visible width, paint everything. Otherwise, blit the\n    // valid content and paint the dirty region.\n    if (dx !== 0 && contentWidth > 0) {\n      if (Math.abs(dx) >= contentWidth) {\n        this.paintContent(contentX, 0, contentWidth, height);\n      } else {\n        const x = dx < 0 ? contentX : contentX + dx;\n        const y = 0;\n        const w = contentWidth - Math.abs(dx);\n        const h = height;\n        this._blitContent(this._canvas, x, y, w, h, x - dx, y);\n        this.paintContent(\n          dx < 0 ? contentX : width - dx,\n          0,\n          Math.abs(dx),\n          height\n        );\n      }\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n  }\n  /**\n   * Blit content into the on-screen grid canvas.\n   *\n   * The rect should be expressed in viewport coordinates.\n   *\n   * This automatically accounts for the dpi ratio.\n   */\n  private _blitContent(\n    source: HTMLCanvasElement,\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n    dx: number,\n    dy: number\n  ): void {\n    // Scale the blit coordinates by the dpi ratio.\n    x *= this._dpiRatio;\n    y *= this._dpiRatio;\n    w *= this._dpiRatio;\n    h *= this._dpiRatio;\n    dx *= this._dpiRatio;\n    dy *= this._dpiRatio;\n\n    // Save the current gc state.\n    this._canvasGC.save();\n\n    // Set the transform to the identity matrix.\n    this._canvasGC.setTransform(1, 0, 0, 1, 0, 0);\n\n    // Draw the specified content.\n    this._canvasGC.drawImage(source, x, y, w, h, dx, dy, w, h);\n\n    // Restore the gc state.\n    this._canvasGC.restore();\n  }\n\n  /**\n   * Paint the grid content for the given dirty rect.\n   *\n   * The rect should be expressed in valid viewport coordinates.\n   *\n   * This is the primary paint entry point. The individual `_draw*`\n   * methods should not be invoked directly. This method dispatches\n   * to the drawing methods in the correct order.\n   */\n  protected paintContent(rx: number, ry: number, rw: number, rh: number): void {\n    // Scale the canvas and buffer GC for the dpi ratio.\n    this._canvasGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);\n    this._bufferGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);\n\n    // Clear the dirty rect of all content.\n    this._canvasGC.clearRect(rx, ry, rw, rh);\n\n    // Draw the void region.\n    this._drawVoidRegion(rx, ry, rw, rh);\n\n    // Draw the body region.\n    this._drawBodyRegion(rx, ry, rw, rh);\n\n    // Draw the row header region.\n    this._drawRowHeaderRegion(rx, ry, rw, rh);\n\n    // Draw the column header region.\n    this._drawColumnHeaderRegion(rx, ry, rw, rh);\n\n    // Draw the corner header region.\n    this.drawCornerHeaderRegion(rx, ry, rw, rh);\n  }\n\n  /**\n   * Resizes body column headers so their text fits\n   * without clipping or wrapping.\n   * @param dataModel\n   */\n  private _fitBodyColumnHeaders(\n    dataModel: DataModel,\n    padding: number,\n    numCols?: number\n  ): void {\n    // Get the body column count\n    const bodyColumnCount =\n      numCols === undefined ? dataModel.columnCount('body') : numCols;\n\n    for (let i = 0; i < bodyColumnCount; i++) {\n      /* \n        if we're working with nested column headers,\n        retrieve the nested levels and iterate on them.\n      */\n      const numRows = dataModel.rowCount('column-header');\n\n      /*\n        Calculate the maximum text width vertically, across\n        all nested rows under a given column number.\n      */\n      let maxWidth = 0;\n      for (let j = 0; j < numRows; j++) {\n        const cellValue = dataModel.data('column-header', j, i);\n\n        // Basic CellConfig object to get the renderer for that cell\n        let config = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0,\n          region: 'column-header' as DataModel.CellRegion,\n          row: 0,\n          column: i,\n          value: null as any,\n          metadata: DataModel.emptyMetadata\n        };\n\n        // Get the renderer for the given cell\n        const renderer = this.cellRenderers.get(config) as TextRenderer;\n\n        // Use the canvas context to measure the cell's text width\n        const gc = this.canvasGC;\n        gc.font = CellRenderer.resolveOption(renderer.font, config);\n        const textWidth = gc.measureText(cellValue).width;\n\n        // Update the maximum width for that column.\n        maxWidth = Math.max(maxWidth, textWidth);\n      }\n\n      /*\n        Send a resize message with new width for the given column.\n        Using a padding of 15 pixels to leave some room.\n      */\n      this.resizeColumn('body', i, maxWidth + padding);\n    }\n  }\n\n  /**\n   * Resizes row header columns so their text fits\n   * without clipping or wrapping.\n   * @param dataModel\n   */\n  private _fitRowColumnHeaders(\n    dataModel: DataModel,\n    padding: number,\n    numCols?: number\n  ): void {\n    /*\n      if we're working with nested row headers,\n      retrieve the nested levels and iterate on them.\n    */\n    const rowColumnCount =\n      numCols === undefined ? dataModel.columnCount('row-header') : numCols;\n\n    for (let i = 0; i < rowColumnCount; i++) {\n      const numCols = dataModel.rowCount('column-header');\n      /*\n        Calculate the maximum text width vertically, across\n        all nested columns under a given row index.\n      */\n      let maxWidth = 0;\n      for (let j = 0; j < numCols; j++) {\n        const cellValue = dataModel.data('corner-header', j, i);\n\n        // Basic CellConfig object to get the renderer for that cell.\n        let config = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0,\n          region: 'column-header' as DataModel.CellRegion,\n          row: 0,\n          column: i,\n          value: null as any,\n          metadata: DataModel.emptyMetadata\n        };\n\n        // Get the renderer for the given cell.\n        const renderer = this.cellRenderers.get(config) as TextRenderer;\n\n        // Use the canvas context to measure the cell's text width\n        const gc = this.canvasGC;\n        gc.font = CellRenderer.resolveOption(renderer.font, config);\n        const textWidth = gc.measureText(cellValue).width;\n        maxWidth = Math.max(maxWidth, textWidth);\n      }\n\n      /*\n        Send a resize message with new width for the given column.\n        Using a padding of 15 pixels to leave some room.\n      */\n      this.resizeColumn('row-header', i, maxWidth + padding);\n    }\n  }\n\n  /**\n   * Paint the overlay content for the entire grid.\n   *\n   * This is the primary overlay paint entry point. The individual\n   * `_draw*` methods should not be invoked directly. This method\n   * dispatches to the drawing methods in the correct order.\n   */\n  private _paintOverlay(): void {\n    // Scale the overlay GC for the dpi ratio.\n    this._overlayGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);\n\n    // Clear the overlay of all content.\n    this._overlayGC.clearRect(0, 0, this._overlay.width, this._overlay.height);\n\n    // Draw the body selections.\n    this._drawBodySelections();\n\n    // Draw the row header selections.\n    this._drawRowHeaderSelections();\n\n    // Draw the column header selections.\n    this._drawColumnHeaderSelections();\n\n    // Draw the cursor.\n    this._drawCursor();\n\n    // Draw the shadows.\n    this._drawShadows();\n  }\n\n  /**\n   * Draw the void region for the dirty rect.\n   */\n  private _drawVoidRegion(\n    rx: number,\n    ry: number,\n    rw: number,\n    rh: number\n  ): void {\n    // Look up the void color.\n    let color = this._style.voidColor;\n\n    // Bail if there is no void color.\n    if (!color) {\n      return;\n    }\n\n    // Fill the dirty rect with the void color.\n    this._canvasGC.fillStyle = color;\n    this._canvasGC.fillRect(rx, ry, rw, rh);\n  }\n\n  /**\n   * Draw the body region which intersects the dirty rect.\n   */\n  private _drawBodyRegion(\n    rx: number,\n    ry: number,\n    rw: number,\n    rh: number\n  ): void {\n    // Get the visible content dimensions.\n    let contentW = this._columnSections.length - this._scrollX;\n    let contentH = this._rowSections.length - this._scrollY;\n\n    // Bail if there is no content to draw.\n    if (contentW <= 0 || contentH <= 0) {\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = this.headerWidth;\n    let contentY = this.headerHeight;\n\n    // Bail if the dirty rect does not intersect the content area.\n    if (rx + rw <= contentX) {\n      return;\n    }\n    if (ry + rh <= contentY) {\n      return;\n    }\n    if (rx >= contentX + contentW) {\n      return;\n    }\n    if (ry >= contentY + contentH) {\n      return;\n    }\n\n    // Fetch the geometry.\n    let bh = this.bodyHeight;\n    let bw = this.bodyWidth;\n    let ph = this.pageHeight;\n    let pw = this.pageWidth;\n\n    // Get the upper and lower bounds of the dirty content area.\n    let x1 = Math.max(rx, contentX);\n    let y1 = Math.max(ry, contentY);\n    let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n    let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n\n    // Convert the dirty content bounds into cell bounds.\n    let r1 = this._rowSections.indexOf(y1 - contentY + this._scrollY);\n    let c1 = this._columnSections.indexOf(x1 - contentX + this._scrollX);\n    let r2 = this._rowSections.indexOf(y2 - contentY + this._scrollY);\n    let c2 = this._columnSections.indexOf(x2 - contentX + this._scrollX);\n\n    // Fetch the max row and column.\n    let maxRow = this._rowSections.count - 1;\n    let maxColumn = this._columnSections.count - 1;\n\n    // Handle a dirty content area larger than the cell count.\n    if (r2 < 0) {\n      r2 = maxRow;\n    }\n    if (c2 < 0) {\n      c2 = maxColumn;\n    }\n\n    // Convert the cell bounds back to visible coordinates.\n    let x = this._columnSections.offsetOf(c1) + contentX - this._scrollX;\n    let y = this._rowSections.offsetOf(r1) + contentY - this._scrollY;\n\n    // Set up the paint region size variables.\n    let width = 0;\n    let height = 0;\n\n    // Allocate the section sizes arrays.\n    let rowSizes = new Array<number>(r2 - r1 + 1);\n    let columnSizes = new Array<number>(c2 - c1 + 1);\n\n    // Get the row sizes for the region.\n    for (let j = r1; j <= r2; ++j) {\n      let size = this._rowSections.sizeOf(j);\n      rowSizes[j - r1] = size;\n      height += size;\n    }\n\n    // Get the column sizes for the region.\n    for (let i = c1; i <= c2; ++i) {\n      let size = this._columnSections.sizeOf(i);\n      columnSizes[i - c1] = size;\n      width += size;\n    }\n\n    // Adjust the geometry if the last row is streched.\n    if (this._stretchLastRow && ph > bh && r2 === maxRow) {\n      let dh = this.pageHeight - this.bodyHeight;\n      rowSizes[rowSizes.length - 1] += dh;\n      height += dh;\n      y2 += dh;\n    }\n\n    // Adjust the geometry if the last column is streched.\n    if (this._stretchLastColumn && pw > bw && c2 === maxColumn) {\n      let dw = this.pageWidth - this.bodyWidth;\n      columnSizes[columnSizes.length - 1] += dw;\n      width += dw;\n      x2 += dw;\n    }\n\n    // Create the paint region object.\n    let rgn: Private.PaintRegion = {\n      region: 'body',\n      xMin: x1,\n      yMin: y1,\n      xMax: x2,\n      yMax: y2,\n      x,\n      y,\n      width,\n      height,\n      row: r1,\n      column: c1,\n      rowSizes,\n      columnSizes\n    };\n\n    // Draw the background.\n    this._drawBackground(rgn, this._style.backgroundColor);\n\n    // Draw the row background.\n    this._drawRowBackground(rgn, this._style.rowBackgroundColor);\n\n    // Draw the column background.\n    this._drawColumnBackground(rgn, this._style.columnBackgroundColor);\n\n    // Draw the cell content for the paint region.\n    this._drawCells(rgn);\n\n    // Draw the horizontal grid lines.\n    this._drawHorizontalGridLines(\n      rgn,\n      this._style.horizontalGridLineColor || this._style.gridLineColor\n    );\n\n    // Draw the vertical grid lines.\n    this._drawVerticalGridLines(\n      rgn,\n      this._style.verticalGridLineColor || this._style.gridLineColor\n    );\n  }\n\n  /**\n   * Draw the row header region which intersects the dirty rect.\n   */\n  private _drawRowHeaderRegion(\n    rx: number,\n    ry: number,\n    rw: number,\n    rh: number\n  ): void {\n    // Get the visible content dimensions.\n    let contentW = this.headerWidth;\n    let contentH = this.bodyHeight - this._scrollY;\n\n    // Bail if there is no content to draw.\n    if (contentW <= 0 || contentH <= 0) {\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = 0;\n    let contentY = this.headerHeight;\n\n    // Bail if the dirty rect does not intersect the content area.\n    if (rx + rw <= contentX) {\n      return;\n    }\n    if (ry + rh <= contentY) {\n      return;\n    }\n    if (rx >= contentX + contentW) {\n      return;\n    }\n    if (ry >= contentY + contentH) {\n      return;\n    }\n\n    // Fetch the geometry.\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n\n    // Get the upper and lower bounds of the dirty content area.\n    let x1 = rx;\n    let y1 = Math.max(ry, contentY);\n    let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n    let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n\n    // Convert the dirty content bounds into cell bounds.\n    let r1 = this._rowSections.indexOf(y1 - contentY + this._scrollY);\n    let c1 = this._rowHeaderSections.indexOf(x1);\n    let r2 = this._rowSections.indexOf(y2 - contentY + this._scrollY);\n    let c2 = this._rowHeaderSections.indexOf(x2);\n\n    // Fetch max row and column.\n    let maxRow = this._rowSections.count - 1;\n    let maxColumn = this._rowHeaderSections.count - 1;\n\n    // Handle a dirty content area larger than the cell count.\n    if (r2 < 0) {\n      r2 = maxRow;\n    }\n    if (c2 < 0) {\n      c2 = maxColumn;\n    }\n\n    // Convert the cell bounds back to visible coordinates.\n    let x = this._rowHeaderSections.offsetOf(c1);\n    let y = this._rowSections.offsetOf(r1) + contentY - this._scrollY;\n\n    // Set up the paint region size variables.\n    let width = 0;\n    let height = 0;\n\n    // Allocate the section sizes arrays.\n    let rowSizes = new Array<number>(r2 - r1 + 1);\n    let columnSizes = new Array<number>(c2 - c1 + 1);\n\n    // Get the row sizes for the region.\n    for (let j = r1; j <= r2; ++j) {\n      let size = this._rowSections.sizeOf(j);\n      rowSizes[j - r1] = size;\n      height += size;\n    }\n\n    // Get the column sizes for the region.\n    for (let i = c1; i <= c2; ++i) {\n      let size = this._rowHeaderSections.sizeOf(i);\n      columnSizes[i - c1] = size;\n      width += size;\n    }\n\n    // Adjust the geometry if the last row is stretched.\n    if (this._stretchLastRow && ph > bh && r2 === maxRow) {\n      let dh = this.pageHeight - this.bodyHeight;\n      rowSizes[rowSizes.length - 1] += dh;\n      height += dh;\n      y2 += dh;\n    }\n\n    // Create the paint region object.\n    let rgn: Private.PaintRegion = {\n      region: 'row-header',\n      xMin: x1,\n      yMin: y1,\n      xMax: x2,\n      yMax: y2,\n      x,\n      y,\n      width,\n      height,\n      row: r1,\n      column: c1,\n      rowSizes,\n      columnSizes\n    };\n\n    // Draw the background.\n    this._drawBackground(rgn, this._style.headerBackgroundColor);\n\n    // Draw the cell content for the paint region.\n    this._drawCells(rgn);\n\n    // Draw the horizontal grid lines.\n    this._drawHorizontalGridLines(\n      rgn,\n      this._style.headerHorizontalGridLineColor ||\n        this._style.headerGridLineColor\n    );\n\n    // Draw the vertical grid lines.\n    this._drawVerticalGridLines(\n      rgn,\n      this._style.headerVerticalGridLineColor || this._style.headerGridLineColor\n    );\n  }\n\n  /**\n   * Draw the column header region which intersects the dirty rect.\n   */\n  private _drawColumnHeaderRegion(\n    rx: number,\n    ry: number,\n    rw: number,\n    rh: number\n  ): void {\n    // Get the visible content dimensions.\n    let contentW = this.bodyWidth - this._scrollX;\n    let contentH = this.headerHeight;\n\n    // Bail if there is no content to draw.\n    if (contentW <= 0 || contentH <= 0) {\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = this.headerWidth;\n    let contentY = 0;\n\n    // Bail if the dirty rect does not intersect the content area.\n    if (rx + rw <= contentX) {\n      return;\n    }\n    if (ry + rh <= contentY) {\n      return;\n    }\n    if (rx >= contentX + contentW) {\n      return;\n    }\n    if (ry >= contentY + contentH) {\n      return;\n    }\n\n    // Fetch the geometry.\n    let bw = this.bodyWidth;\n    let pw = this.pageWidth;\n\n    // Get the upper and lower bounds of the dirty content area.\n    let x1 = Math.max(rx, contentX);\n    let y1 = ry;\n    let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n    let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n\n    // Convert the dirty content bounds into cell bounds.\n    let r1 = this._columnHeaderSections.indexOf(y1);\n    let c1 = this._columnSections.indexOf(x1 - contentX + this._scrollX);\n    let r2 = this._columnHeaderSections.indexOf(y2);\n    let c2 = this._columnSections.indexOf(x2 - contentX + this._scrollX);\n\n    // Fetch the max row and column.\n    let maxRow = this._columnHeaderSections.count - 1;\n    let maxColumn = this._columnSections.count - 1;\n\n    // Handle a dirty content area larger than the cell count.\n    if (r2 < 0) {\n      r2 = maxRow;\n    }\n    if (c2 < 0) {\n      c2 = maxColumn;\n    }\n\n    // Convert the cell bounds back to visible coordinates.\n    let x = this._columnSections.offsetOf(c1) + contentX - this._scrollX;\n    let y = this._columnHeaderSections.offsetOf(r1);\n\n    // Set up the paint region size variables.\n    let width = 0;\n    let height = 0;\n\n    // Allocate the section sizes arrays.\n    let rowSizes = new Array<number>(r2 - r1 + 1);\n    let columnSizes = new Array<number>(c2 - c1 + 1);\n\n    // Get the row sizes for the region.\n    for (let j = r1; j <= r2; ++j) {\n      let size = this._columnHeaderSections.sizeOf(j);\n      rowSizes[j - r1] = size;\n      height += size;\n    }\n\n    // Get the column sizes for the region.\n    for (let i = c1; i <= c2; ++i) {\n      let size = this._columnSections.sizeOf(i);\n      columnSizes[i - c1] = size;\n      width += size;\n    }\n\n    // Adjust the geometry if the last column is stretched.\n    if (this._stretchLastColumn && pw > bw && c2 === maxColumn) {\n      let dw = this.pageWidth - this.bodyWidth;\n      columnSizes[columnSizes.length - 1] += dw;\n      width += dw;\n      x2 += dw;\n    }\n\n    // Create the paint region object.\n    let rgn: Private.PaintRegion = {\n      region: 'column-header',\n      xMin: x1,\n      yMin: y1,\n      xMax: x2,\n      yMax: y2,\n      x,\n      y,\n      width,\n      height,\n      row: r1,\n      column: c1,\n      rowSizes,\n      columnSizes\n    };\n\n    // Draw the background.\n    this._drawBackground(rgn, this._style.headerBackgroundColor);\n\n    // Draw the cell content for the paint region.\n    this._drawCells(rgn);\n\n    // Draw the horizontal grid lines.\n    this._drawHorizontalGridLines(\n      rgn,\n      this._style.headerHorizontalGridLineColor ||\n        this._style.headerGridLineColor\n    );\n\n    // Draw the vertical grid lines.\n    this._drawVerticalGridLines(\n      rgn,\n      this._style.headerVerticalGridLineColor || this._style.headerGridLineColor\n    );\n  }\n\n  /**\n   * Draw the corner header region which intersects the dirty rect.\n   */\n  protected drawCornerHeaderRegion(\n    rx: number,\n    ry: number,\n    rw: number,\n    rh: number\n  ): void {\n    // Get the visible content dimensions.\n    let contentW = this.headerWidth;\n    let contentH = this.headerHeight;\n\n    // Bail if there is no content to draw.\n    if (contentW <= 0 || contentH <= 0) {\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = 0;\n    let contentY = 0;\n\n    // Bail if the dirty rect does not intersect the content area.\n    if (rx + rw <= contentX) {\n      return;\n    }\n    if (ry + rh <= contentY) {\n      return;\n    }\n    if (rx >= contentX + contentW) {\n      return;\n    }\n    if (ry >= contentY + contentH) {\n      return;\n    }\n\n    // Get the upper and lower bounds of the dirty content area.\n    let x1 = rx;\n    let y1 = ry;\n    let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n    let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n\n    // Convert the dirty content bounds into cell bounds.\n    let r1 = this._columnHeaderSections.indexOf(y1);\n    let c1 = this._rowHeaderSections.indexOf(x1);\n    let r2 = this._columnHeaderSections.indexOf(y2);\n    let c2 = this._rowHeaderSections.indexOf(x2);\n\n    // Handle a dirty content area larger than the cell count.\n    if (r2 < 0) {\n      r2 = this._columnHeaderSections.count - 1;\n    }\n    if (c2 < 0) {\n      c2 = this._rowHeaderSections.count - 1;\n    }\n\n    // Convert the cell bounds back to visible coordinates.\n    let x = this._rowHeaderSections.offsetOf(c1);\n    let y = this._columnHeaderSections.offsetOf(r1);\n\n    // Set up the paint region size variables.\n    let width = 0;\n    let height = 0;\n\n    // Allocate the section sizes arrays.\n    let rowSizes = new Array<number>(r2 - r1 + 1);\n    let columnSizes = new Array<number>(c2 - c1 + 1);\n\n    // Get the row sizes for the region.\n    for (let j = r1; j <= r2; ++j) {\n      let size = this._columnHeaderSections.sizeOf(j);\n      rowSizes[j - r1] = size;\n      height += size;\n    }\n\n    // Get the column sizes for the region.\n    for (let i = c1; i <= c2; ++i) {\n      let size = this._rowHeaderSections.sizeOf(i);\n      columnSizes[i - c1] = size;\n      width += size;\n    }\n\n    // Create the paint region object.\n    let rgn: Private.PaintRegion = {\n      region: 'corner-header',\n      xMin: x1,\n      yMin: y1,\n      xMax: x2,\n      yMax: y2,\n      x,\n      y,\n      width,\n      height,\n      row: r1,\n      column: c1,\n      rowSizes,\n      columnSizes\n    };\n\n    // Draw the background.\n    this._drawBackground(rgn, this._style.headerBackgroundColor);\n\n    // Draw the cell content for the paint region.\n    this._drawCells(rgn);\n\n    // Draw the horizontal grid lines.\n    this._drawHorizontalGridLines(\n      rgn,\n      this._style.headerHorizontalGridLineColor ||\n        this._style.headerGridLineColor\n    );\n\n    // Draw the vertical grid lines.\n    this._drawVerticalGridLines(\n      rgn,\n      this._style.headerVerticalGridLineColor || this._style.headerGridLineColor\n    );\n  }\n\n  /**\n   * Draw the background for the given paint region.\n   */\n  private _drawBackground(\n    rgn: Private.PaintRegion,\n    color: string | undefined\n  ): void {\n    // Bail if there is no color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Unpack the region.\n    let { xMin, yMin, xMax, yMax } = rgn;\n\n    // Fill the region with the specified color.\n    this._canvasGC.fillStyle = color;\n    this._canvasGC.fillRect(xMin, yMin, xMax - xMin + 1, yMax - yMin + 1);\n  }\n\n  /**\n   * Draw the row background for the given paint region.\n   */\n  private _drawRowBackground(\n    rgn: Private.PaintRegion,\n    colorFn: ((i: number) => string) | undefined\n  ): void {\n    // Bail if there is no color function.\n    if (!colorFn) {\n      return;\n    }\n\n    // Compute the X bounds for the row.\n    let x1 = Math.max(rgn.xMin, rgn.x);\n    let x2 = Math.min(rgn.x + rgn.width - 1, rgn.xMax);\n\n    // Draw the background for the rows in the region.\n    for (let y = rgn.y, j = 0, n = rgn.rowSizes.length; j < n; ++j) {\n      // Fetch the size of the row.\n      let size = rgn.rowSizes[j];\n\n      // Skip zero sized rows.\n      if (size === 0) {\n        continue;\n      }\n\n      // Get the background color for the row.\n      let color = colorFn(rgn.row + j);\n\n      // Fill the row with the background color if needed.\n      if (color) {\n        let y1 = Math.max(rgn.yMin, y);\n        let y2 = Math.min(y + size - 1, rgn.yMax);\n        this._canvasGC.fillStyle = color;\n        this._canvasGC.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n      }\n\n      // Increment the running Y coordinate.\n      y += size;\n    }\n  }\n\n  /**\n   * Draw the column background for the given paint region.\n   */\n  private _drawColumnBackground(\n    rgn: Private.PaintRegion,\n    colorFn: ((i: number) => string) | undefined\n  ): void {\n    // Bail if there is no color function.\n    if (!colorFn) {\n      return;\n    }\n\n    // Compute the Y bounds for the column.\n    let y1 = Math.max(rgn.yMin, rgn.y);\n    let y2 = Math.min(rgn.y + rgn.height - 1, rgn.yMax);\n\n    // Draw the background for the columns in the region.\n    for (let x = rgn.x, i = 0, n = rgn.columnSizes.length; i < n; ++i) {\n      // Fetch the size of the column.\n      let size = rgn.columnSizes[i];\n\n      // Skip zero sized columns.\n      if (size === 0) {\n        continue;\n      }\n\n      // Get the background color for the column.\n      let color = colorFn(rgn.column + i);\n\n      // Fill the column with the background color if needed.\n      if (color) {\n        let x1 = Math.max(rgn.xMin, x);\n        let x2 = Math.min(x + size - 1, rgn.xMax);\n        this._canvasGC.fillStyle = color;\n        this._canvasGC.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n      }\n\n      // Increment the running X coordinate.\n      x += size;\n    }\n  }\n\n  /**\n   * Returns column size\n   * @param region\n   * @param index\n   */\n  private _getColumnSize(region: DataModel.CellRegion, index: number): number {\n    if (region === 'corner-header') {\n      return this._rowHeaderSections.sizeOf(index);\n    }\n    return this.columnSize(region as DataModel.ColumnRegion, index);\n  }\n\n  /**\n   * Returns row size\n   * @param region\n   * @param index\n   */\n  private _getRowSize(region: DataModel.CellRegion, index: number): number {\n    if (region === 'corner-header') {\n      return this._columnHeaderSections.sizeOf(index);\n    }\n    return this.rowSize(region as DataModel.RowRegion, index);\n  }\n\n  /**\n   * Draw the cells for the given paint region.\n   */\n  private _drawCells(rgn: Private.PaintRegion): void {\n    // Bail if there is no data model.\n    if (!this._dataModel) {\n      return;\n    }\n\n    // Determine if the cell intersects with a merged group at row or column\n    let intersectingColumnGroups = CellGroup.getCellGroupsAtColumn(\n      this._dataModel!,\n      rgn.region,\n      rgn.column\n    );\n    let intersectingRowGroups = CellGroup.getCellGroupsAtRow(\n      this._dataModel!,\n      rgn.region,\n      rgn.row\n    );\n\n    // move the bounds of the region if edges of the region are part of a merge group.\n    // after the move, new region contains entirety of the merge groups\n    rgn = JSONExt.deepCopy(rgn);\n\n    const joinedGroup = CellGroup.joinCellGroupWithMergedCellGroups(\n      this.dataModel!,\n      {\n        r1: rgn.row,\n        r2: rgn.row + rgn.rowSizes.length - 1,\n        c1: rgn.column,\n        c2: rgn.column + rgn.columnSizes.length - 1\n      },\n      rgn.region\n    );\n\n    for (let r = joinedGroup.r1; r < rgn.row; r++) {\n      const h = this._getRowSize(rgn.region, r);\n      rgn.y -= h;\n      rgn.rowSizes = [h].concat(rgn.rowSizes);\n    }\n    rgn.row = joinedGroup.r1;\n\n    for (let c = joinedGroup.c1; c < rgn.column; c++) {\n      const w = this._getColumnSize(rgn.region, c);\n      rgn.x -= w;\n      rgn.columnSizes = [w].concat(rgn.columnSizes);\n    }\n    rgn.column = joinedGroup.c1;\n\n    // Set up the cell config object for rendering.\n    let config = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      region: rgn.region,\n      row: 0,\n      column: 0,\n      value: null as any,\n      metadata: DataModel.emptyMetadata\n    };\n\n    let groupIndex = -1;\n\n    // Save the buffer gc before wrapping.\n    this._bufferGC.save();\n\n    // Wrap the buffer gc for painting the cells.\n    let gc = new GraphicsContext(this._bufferGC);\n\n    let height = 0;\n\n    // Loop over the columns in the region.\n    for (let x = rgn.x, i = 0, n = rgn.columnSizes.length; i < n; ++i) {\n      let xOffset = 0;\n      let yOffset = 0;\n\n      // Fetch the size of the column.\n      let width = rgn.columnSizes[i];\n\n      // Skip zero sized columns.\n      if (width === 0) {\n        continue;\n      }\n\n      xOffset = width;\n\n      // Compute the column index.\n      let column = rgn.column + i;\n\n      // Update the config for the current column.\n      config.x = x;\n      config.width = width;\n      config.column = column;\n\n      // Loop over the rows in the column.\n      for (let y = rgn.y, j = 0, n = rgn.rowSizes.length; j < n; ++j) {\n        // Fetch the size of the row.\n        height = rgn.rowSizes[j];\n\n        // Skip zero sized rows.\n        if (height === 0) {\n          continue;\n        }\n\n        // Compute the row index.\n        let row = rgn.row + j;\n\n        groupIndex = CellGroup.getGroupIndex(\n          this.dataModel!,\n          config.region,\n          row,\n          column\n        );\n        yOffset = height;\n\n        /**\n         * For merged cell regions, only rendering the merged region\n         * if the \"parent\" cell is the one being painted. Bail otherwise.\n         */\n        if (groupIndex !== -1) {\n          const group = this.dataModel!.group(config.region, groupIndex)!;\n          if (group.r1 === row && group.c1 === column) {\n            width = 0;\n            for (let c = group.c1; c <= group.c2; c++) {\n              width += this._getColumnSize(config.region, c);\n            }\n\n            height = 0;\n            for (let r = group.r1; r <= group.r2; r++) {\n              height += this._getRowSize(config.region, r);\n            }\n          } else {\n            y += yOffset;\n            continue;\n          }\n        } else {\n          /**\n           * Reset column width if we're rendering a column-header\n           * which is not part of a merged cell group.\n           */\n          if (rgn.region == 'column-header') {\n            width = rgn.columnSizes[i];\n          }\n        }\n\n        // Clear the buffer rect for the cell.\n        gc.clearRect(x, y, width, height);\n\n        // Save the GC state.\n        gc.save();\n\n        // Get the value for the cell.\n        let value: any;\n        try {\n          value = this._dataModel.data(rgn.region, row, column);\n        } catch (err) {\n          value = undefined;\n          console.error(err);\n        }\n\n        // Get the metadata for the cell.\n        let metadata: DataModel.Metadata;\n        try {\n          metadata = this._dataModel.metadata(rgn.region, row, column);\n        } catch (err) {\n          metadata = DataModel.emptyMetadata;\n          console.error(err);\n        }\n\n        // Update the config for the current cell.\n        config.y = y;\n        config.height = height;\n        config.width = width;\n        config.row = row;\n        config.value = value;\n        config.metadata = metadata;\n\n        // Get the renderer for the cell.\n        let renderer = this._cellRenderers.get(config);\n\n        // Save the GC state.\n        gc.save();\n\n        // Paint the cell into the off-screen buffer.\n        try {\n          renderer.paint(gc, config);\n        } catch (err) {\n          console.error(err);\n        }\n\n        // Restore the GC state.\n        gc.restore();\n\n        // Compute the actual X bounds for the cell.\n        let x1 = Math.max(rgn.xMin, config.x);\n        let x2 = Math.min(config.x + config.width - 1, rgn.xMax);\n\n        // Compute the actual Y bounds for the cell.\n        let y1 = Math.max(rgn.yMin, config.y);\n        let y2 = Math.min(config.y + config.height - 1, rgn.yMax);\n\n        if (\n          intersectingColumnGroups.length !== 0 ||\n          intersectingRowGroups.length !== 0\n        ) {\n          if (x2 > x1 && y2 > y1) {\n            this._blitContent(\n              this._buffer,\n              x1,\n              y1,\n              x2 - x1 + 1,\n              y2 - y1 + 1,\n              x1,\n              y1\n            );\n          }\n        } else {\n          this._blitContent(\n            this._buffer,\n            x1,\n            y1,\n            x2 - x1 + 1,\n            y2 - y1 + 1,\n            x1,\n            y1\n          );\n        }\n\n        // Increment the running Y coordinate.\n        y += yOffset;\n      }\n\n      // Restore the GC state.\n      gc.restore();\n\n      // Increment the running X coordinate.\n      x += xOffset;\n    }\n\n    // Dispose of the wrapped gc.\n    gc.dispose();\n\n    // Restore the final buffer gc state.\n    this._bufferGC.restore();\n  }\n\n  /**\n   * Draw the horizontal grid lines for the given paint region.\n   */\n  private _drawHorizontalGridLines(\n    rgn: Private.PaintRegion,\n    color: string | undefined\n  ): void {\n    // Bail if there is no color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Compute the X bounds for the horizontal lines.\n    let x1 = Math.max(rgn.xMin, rgn.x);\n\n    // Begin the path for the grid lines.\n    this._canvasGC.beginPath();\n\n    // Set the line width for the grid lines.\n    this._canvasGC.lineWidth = 1;\n\n    // Fetch the geometry.\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n\n    // Fetch the number of grid lines to be drawn.\n    let n = rgn.rowSizes.length;\n\n    // Adjust the count down if the last line shouldn't be drawn.\n    if (this._stretchLastRow && ph > bh) {\n      if (rgn.row + n === this._rowSections.count) {\n        n -= 1;\n      }\n    }\n\n    // Draw the horizontal grid lines.\n    for (let y = rgn.y, j = 0; j < n; ++j) {\n      // Fetch the size of the row.\n      let size = rgn.rowSizes[j];\n\n      // Skip zero sized rows.\n      if (size === 0) {\n        continue;\n      }\n\n      let xStart = 0;\n      let lineStarted = false;\n      let lines = [];\n      let leftCurrent = x1;\n\n      for (let c = rgn.column; c < rgn.column + rgn.columnSizes.length; c++) {\n        const cIndex = c - rgn.column;\n        const cellUp = [rgn.row + j, c];\n        const cellDown = [rgn.row + j + 1, c];\n\n        if (\n          CellGroup.areCellsMerged(\n            this.dataModel!,\n            rgn.region,\n            cellUp,\n            cellDown\n          )\n        ) {\n          if (lineStarted) {\n            lines.push([xStart, leftCurrent]);\n          }\n          lineStarted = false;\n        } else {\n          if (!lineStarted) {\n            lineStarted = true;\n            xStart = leftCurrent;\n          }\n        }\n\n        leftCurrent += rgn.columnSizes[cIndex];\n        if (c === rgn.column) {\n          leftCurrent -= rgn.xMin - rgn.x;\n        }\n      }\n\n      if (lineStarted) {\n        lines.push([xStart, rgn.xMax + 1]);\n      }\n\n      // Compute the Y position of the line.\n      let pos = y + size - 1;\n\n      // Draw the line if it's in range of the dirty rect.\n      if (pos >= rgn.yMin && pos <= rgn.yMax) {\n        // Render entire grid if scrolling merged cells grid\n        const extendLines = Private.shouldPaintEverything(this._dataModel!);\n        if (extendLines) {\n          for (const line of lines) {\n            const [x1, x2] = line;\n            this._canvasGC.moveTo(x1, pos + 0.5);\n            this._canvasGC.lineTo(x2, pos + 0.5);\n          }\n        } else {\n          const x2 = Math.min(rgn.x + rgn.width, rgn.xMax + 1);\n          this._canvasGC.moveTo(x1, pos + 0.5);\n          this._canvasGC.lineTo(x2, pos + 0.5);\n        }\n      }\n\n      // Increment the running Y coordinate.\n      y += size;\n    }\n\n    // Stroke the lines with the specified color.\n    this._canvasGC.strokeStyle = color;\n    this._canvasGC.stroke();\n  }\n\n  /**\n   * Draw the vertical grid lines for the given paint region.\n   */\n  private _drawVerticalGridLines(\n    rgn: Private.PaintRegion,\n    color: string | undefined\n  ): void {\n    // Bail if there is no color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Compute the Y bounds for the vertical lines.\n    let y1 = Math.max(rgn.yMin, rgn.y);\n\n    // Begin the path for the grid lines\n    this._canvasGC.beginPath();\n\n    // Set the line width for the grid lines.\n    this._canvasGC.lineWidth = 1;\n\n    // Fetch the geometry.\n    let bw = this.bodyWidth;\n    let pw = this.pageWidth;\n\n    // Fetch the number of grid lines to be drawn.\n    let n = rgn.columnSizes.length;\n\n    // Adjust the count down if the last line shouldn't be drawn.\n    if (this._stretchLastColumn && pw > bw) {\n      if (rgn.column + n === this._columnSections.count) {\n        n -= 1;\n      }\n    }\n\n    // Draw the vertical grid lines.\n    for (let x = rgn.x, i = 0; i < n; ++i) {\n      // Fetch the size of the column.\n      let size = rgn.columnSizes[i];\n\n      // Skip zero sized columns.\n      if (size === 0) {\n        continue;\n      }\n\n      let yStart = 0;\n      let lineStarted = false;\n      let lines = [];\n      let topCurrent = y1;\n\n      for (let r = rgn.row; r < rgn.row + rgn.rowSizes.length; r++) {\n        const rIndex = r - rgn.row;\n        const cellLeft = [r, rgn.column + i];\n        const cellRight = [r, rgn.column + i + 1];\n\n        if (\n          CellGroup.areCellsMerged(\n            this.dataModel!,\n            rgn.region,\n            cellLeft,\n            cellRight\n          )\n        ) {\n          if (lineStarted) {\n            lines.push([yStart, topCurrent]);\n          }\n          lineStarted = false;\n        } else {\n          if (!lineStarted) {\n            lineStarted = true;\n            yStart = topCurrent;\n          }\n        }\n\n        topCurrent += rgn.rowSizes[rIndex];\n        if (r === rgn.row) {\n          topCurrent -= rgn.yMin - rgn.y;\n        }\n      }\n\n      if (lineStarted) {\n        lines.push([yStart, rgn.yMax + 1]);\n      }\n\n      // Compute the X position of the line.\n      let pos = x + size - 1;\n\n      // Draw the line if it's in range of the dirty rect.\n      if (pos >= rgn.xMin && pos <= rgn.xMax) {\n        // Render entire grid if scrolling merged cells grid\n        const extendLines = Private.shouldPaintEverything(this._dataModel!);\n        if (extendLines) {\n          for (const line of lines) {\n            // this._canvasGC.strokeStyle = color;\n            this._canvasGC.moveTo(pos + 0.5, line[0]);\n            this._canvasGC.lineTo(pos + 0.5, line[1]);\n          }\n        } else {\n          let y2 = Math.min(rgn.y + rgn.height, rgn.yMax + 1);\n          this._canvasGC.moveTo(pos + 0.5, y1);\n          this._canvasGC.lineTo(pos + 0.5, y2);\n        }\n      }\n\n      // Increment the running X coordinate.\n      x += size;\n    }\n\n    // Stroke the lines with the specified color.\n    this._canvasGC.strokeStyle = color;\n    this._canvasGC.stroke();\n  }\n\n  /**\n   * Draw the body selections for the data grid.\n   */\n  private _drawBodySelections(): void {\n    // Fetch the selection model.\n    let model = this._selectionModel;\n\n    // Bail early if there are no selections.\n    if (!model || model.isEmpty) {\n      return;\n    }\n\n    // Fetch the selection colors.\n    let fill = this._style.selectionFillColor;\n    let stroke = this._style.selectionBorderColor;\n\n    // Bail early if there is nothing to draw.\n    if (!fill && !stroke) {\n      return;\n    }\n\n    // Fetch the scroll geometry.\n    let sx = this._scrollX;\n    let sy = this._scrollY;\n\n    // Get the first visible cell of the grid.\n    let r1 = this._rowSections.indexOf(sy);\n    let c1 = this._columnSections.indexOf(sx);\n\n    // Bail early if there are no visible cells.\n    if (r1 < 0 || c1 < 0) {\n      return;\n    }\n\n    // Fetch the extra geometry.\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n    let pw = this.pageWidth;\n    let ph = this.pageHeight;\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n\n    // Get the last visible cell of the grid.\n    let r2 = this._rowSections.indexOf(sy + ph);\n    let c2 = this._columnSections.indexOf(sx + pw);\n\n    // Fetch the max row and column.\n    let maxRow = this._rowSections.count - 1;\n    let maxColumn = this._columnSections.count - 1;\n\n    // Clamp the last cell if the void space is visible.\n    r2 = r2 < 0 ? maxRow : r2;\n    c2 = c2 < 0 ? maxColumn : c2;\n\n    // Fetch the overlay gc.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Set up the body clipping rect.\n    gc.beginPath();\n    gc.rect(hw, hh, pw, ph);\n    gc.clip();\n\n    // Set up the gc style.\n    if (fill) {\n      gc.fillStyle = fill;\n    }\n    if (stroke) {\n      gc.strokeStyle = stroke;\n      gc.lineWidth = 1;\n    }\n\n    // Iterate over the selections.\n    let it = model.selections();\n    let s: SelectionModel.Selection | undefined;\n    while ((s = it.next()) !== undefined) {\n      // Skip the section if it's not visible.\n      if (s.r1 < r1 && s.r2 < r1) {\n        continue;\n      }\n      if (s.r1 > r2 && s.r2 > r2) {\n        continue;\n      }\n      if (s.c1 < c1 && s.c2 < c1) {\n        continue;\n      }\n      if (s.c1 > c2 && s.c2 > c2) {\n        continue;\n      }\n\n      // Clamp the cell to the model bounds.\n      let sr1 = Math.max(0, Math.min(s.r1, maxRow));\n      let sc1 = Math.max(0, Math.min(s.c1, maxColumn));\n      let sr2 = Math.max(0, Math.min(s.r2, maxRow));\n      let sc2 = Math.max(0, Math.min(s.c2, maxColumn));\n\n      // Swap index order if needed.\n      let tmp: number;\n      if (sr1 > sr2) {\n        tmp = sr1;\n        sr1 = sr2;\n        sr2 = tmp;\n      }\n      if (sc1 > sc2) {\n        tmp = sc1;\n        sc1 = sc2;\n        sc2 = tmp;\n      }\n\n      const joinedGroup = CellGroup.joinCellGroupWithMergedCellGroups(\n        this.dataModel!,\n        { r1: sr1, r2: sr2, c1: sc1, c2: sc2 },\n        'body'\n      );\n\n      sr1 = joinedGroup.r1;\n      sr2 = joinedGroup.r2;\n      sc1 = joinedGroup.c1;\n      sc2 = joinedGroup.c2;\n\n      // Convert to pixel coordinates.\n      let x1 = this._columnSections.offsetOf(sc1) - sx + hw;\n      let y1 = this._rowSections.offsetOf(sr1) - sy + hh;\n      let x2 = this._columnSections.extentOf(sc2) - sx + hw;\n      let y2 = this._rowSections.extentOf(sr2) - sy + hh;\n\n      // Adjust the trailing X coordinate for column stretch.\n      if (this._stretchLastColumn && pw > bw && sc2 === maxColumn) {\n        x2 = hw + pw - 1;\n      }\n\n      // Adjust the trailing Y coordinate for row stretch.\n      if (this._stretchLastRow && ph > bh && sr2 === maxRow) {\n        y2 = hh + ph - 1;\n      }\n\n      // Clamp the bounds to just outside of the clipping rect.\n      x1 = Math.max(hw - 1, x1);\n      y1 = Math.max(hh - 1, y1);\n      x2 = Math.min(hw + pw + 1, x2);\n      y2 = Math.min(hh + ph + 1, y2);\n\n      // Skip zero sized ranges.\n      if (x2 < x1 || y2 < y1) {\n        continue;\n      }\n\n      // Fill the rect if needed.\n      if (fill) {\n        gc.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n      }\n\n      // Stroke the rect if needed.\n      if (stroke) {\n        gc.strokeRect(x1 - 0.5, y1 - 0.5, x2 - x1 + 1, y2 - y1 + 1);\n      }\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  /**\n   * Draw the row header selections for the data grid.\n   */\n  private _drawRowHeaderSelections(): void {\n    // Fetch the selection model.\n    let model = this._selectionModel;\n\n    // Bail early if there are no selections or if the selectionMode is the entire column.\n    if (!model || model.isEmpty || model.selectionMode == 'column') {\n      return;\n    }\n\n    // Bail early if the row headers are not visible.\n    if (this.headerWidth === 0 || this.pageHeight === 0) {\n      return;\n    }\n\n    // Fetch the selection colors.\n    let fill = this._style.headerSelectionFillColor;\n    let stroke = this._style.headerSelectionBorderColor;\n\n    // Bail early if there is nothing to draw.\n    if (!fill && !stroke) {\n      return;\n    }\n\n    // Fetch common geometry.\n    let sy = this._scrollY;\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n    let rs = this._rowSections;\n\n    // Fetch the overlay gc.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Set up the header clipping rect.\n    gc.beginPath();\n    gc.rect(0, hh, hw, ph);\n    gc.clip();\n\n    // Set up the gc style.\n    if (fill) {\n      gc.fillStyle = fill;\n    }\n    if (stroke) {\n      gc.strokeStyle = stroke;\n      gc.lineWidth = 1;\n    }\n\n    // Fetch the max row.\n    let maxRow = rs.count - 1;\n\n    // Fetch the visible rows.\n    let r1 = rs.indexOf(sy);\n    let r2 = rs.indexOf(sy + ph - 1);\n    r2 = r2 < 0 ? maxRow : r2;\n\n    // Iterate over the visible rows.\n    for (let j = r1; j <= r2; ++j) {\n      // Skip rows which aren't selected.\n      if (!model.isRowSelected(j)) {\n        continue;\n      }\n\n      // Get the dimensions of the row.\n      let y = rs.offsetOf(j) - sy + hh;\n      let h = rs.sizeOf(j);\n\n      // Adjust the height for row stretch.\n      if (this._stretchLastRow && ph > bh && j === maxRow) {\n        h = hh + ph - y;\n      }\n\n      // Skip zero sized rows.\n      if (h === 0) {\n        continue;\n      }\n\n      // Fill the rect if needed.\n      if (fill) {\n        gc.fillRect(0, y, hw, h);\n      }\n\n      // Draw the border if needed.\n      if (stroke) {\n        gc.beginPath();\n        gc.moveTo(hw - 0.5, y - 1);\n        gc.lineTo(hw - 0.5, y + h);\n        gc.stroke();\n      }\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  /**\n   * Draw the column header selections for the data grid.\n   */\n  private _drawColumnHeaderSelections(): void {\n    // Fetch the selection model.\n    let model = this._selectionModel;\n\n    // Bail early if there are no selections or if the selectionMode is the entire row\n    if (!model || model.isEmpty || model.selectionMode == 'row') {\n      return;\n    }\n\n    // Bail early if the column headers are not visible.\n    if (this.headerHeight === 0 || this.pageWidth === 0) {\n      return;\n    }\n\n    // Fetch the selection colors.\n    let fill = this._style.headerSelectionFillColor;\n    let stroke = this._style.headerSelectionBorderColor;\n\n    // Bail early if there is nothing to draw.\n    if (!fill && !stroke) {\n      return;\n    }\n\n    // Fetch common geometry.\n    let sx = this._scrollX;\n    let bw = this.bodyWidth;\n    let pw = this.pageWidth;\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n    let cs = this._columnSections;\n\n    // Fetch the overlay gc.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Set up the header clipping rect.\n    gc.beginPath();\n    gc.rect(hw, 0, pw, hh);\n    gc.clip();\n\n    // Set up the gc style.\n    if (fill) {\n      gc.fillStyle = fill;\n    }\n    if (stroke) {\n      gc.strokeStyle = stroke;\n      gc.lineWidth = 1;\n    }\n\n    // Fetch the max column.\n    let maxCol = cs.count - 1;\n\n    // Fetch the visible columns.\n    let c1 = cs.indexOf(sx);\n    let c2 = cs.indexOf(sx + pw - 1);\n    c2 = c2 < 0 ? maxCol : c2;\n\n    // Iterate over the visible columns.\n    for (let i = c1; i <= c2; ++i) {\n      // Skip columns which aren't selected.\n      if (!model.isColumnSelected(i)) {\n        continue;\n      }\n\n      // Get the dimensions of the column.\n      let x = cs.offsetOf(i) - sx + hw;\n      let w = cs.sizeOf(i);\n\n      // Adjust the width for column stretch.\n      if (this._stretchLastColumn && pw > bw && i === maxCol) {\n        w = hw + pw - x;\n      }\n\n      // Skip zero sized columns.\n      if (w === 0) {\n        continue;\n      }\n\n      // Fill the rect if needed.\n      if (fill) {\n        gc.fillRect(x, 0, w, hh);\n      }\n\n      // Draw the border if needed.\n      if (stroke) {\n        gc.beginPath();\n        gc.moveTo(x - 1, hh - 0.5);\n        gc.lineTo(x + w, hh - 0.5);\n        gc.stroke();\n      }\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  /**\n   * Draw the overlay cursor for the data grid.\n   */\n  private _drawCursor(): void {\n    // Fetch the selection model.\n    let model = this._selectionModel;\n\n    // Bail early if there is no cursor.\n    if (!model || model.isEmpty || model.selectionMode !== 'cell') {\n      return;\n    }\n\n    // Extract the style information.\n    let fill = this._style.cursorFillColor;\n    let stroke = this._style.cursorBorderColor;\n\n    // Bail early if there is nothing to draw.\n    if (!fill && !stroke) {\n      return;\n    }\n\n    // Fetch the cursor location.\n    let startRow = model.cursorRow;\n    let startColumn = model.cursorColumn;\n\n    // Fetch the max row and column.\n    let maxRow = this._rowSections.count - 1;\n    let maxColumn = this._columnSections.count - 1;\n\n    // Bail early if the cursor is out of bounds.\n    if (startRow < 0 || startRow > maxRow) {\n      return;\n    }\n    if (startColumn < 0 || startColumn > maxColumn) {\n      return;\n    }\n\n    let endRow = startRow;\n    let endColumn = startColumn;\n\n    const joinedGroup = CellGroup.joinCellGroupWithMergedCellGroups(\n      this.dataModel!,\n      { r1: startRow, r2: endRow, c1: startColumn, c2: endColumn },\n      'body'\n    );\n\n    startRow = joinedGroup.r1;\n    endRow = joinedGroup.r2;\n    startColumn = joinedGroup.c1;\n    endColumn = joinedGroup.c2;\n\n    // Fetch geometry.\n    let sx = this._scrollX;\n    let sy = this._scrollY;\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n    let pw = this.pageWidth;\n    let ph = this.pageHeight;\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // Get the cursor bounds in viewport coordinates.\n    let x1 = this._columnSections.offsetOf(startColumn) - sx + hw;\n    let x2 = this._columnSections.extentOf(endColumn) - sx + hw;\n    let y1 = this._rowSections.offsetOf(startRow) - sy + hh;\n    let y2 = this._rowSections.extentOf(endRow) - sy + hh;\n\n    // Adjust the trailing X coordinate for column stretch.\n    if (this._stretchLastColumn && pw > bw && startColumn === maxColumn) {\n      x2 = vw - 1;\n    }\n\n    // Adjust the trailing Y coordinate for row stretch.\n    if (this._stretchLastRow && ph > bh && startRow === maxRow) {\n      y2 = vh - 1;\n    }\n\n    // Skip zero sized cursors.\n    if (x2 < x1 || y2 < y1) {\n      return;\n    }\n\n    // Bail early if the cursor is off the screen.\n    if (x1 - 1 >= vw || y1 - 1 >= vh || x2 + 1 < hw || y2 + 1 < hh) {\n      return;\n    }\n\n    // Fetch the overlay gc.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Set up the body clipping rect.\n    gc.beginPath();\n    gc.rect(hw, hh, pw, ph);\n    gc.clip();\n\n    // Clear any existing overlay content.\n    gc.clearRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n\n    // Fill the cursor rect if needed.\n    if (fill) {\n      // Set up the fill style.\n      gc.fillStyle = fill;\n\n      // Fill the cursor rect.\n      gc.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n    }\n\n    // Stroke the cursor border if needed.\n    if (stroke) {\n      // Set up the stroke style.\n      gc.strokeStyle = stroke;\n      gc.lineWidth = 2;\n\n      // Stroke the cursor rect.\n      gc.strokeRect(x1, y1, x2 - x1, y2 - y1);\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  /**\n   * Draw the overlay shadows for the data grid.\n   */\n  private _drawShadows(): void {\n    // Fetch the scroll shadow from the style.\n    let shadow = this._style.scrollShadow;\n\n    // Bail early if there is no shadow to draw.\n    if (!shadow) {\n      return;\n    }\n\n    // Fetch the scroll position.\n    let sx = this._scrollX;\n    let sy = this._scrollY;\n\n    // Fetch maximum scroll position.\n    let sxMax = this.maxScrollX;\n    let syMax = this.maxScrollY;\n\n    // Fetch the header width and height.\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n\n    // Fetch the page width and height.\n    let pw = this.pageWidth;\n    let ph = this.pageHeight;\n\n    // Fetch the viewport width and height.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // Fetch the body width and height.\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n\n    // Adjust the body size for row and column stretch.\n    if (this._stretchLastRow && ph > bh) {\n      bh = ph;\n    }\n    if (this._stretchLastColumn && pw > bw) {\n      bw = pw;\n    }\n\n    // Fetch the gc object.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Draw the column header shadow if needed.\n    if (sy > 0) {\n      // Set up the gradient coordinates.\n      let x0 = 0;\n      let y0 = hh;\n      let x1 = 0;\n      let y1 = y0 + shadow.size;\n\n      // Create the gradient object.\n      let grad = gc.createLinearGradient(x0, y0, x1, y1);\n\n      // Set the gradient stops.\n      grad.addColorStop(0, shadow.color1);\n      grad.addColorStop(0.5, shadow.color2);\n      grad.addColorStop(1, shadow.color3);\n\n      // Set up the rect coordinates.\n      let x = 0;\n      let y = hh;\n      let w = hw + Math.min(pw, bw - sx);\n      let h = shadow.size;\n\n      // Fill the shadow rect with the fill style.\n      gc.fillStyle = grad;\n      gc.fillRect(x, y, w, h);\n    }\n\n    // Draw the row header shadow if needed.\n    if (sx > 0) {\n      // Set up the gradient coordinates.\n      let x0 = hw;\n      let y0 = 0;\n      let x1 = x0 + shadow.size;\n      let y1 = 0;\n\n      // Create the gradient object.\n      let grad = gc.createLinearGradient(x0, y0, x1, y1);\n\n      // Set the gradient stops.\n      grad.addColorStop(0, shadow.color1);\n      grad.addColorStop(0.5, shadow.color2);\n      grad.addColorStop(1, shadow.color3);\n\n      // Set up the rect coordinates.\n      let x = hw;\n      let y = 0;\n      let w = shadow.size;\n      let h = hh + Math.min(ph, bh - sy);\n\n      // Fill the shadow rect with the fill style.\n      gc.fillStyle = grad;\n      gc.fillRect(x, y, w, h);\n    }\n\n    // Draw the column footer shadow if needed.\n    if (sy < syMax) {\n      // Set up the gradient coordinates.\n      let x0 = 0;\n      let y0 = vh;\n      let x1 = 0;\n      let y1 = vh - shadow.size;\n\n      // Create the gradient object.\n      let grad = gc.createLinearGradient(x0, y0, x1, y1);\n\n      // Set the gradient stops.\n      grad.addColorStop(0, shadow.color1);\n      grad.addColorStop(0.5, shadow.color2);\n      grad.addColorStop(1, shadow.color3);\n\n      // Set up the rect coordinates.\n      let x = 0;\n      let y = vh - shadow.size;\n      let w = hw + Math.min(pw, bw - sx);\n      let h = shadow.size;\n\n      // Fill the shadow rect with the fill style.\n      gc.fillStyle = grad;\n      gc.fillRect(x, y, w, h);\n    }\n\n    // Draw the row footer shadow if needed.\n    if (sx < sxMax) {\n      // Set up the gradient coordinates.\n      let x0 = vw;\n      let y0 = 0;\n      let x1 = vw - shadow.size;\n      let y1 = 0;\n\n      // Create the gradient object.\n      let grad = gc.createLinearGradient(x0, y0, x1, y1);\n\n      // Set the gradient stops.\n      grad.addColorStop(0, shadow.color1);\n      grad.addColorStop(0.5, shadow.color2);\n      grad.addColorStop(1, shadow.color3);\n\n      // Set up the rect coordinates.\n      let x = vw - shadow.size;\n      let y = 0;\n      let w = shadow.size;\n      let h = hh + Math.min(ph, bh - sy);\n\n      // Fill the shadow rect with the fill style.\n      gc.fillStyle = grad;\n      gc.fillRect(x, y, w, h);\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  private _viewport: Widget;\n  private _vScrollBar: ScrollBar;\n  private _hScrollBar: ScrollBar;\n  private _scrollCorner: Widget;\n\n  private _scrollX = 0;\n  private _scrollY = 0;\n  private _viewportWidth = 0;\n  private _viewportHeight = 0;\n\n  private _mousedown = false;\n  private _keyHandler: DataGrid.IKeyHandler | null = null;\n  private _mouseHandler: DataGrid.IMouseHandler | null = null;\n\n  private _vScrollBarMinWidth = 0;\n  private _hScrollBarMinHeight = 0;\n  private _dpiRatio = Math.ceil(window.devicePixelRatio);\n\n  private _canvas: HTMLCanvasElement;\n  private _buffer: HTMLCanvasElement;\n  private _overlay: HTMLCanvasElement;\n  private _canvasGC: CanvasRenderingContext2D;\n  private _bufferGC: CanvasRenderingContext2D;\n  private _overlayGC: CanvasRenderingContext2D;\n\n  private _rowSections: SectionList;\n  private _columnSections: SectionList;\n  private _rowHeaderSections: SectionList;\n  private _columnHeaderSections: SectionList;\n\n  private _dataModel: DataModel | null = null;\n  private _selectionModel: SelectionModel | null = null;\n\n  private _stretchLastRow: boolean;\n  private _stretchLastColumn: boolean;\n\n  private _style: DataGrid.Style;\n  private _cellRenderers: RendererMap;\n  private _copyConfig: DataGrid.CopyConfig;\n  private _headerVisibility: DataGrid.HeaderVisibility;\n  private _editorController: ICellEditorController | null;\n  private _editingEnabled: boolean = false;\n}\n\n/**\n * The namespace for the `DataGrid` class statics.\n */\nexport namespace DataGrid {\n  /**\n   * An object which defines the style for a data grid.\n   *\n   * #### Notes\n   * All style colors support the full CSS color syntax.\n   */\n  export type Style = {\n    /**\n     * The void color for the data grid.\n     *\n     * This is the base fill color for the entire data grid.\n     */\n    readonly voidColor?: string;\n\n    /**\n     * The background color for the body cells.\n     *\n     * This color is layered on top of the `voidColor`.\n     */\n    readonly backgroundColor?: string;\n\n    /**\n     * A function which returns the background color for a row.\n     *\n     * This color is layered on top of the `backgroundColor` and can\n     * be used to implement \"zebra striping\" of the grid rows.\n     */\n    readonly rowBackgroundColor?: (index: number) => string;\n\n    /**\n     * A function which returns the background color for a column.\n     *\n     * This color is layered on top of the `backgroundColor` and can\n     * be used to implement \"zebra striping\" of the grid columns.\n     */\n    readonly columnBackgroundColor?: (index: number) => string;\n\n    /**\n     * The color for the grid lines of the body cells.\n     *\n     * The grid lines are draw on top of the cell contents.\n     */\n    readonly gridLineColor?: string;\n\n    /**\n     * The color for the vertical grid lines of the body cells.\n     *\n     * This overrides the `gridLineColor` option.\n     */\n    readonly verticalGridLineColor?: string;\n\n    /**\n     * The color for the horizontal grid lines of the body cells.\n     *\n     * This overrides the `gridLineColor` option.\n     */\n    readonly horizontalGridLineColor?: string;\n\n    /**\n     * The background color for the header cells.\n     *\n     * This color is layered on top of the `voidColor`.\n     */\n    readonly headerBackgroundColor?: string;\n\n    /**\n     * The color for the grid lines of the header cells.\n     *\n     * The grid lines are draw on top of the cell contents.\n     */\n    readonly headerGridLineColor?: string;\n\n    /**\n     * The color for the vertical grid lines of the header cells.\n     *\n     * This overrides the `headerGridLineColor` option.\n     */\n    readonly headerVerticalGridLineColor?: string;\n\n    /**\n     * The color for the horizontal grid lines of the header cells.\n     *\n     * This overrides the `headerGridLineColor` option.\n     */\n    readonly headerHorizontalGridLineColor?: string;\n\n    /**\n     * The fill color for a selection.\n     */\n    readonly selectionFillColor?: string;\n\n    /**\n     * The border color for a selection.\n     */\n    readonly selectionBorderColor?: string;\n\n    /**\n     * The fill color for the cursor.\n     */\n    readonly cursorFillColor?: string;\n\n    /**\n     * The border color for the cursor.\n     */\n    readonly cursorBorderColor?: string;\n\n    /**\n     * The fill color for a header selection.\n     */\n    readonly headerSelectionFillColor?: string;\n\n    /**\n     * The border color for a header selection.\n     */\n    readonly headerSelectionBorderColor?: string;\n\n    /**\n     * The drop shadow effect when the grid is scrolled.\n     */\n    readonly scrollShadow?: {\n      /**\n       * The size of the shadow, in pixels.\n       */\n      readonly size: number;\n\n      /**\n       * The first color stop for the shadow.\n       */\n      readonly color1: string;\n\n      /**\n       * The second color stop for the shadow.\n       */\n      readonly color2: string;\n\n      /**\n       * The third color stop for the shadow.\n       */\n      readonly color3: string;\n    };\n  };\n\n  /**\n   * An object which defines the default sizes for a data grid.\n   */\n  export type DefaultSizes = {\n    /**\n     * The default height of a row.\n     */\n    readonly rowHeight: number;\n\n    /**\n     * The default width of a column.\n     */\n    readonly columnWidth: number;\n\n    /**\n     * The default width of a row header.\n     */\n    readonly rowHeaderWidth: number;\n\n    /**\n     * The default height of a column header.\n     */\n    readonly columnHeaderHeight: number;\n  };\n\n  /**\n   * An object which defines the minimum sizes for a data grid.\n   */\n  export type MinimumSizes = {\n    /**\n     * The minimum height of a row.\n     */\n    readonly rowHeight: number;\n\n    /**\n     * The minimum width of a column.\n     */\n    readonly columnWidth: number;\n\n    /**\n     * The minimum width of a row header.\n     */\n    readonly rowHeaderWidth: number;\n\n    /**\n     * The minimum height of a column header.\n     */\n    readonly columnHeaderHeight: number;\n  };\n\n  /**\n   * A type alias for the supported header visibility modes.\n   */\n  export type HeaderVisibility = 'all' | 'row' | 'column' | 'none';\n\n  /**\n   * A type alias for the supported column auto resize modes.\n   */\n  export type ColumnFitType = 'all' | 'row-header' | 'body';\n\n  /**\n   * A type alias for the arguments to a copy format function.\n   */\n  export type CopyFormatArgs = {\n    /**\n     * The cell region for the value.\n     */\n    region: DataModel.CellRegion;\n\n    /**\n     * The row index of the value.\n     */\n    row: number;\n\n    /**\n     * The column index of the value.\n     */\n    column: number;\n\n    /**\n     * The value for the cell.\n     */\n    value: any;\n\n    /**\n     * The metadata for the cell.\n     */\n    metadata: DataModel.Metadata;\n  };\n\n  /**\n   * A type alias for a copy format function.\n   */\n  export type CopyFormatFunc = (args: CopyFormatArgs) => string;\n\n  /**\n   * A type alias for the data grid copy config.\n   */\n  export type CopyConfig = {\n    /**\n     * The separator to use between values.\n     */\n    readonly separator: string;\n\n    /**\n     * The headers to included in the copied output.\n     */\n    readonly headers: 'none' | 'row' | 'column' | 'all';\n\n    /**\n     * The function for formatting the data values.\n     */\n    readonly format: CopyFormatFunc;\n\n    /**\n     * The cell count threshold for a copy to be considered \"large\".\n     */\n    readonly warningThreshold: number;\n  };\n\n  /**\n   * An options object for initializing a data grid.\n   */\n  export interface IOptions {\n    /**\n     * The style for the data grid.\n     *\n     * The default is `DataGrid.defaultStyle`.\n     */\n    style?: Style;\n\n    /**\n     * The default sizes for the data grid.\n     *\n     * The default is `DataGrid.defaultSizes`.\n     */\n    defaultSizes?: DefaultSizes;\n\n    /**\n     * The minimum sizes for the data grid.\n     *\n     * The default is `DataGrid.minimumSizes`.\n     */\n    minimumSizes?: MinimumSizes;\n\n    /**\n     * The header visibility for the data grid.\n     *\n     * The default is `'all'`.\n     */\n    headerVisibility?: HeaderVisibility;\n\n    /**\n     * The cell renderer map for the data grid.\n     *\n     * The default is an empty renderer map.\n     */\n    cellRenderers?: RendererMap;\n\n    /**\n     * The default cell renderer for the data grid.\n     *\n     * The default is a new `TextRenderer`.\n     */\n    defaultRenderer?: CellRenderer;\n\n    /**\n     * The copy configuration data for the grid.\n     *\n     * The default is `DataGrid.defaultCopyConfig`.\n     */\n    copyConfig?: CopyConfig;\n\n    /**\n     * Whether to stretch the last row of the grid.\n     *\n     * The default is `false`.\n     */\n    stretchLastRow?: boolean;\n\n    /**\n     * Whether to stretch the last column of the grid.\n     *\n     * The default is `false`.\n     */\n    stretchLastColumn?: boolean;\n  }\n\n  /**\n   * An object which handles keydown events for the data grid.\n   */\n  export interface IKeyHandler extends IDisposable {\n    /**\n     * Handle the key down event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keydown event of interest.\n     *\n     * #### Notes\n     * This will not be called if the mouse button is pressed.\n     */\n    onKeyDown(grid: DataGrid, event: KeyboardEvent): void;\n  }\n\n  /**\n   * An object which handles mouse events for the data grid.\n   */\n  export interface IMouseHandler extends IDisposable {\n    /**\n     * Release any resources acquired during a mouse press.\n     *\n     * #### Notes\n     * This method is called when the mouse should be released\n     * independent of a mouseup event, such as an early detach.\n     */\n    release(): void;\n\n    /**\n     * Handle the mouse hover event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse hover event of interest.\n     */\n    onMouseHover(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse leave event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse hover event of interest.\n     */\n    onMouseLeave(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse down event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse down event of interest.\n     */\n    onMouseDown(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse move event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse move event of interest.\n     */\n    onMouseMove(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse up event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse up event of interest.\n     */\n    onMouseUp(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse double click event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse double click event of interest.\n     */\n    onMouseDoubleClick(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the context menu event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The context menu event of interest.\n     */\n    onContextMenu(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the wheel event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The wheel event of interest.\n     */\n    onWheel(grid: DataGrid, event: WheelEvent): void;\n  }\n\n  /**\n   * An object which holds the result of a grid hit test.\n   */\n  export type HitTestResult = {\n    /**\n     * The region of the data grid that was hit.\n     */\n    readonly region: DataModel.CellRegion | 'void';\n\n    /**\n     * The row index of the cell that was hit.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly row: number;\n\n    /**\n     * The column index of the cell that was hit.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly column: number;\n\n    /**\n     * The X coordinate of the mouse in cell coordinates.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly x: number;\n\n    /**\n     * The Y coordinate of the mouse in cell coordinates.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly y: number;\n\n    /**\n     * The width of the cell.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly width: number;\n\n    /**\n     * The height of the cell.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly height: number;\n  };\n\n  /**\n   * A generic format function for the copy handler.\n   *\n   * @param args - The format args for the function.\n   *\n   * @returns The string representation of the value.\n   *\n   * #### Notes\n   * This function uses `String()` to coerce a value to a string.\n   */\n  export function copyFormatGeneric(args: CopyFormatArgs): string {\n    if (args.value === null || args.value === undefined) {\n      return '';\n    }\n    return String(args.value);\n  }\n\n  /**\n   * The default theme for a data grid.\n   */\n  export const defaultStyle: Style = {\n    voidColor: '#F3F3F3',\n    backgroundColor: '#FFFFFF',\n    gridLineColor: 'rgba(20, 20, 20, 0.15)',\n    headerBackgroundColor: '#F3F3F3',\n    headerGridLineColor: 'rgba(20, 20, 20, 0.25)',\n    selectionFillColor: 'rgba(49, 119, 229, 0.2)',\n    selectionBorderColor: 'rgba(0, 107, 247, 1.0)',\n    cursorBorderColor: 'rgba(0, 107, 247, 1.0)',\n    headerSelectionFillColor: 'rgba(20, 20, 20, 0.1)',\n    headerSelectionBorderColor: 'rgba(0, 107, 247, 1.0)',\n    scrollShadow: {\n      size: 10,\n      color1: 'rgba(0, 0, 0, 0.20)',\n      color2: 'rgba(0, 0, 0, 0.05)',\n      color3: 'rgba(0, 0, 0, 0.00)'\n    }\n  };\n\n  /**\n   * The default sizes for a data grid.\n   */\n  export const defaultSizes: DefaultSizes = {\n    rowHeight: 20,\n    columnWidth: 64,\n    rowHeaderWidth: 64,\n    columnHeaderHeight: 20\n  };\n\n  /**\n   * The default minimum sizes for a data grid.\n   */\n  export const minimumSizes: MinimumSizes = {\n    rowHeight: 20,\n    columnWidth: 10,\n    rowHeaderWidth: 10,\n    columnHeaderHeight: 20\n  };\n\n  /**\n   * The default copy config for a data grid.\n   */\n  export const defaultCopyConfig: CopyConfig = {\n    separator: '\\t',\n    format: copyFormatGeneric,\n    headers: 'none',\n    warningThreshold: 1e6\n  };\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * A singleton `scroll-request` conflatable message.\n   */\n  export const ScrollRequest = new ConflatableMessage('scroll-request');\n\n  /**\n   * A singleton `overlay-paint-request` conflatable message.\n   */\n  export const OverlayPaintRequest = new ConflatableMessage(\n    'overlay-paint-request'\n  );\n\n  /**\n   * Create a new zero-sized canvas element.\n   */\n  export function createCanvas(): HTMLCanvasElement {\n    let canvas = document.createElement('canvas');\n    canvas.width = 0;\n    canvas.height = 0;\n    return canvas;\n  }\n\n  /**\n   * A function to check whether the entire grid should be rendered\n   * when dealing with merged cell regions.\n   * @param dataModel grid's data model.\n   * @returns boolean.\n   */\n  export function shouldPaintEverything(dataModel: DataModel): boolean {\n    const colGroups = CellGroup.getCellGroupsAtRegion(\n      dataModel!,\n      'column-header'\n    );\n    const rowHeaderGroups = CellGroup.getCellGroupsAtRegion(\n      dataModel!,\n      'row-header'\n    );\n    const cornerHeaderGroups = CellGroup.getCellGroupsAtRegion(\n      dataModel!,\n      'corner-header'\n    );\n    const bodyGroups = CellGroup.getCellGroupsAtRegion(dataModel!, 'body');\n    return (\n      colGroups.length > 0 ||\n      rowHeaderGroups.length > 0 ||\n      cornerHeaderGroups.length > 0 ||\n      bodyGroups.length > 0\n    );\n  }\n\n  /**\n   * Checks whether a given regions has merged cells in it.\n   * @param dataModel grid's data model.\n   * @param region the paint region to be checked.\n   * @returns boolean.\n   */\n  export function regionHasMergedCells(\n    dataModel: DataModel,\n    region: DataModel.CellRegion\n  ): boolean {\n    const regionGroups = CellGroup.getCellGroupsAtRegion(dataModel!, region);\n    return regionGroups.length > 0;\n  }\n\n  /**\n   * An object which represents a region to be painted.\n   */\n  export type PaintRegion = {\n    /**\n     * The min X coordinate the of the dirty viewport rect.\n     *\n     * #### Notes\n     * The data grid must not draw outside of this boundary.\n     */\n    xMin: number;\n\n    /**\n     * The min Y coordinate the of the dirty viewport rect.\n     *\n     * #### Notes\n     * The data grid must not draw outside of this boundary.\n     */\n    yMin: number;\n\n    /**\n     * The max X coordinate the of the dirty viewport rect.\n     *\n     * #### Notes\n     * The data grid must not draw outside of this boundary.\n     */\n    xMax: number;\n\n    /**\n     * The max Y coordinate the of the dirty viewport rect.\n     *\n     * #### Notes\n     * The data grid must not draw outside of this boundary.\n     */\n    yMax: number;\n\n    /**\n     * The X coordinate the of the region, in viewport coordinates.\n     *\n     * #### Notes\n     * This is aligned to the first cell boundary.\n     */\n    x: number;\n\n    /**\n     * The Y coordinate the of the region, in viewport coordinates.\n     *\n     * #### Notes\n     * This is aligned to the first cell boundary.\n     */\n    y: number;\n\n    /**\n     * The total width of the region.\n     *\n     * #### Notes\n     * This is aligned to the cell boundaries.\n     */\n    width: number;\n\n    /**\n     * The total height of the region.\n     *\n     * #### Notes\n     * This is aligned to the cell boundaries.\n     */\n    height: number;\n\n    /**\n     * The cell region being painted.\n     */\n    region: DataModel.CellRegion;\n\n    /**\n     * The row index of the first cell in the region.\n     */\n    row: number;\n\n    /**\n     * The column index of the first cell in the region.\n     */\n    column: number;\n\n    /**\n     * The row sizes for the rows in the region.\n     */\n    rowSizes: number[];\n\n    /**\n     * The column sizes for the columns in the region.\n     */\n    columnSizes: number[];\n  };\n\n  /**\n   * A conflatable message which merges dirty paint regions.\n   */\n  export class PaintRequest extends ConflatableMessage {\n    /**\n     * Construct a new paint request messages.\n     *\n     * @param region - The cell region for the paint.\n     *\n     * @param r1 - The top-left row of the dirty region.\n     *\n     * @param c1 - The top-left column of the dirty region.\n     *\n     * @param r2 - The bottom-right row of the dirty region.\n     *\n     * @param c2 - The bottom-right column of the dirty region.\n     */\n    constructor(\n      region: DataModel.CellRegion | 'all',\n      r1: number,\n      c1: number,\n      r2: number,\n      c2: number\n    ) {\n      super('paint-request');\n      this._region = region;\n      this._r1 = r1;\n      this._c1 = c1;\n      this._r2 = r2;\n      this._c2 = c2;\n    }\n\n    /**\n     * The cell region for the paint.\n     */\n    get region(): DataModel.CellRegion | 'all' {\n      return this._region;\n    }\n\n    /**\n     * The top-left row of the dirty region.\n     */\n    get r1(): number {\n      return this._r1;\n    }\n\n    /**\n     * The top-left column of the dirty region.\n     */\n    get c1(): number {\n      return this._c1;\n    }\n\n    /**\n     * The bottom-right row of the dirty region.\n     */\n    get r2(): number {\n      return this._r2;\n    }\n\n    /**\n     * The bottom-right column of the dirty region.\n     */\n    get c2(): number {\n      return this._c2;\n    }\n\n    /**\n     * Conflate this message with another paint request.\n     */\n    conflate(other: PaintRequest): boolean {\n      // Bail early if the request is already painting everything.\n      if (this._region === 'all') {\n        return true;\n      }\n\n      // Any region can conflate with the `'all'` region.\n      if (other._region === 'all') {\n        this._region = 'all';\n        return true;\n      }\n\n      // Otherwise, do not conflate with a different region.\n      if (this._region !== other._region) {\n        return false;\n      }\n\n      // Conflate the region to the total boundary.\n      this._r1 = Math.min(this._r1, other._r1);\n      this._c1 = Math.min(this._c1, other._c1);\n      this._r2 = Math.max(this._r2, other._r2);\n      this._c2 = Math.max(this._c2, other._c2);\n      return true;\n    }\n\n    private _region: DataModel.CellRegion | 'all';\n    private _r1: number;\n    private _c1: number;\n    private _r2: number;\n    private _c2: number;\n  }\n\n  /**\n   * A conflatable message for resizing rows.\n   */\n  export class RowResizeRequest extends ConflatableMessage {\n    /**\n     * Construct a new row resize request.\n     *\n     * @param region - The row region which holds the section.\n     *\n     * @param index - The index of row in the region.\n     *\n     * @param size - The target size of the section.\n     */\n    constructor(region: DataModel.RowRegion, index: number, size: number) {\n      super('row-resize-request');\n      this._region = region;\n      this._index = index;\n      this._size = size;\n    }\n\n    /**\n     * The row region which holds the section.\n     */\n    get region(): DataModel.RowRegion {\n      return this._region;\n    }\n\n    /**\n     * The index of the row in the region.\n     */\n    get index(): number {\n      return this._index;\n    }\n\n    /**\n     * The target size of the section.\n     */\n    get size(): number {\n      return this._size;\n    }\n\n    /**\n     * Conflate this message with another row resize request.\n     */\n    conflate(other: RowResizeRequest): boolean {\n      if (this._region !== other._region || this._index !== other._index) {\n        return false;\n      }\n      this._size = other._size;\n      return true;\n    }\n\n    private _region: DataModel.RowRegion;\n    private _index: number;\n    private _size: number;\n  }\n\n  /**\n   * A conflatable message for resizing columns.\n   */\n  export class ColumnResizeRequest extends ConflatableMessage {\n    /**\n     * Construct a new column resize request.\n     *\n     * @param region - The column region which holds the section.\n     *\n     * @param index - The index of column in the region.\n     *\n     * @param size - The target size of the section.\n     */\n    constructor(region: DataModel.ColumnRegion, index: number, size: number) {\n      super('column-resize-request');\n      this._region = region;\n      this._index = index;\n      this._size = size;\n    }\n\n    /**\n     * The column region which holds the section.\n     */\n    get region(): DataModel.ColumnRegion {\n      return this._region;\n    }\n\n    /**\n     * The index of the column in the region.\n     */\n    get index(): number {\n      return this._index;\n    }\n\n    /**\n     * The target size of the section.\n     */\n    get size(): number {\n      return this._size;\n    }\n\n    /**\n     * Conflate this message with another column resize request.\n     */\n    conflate(other: ColumnResizeRequest): boolean {\n      if (this._region !== other._region || this._index !== other._index) {\n        return false;\n      }\n      this._size = other._size;\n      return true;\n    }\n\n    private _region: DataModel.ColumnRegion;\n    private _index: number;\n    private _size: number;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ReadonlyJSONObject } from '@lumino/coreutils';\n\nimport { DataModel } from './datamodel';\n\n/**\n * A data model implementation for in-memory JSON data.\n */\nexport class JSONModel extends DataModel {\n  /**\n   * Create a data model with static JSON data.\n   *\n   * @param options - The options for initializing the data model.\n   */\n  constructor(options: JSONModel.IOptions) {\n    super();\n    let split = Private.splitFields(options.schema);\n    this._data = options.data;\n    this._bodyFields = split.bodyFields;\n    this._headerFields = split.headerFields;\n    this._missingValues = Private.createMissingMap(options.schema);\n  }\n\n  /**\n   * Get the row count for a region in the data model.\n   *\n   * @param region - The row region of interest.\n   *\n   * @returns - The row count for the region.\n   */\n  rowCount(region: DataModel.RowRegion): number {\n    if (region === 'body') {\n      return this._data.length;\n    }\n    return 1; // TODO multiple column-header rows?\n  }\n\n  /**\n   * Get the column count for a region in the data model.\n   *\n   * @param region - The column region of interest.\n   *\n   * @returns - The column count for the region.\n   */\n  columnCount(region: DataModel.ColumnRegion): number {\n    if (region === 'body') {\n      return this._bodyFields.length;\n    }\n    return this._headerFields.length;\n  }\n\n  /**\n   * Get the data value for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns - The data value for the specified cell.\n   *\n   * #### Notes\n   * A `missingValue` as defined by the schema is converted to `null`.\n   */\n  data(region: DataModel.CellRegion, row: number, column: number): any {\n    // Set up the field and value variables.\n    let field: JSONModel.Field;\n    let value: any;\n\n    // Look up the field and value for the region.\n    switch (region) {\n      case 'body':\n        field = this._bodyFields[column];\n        value = this._data[row][field.name];\n        break;\n      case 'column-header':\n        field = this._bodyFields[column];\n        value = field.title || field.name;\n        break;\n      case 'row-header':\n        field = this._headerFields[column];\n        value = this._data[row][field.name];\n        break;\n      case 'corner-header':\n        field = this._headerFields[column];\n        value = field.title || field.name;\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Test whether the value is a missing value.\n    let missing =\n      this._missingValues !== null &&\n      typeof value === 'string' &&\n      this._missingValues[value] === true;\n\n    // Return the final value.\n    return missing ? null : value;\n  }\n\n  /**\n   * Get the metadata for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns The metadata for the cell.\n   */\n  metadata(\n    region: DataModel.CellRegion,\n    row: number,\n    column: number\n  ): DataModel.Metadata {\n    if (region === 'body' || region === 'column-header') {\n      return this._bodyFields[column];\n    }\n    return this._headerFields[column];\n  }\n\n  private _data: JSONModel.DataSource;\n  private _bodyFields: JSONModel.Field[];\n  private _headerFields: JSONModel.Field[];\n  private _missingValues: Private.MissingValuesMap | null;\n}\n\n/**\n * The namespace for the `JSONModel` class statics.\n */\nexport namespace JSONModel {\n  /**\n   * An object which describes a column of data in the model.\n   *\n   * #### Notes\n   * This is based on the JSON Table Schema specification:\n   * https://specs.frictionlessdata.io/table-schema/\n   */\n  export type Field = {\n    /**\n     * The name of the column.\n     *\n     * This is used as the key to extract a value from a data record.\n     * It is also used as the column header label, unless the `title`\n     * property is provided.\n     */\n    readonly name: string;\n\n    /**\n     * The type of data held in the column.\n     */\n    readonly type?: string;\n\n    /**\n     * The format of the data in the column.\n     */\n    readonly format?: string;\n\n    /**\n     * The human readable name for the column.\n     *\n     * This is used as the label for the column header.\n     */\n    readonly title?: string;\n\n    // TODO want/need support for any these?\n    // description?: string;\n    // constraints?: IConstraints;\n    // rdfType?: string;\n  };\n\n  /**\n   * An object when specifies the schema for a data model.\n   *\n   * #### Notes\n   * This is based on the JSON Table Schema specification:\n   * https://specs.frictionlessdata.io/table-schema/\n   */\n  export type Schema = {\n    /**\n     * The fields which describe the data model columns.\n     *\n     * Primary key fields are rendered as row header columns.\n     */\n    readonly fields: Field[];\n\n    /**\n     * The values to treat as \"missing\" data.\n     *\n     * Missing values are automatically converted to `null`.\n     */\n    readonly missingValues?: string[];\n\n    /**\n     * The field names which act as primary keys.\n     *\n     * Primary key fields are rendered as row header columns.\n     */\n    readonly primaryKey?: string | string[];\n\n    // TODO want/need support for this?\n    // foreignKeys?: IForeignKey[];\n  };\n\n  /**\n   * A type alias for a data source for a JSON data model.\n   *\n   * A data source is an array of JSON object records which represent\n   * the rows of the table. The keys of the records correspond to the\n   * field names of the columns.\n   */\n  export type DataSource = ReadonlyArray<ReadonlyJSONObject>;\n\n  /**\n   * An options object for initializing a JSON data model.\n   */\n  export interface IOptions {\n    /**\n     * The schema for the for the data model.\n     *\n     * The schema should be treated as an immutable object.\n     */\n    schema: Schema;\n\n    /**\n     * The data source for the data model.\n     *\n     * The data model takes full ownership of the data source.\n     */\n    data: DataSource;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * An object which holds the results of splitting schema fields.\n   */\n  export type SplitFieldsResult = {\n    /**\n     * The non-primary key fields to use for the grid body.\n     */\n    bodyFields: JSONModel.Field[];\n\n    /**\n     * The primary key fields to use for the grid headers.\n     */\n    headerFields: JSONModel.Field[];\n  };\n\n  /**\n   * Split the schema fields into header and body fields.\n   */\n  export function splitFields(schema: JSONModel.Schema): SplitFieldsResult {\n    // Normalize the primary keys.\n    let primaryKeys: string[];\n    if (schema.primaryKey === undefined) {\n      primaryKeys = [];\n    } else if (typeof schema.primaryKey === 'string') {\n      primaryKeys = [schema.primaryKey];\n    } else {\n      primaryKeys = schema.primaryKey;\n    }\n\n    // Separate the fields for the body and header.\n    let bodyFields: JSONModel.Field[] = [];\n    let headerFields: JSONModel.Field[] = [];\n    for (let field of schema.fields) {\n      if (primaryKeys.indexOf(field.name) === -1) {\n        bodyFields.push(field);\n      } else {\n        headerFields.push(field);\n      }\n    }\n\n    // Return the separated fields.\n    return { bodyFields, headerFields };\n  }\n\n  /**\n   * A type alias for a missing value map.\n   */\n  export type MissingValuesMap = { [key: string]: boolean };\n\n  /**\n   * Create a missing values map for a schema.\n   *\n   * This returns `null` if there are no missing values.\n   */\n  export function createMissingMap(\n    schema: JSONModel.Schema\n  ): MissingValuesMap | null {\n    // Bail early if there are no missing values.\n    if (!schema.missingValues || schema.missingValues.length === 0) {\n      return null;\n    }\n\n    // Collect the missing values into a map.\n    let result: MissingValuesMap = Object.create(null);\n    for (let value of schema.missingValues) {\n      result[value] = true;\n    }\n\n    // Return the populated map.\n    return result;\n  }\n}\n"],"names":["_disposed","this","dispose","onKeyDown","grid","event","editable","selectionModel","cursorRow","cursorColumn","input","String","fromCharCode","keyCode","test","cell","row","column","editorController","edit","getKeyboardLayout","keyForKeydownEvent","stopPropagation","preventDefault","onArrowLeft","onArrowRight","onArrowUp","onArrowDown","onPageUp","onPageDown","onEscape","onDelete","onKeyC","moveCursor","shiftKey","scrollToCursor","model","shift","accel","Platform","mode","selectionMode","scrollTo","scrollY","r1","r2","c1","c2","cr","cc","clear","r","c","cs","currentSelection","select","scrollToColumn","scrollByStep","maxScrollX","Infinity","scrollX","scrollToRow","maxScrollY","n","Math","floor","pageHeight","defaultSizes","rowHeight","scrollByPage","isEmpty","dataModel","maxRow","rowCount","maxColumn","columnCount","it","selections","s","undefined","next","sr1","max","min","sc1","sr2","sc2","setData","copyToClipboard","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","TypeError","__","constructor","create","__assign","assign","t","i","arguments","length","apply","CellRenderer","resolveOption","option","config","Private","options","font","textColor","backgroundColor","verticalAlignment","horizontalAlignment","format","TextRenderer","formatGeneric","elideDirection","wrapText","paint","gc","drawBackground","drawText","color","fillStyle","fillRect","x","y","width","height","text","vAlign","hAlign","boxHeight","textX","textY","boxWidth","textHeight","measureFontHeight","beginPath","rect","clip","textAlign","textBaseline","textWidth","measureText","wordsInColumn","split","curY","textInCurrentLine","curLineTextWidth","curSubString","substring","nextLineText","fillText","curWord","incrementedText","join","elide","missing","value","formatFixed","digits","Number","toFixed","formatPrecision","toPrecision","formatExponential","toExponential","formatIntlNumber","nft","Intl","NumberFormat","locales","formatDate","Date","toDateString","formatTime","toTimeString","formatISODateTime","toISOString","formatUTCDateTime","toUTCString","formatIntlDateTime","dtf","DateTimeFormat","fontHeightCache","fontMeasurementGC","normFont","fontMeasurementNode","style","document","body","appendChild","offsetHeight","removeChild","node","canvas","createElement","position","top","left","visibility","textContent","getContext","CellGroup","url","urlName","HyperlinkRenderer","areCellGroupsIntersectingAtAxis","group1","group2","axis","areCellGroupsIntersecting","getGroupIndex","rgn","numGroups","groupCount","group","getCellGroupsAtRegion","groupsAtRegion","push","joinCellGroups","groups","startRow","MAX_VALUE","endRow","MIN_VALUE","startColumn","endColumn","getCellGroupsAtRow","groupsAtRow","getCellGroupsAtColumn","groupsAtColumn","areCellsMerged","cell1","cell2","row1","column1","row2","column2","calculateMergeOffsets","regions","sectionList","index","mergeStartOffset","mergeEndOffset","mergedCellGroups","region","concat","groupsAtAxis","joinedGroup","g","splice","minRow","sizeOf","getGroup","groupIndex","joinCellGroupWithMergedCellGroups","mergedGroup","isCellGroupAbove","isCellGroupBelow","joinCellGroupsIntersectingAtAxis","mergedGroupAtAxis","_pressData","release","type","timeout","override","onMouseHover","hit","hitTest","clientX","clientY","handle","resizeHandleForHitTest","cursor","cursorForHandle","createCellConfigObject","cellRenderers","get","viewport","onMouseLeave","onMouseDown","renderer","window","open","Drag","localX","localY","selectionGroup","size","rowSize","columnSize","onMouseMove","data","lx","ly","hw","headerWidth","hh","headerHeight","vpw","viewportWidth","vph","viewportHeight","sx","sy","msx","msy","computeTimeout","setTimeout","autoselect","vx","vy","bodyWidth","bodyHeight","rowAt","columnAt","dx","resizeColumn","dy","resizeRow","onMouseUp","onMouseDoubleClick","onContextMenu","onWheel","deltaX","deltaY","deltaMode","ds","columnWidth","pageWidth","scrollBy","cursorMap","metadata","result","lw","lh","tw","th","scrollToCell","delta","abs","right","bottom","hyperlink","none","_changed","Signal","_selectionMode","changed","connect","onDataModelChanged","isRowSelected","some","containsRow","isColumnSelected","containsColumn","isCellSelected","containsCell","sender","args","emitChanged","emit","selection","_cursorRow","_cursorColumn","_cursorRectIndex","_selections","moveCursorWithinSelections","direction","firstSelection","cursorRect","dr","dc","newRow","newColumn","moveToNextRect","moveToPreviousRect","iter","pop","alreadySelected","filter","lr","lc","j","SelectionModel","createNode","_message","addClass","setFlag","Widget","_target","target","message","_placement","placement","close","handleEvent","_evtMouseDown","update","getElementsByClassName","onBeforeAttach","msg","addEventListener","onAfterDetach","removeEventListener","onUpdateRequest","targetRect","getBoundingClientRect","alignItems","justifyContent","messageNode","innerHTML","button","container","className","DEFAULT_INVALID_INPUT_MESSAGE","validate","valid","minLength","NaN","maxLength","pattern","isNaN","inputChanged","validityNotification","_validInput","_gridWheelEventHandler","_closeValidityNotification","viewportOccluder","onCommit","onCancel","validator","createValidatorBasedOnType","updatePosition","_addContainer","startEditing","cancel","getInput","error","console","log","setValidity","editorContainer","classList","remove","add","Notification","show","TextInputValidator","RegExp","constraint","NumberInputValidator","minimum","maximum","IntegerInputValidator","getCellInfo","columnX","rowY","cellGroup","columnOffset","rowOffset","cellInfo","commit","cursorMovement","pointerEvents","_onKeyDown","_onBlur","_onInput","isDisposed","_unbindEvents","createWidget","deserialize","focus","bindEvents","toString","spellcheck","inputType","CellEditor","InputCellEditor","step","trim","floatValue","parseFloat","Error","intValue","parseInt","_createWidget","_input","_deserialize","_bindEvents","checked","_isMultiSelect","_select","multiple","values","item","selected","indexOf","selectedOptions","editorContainerRect","maxHeight","isArray","items","enum","bind","listId","list","id","valueSet","Set","forEach","setAttribute","_editor","_cell","_typeBasedOverrides","Map","_metadataBasedOverrides","setEditor","identifier","editor","set","key","_metadataIdentifierToKey","_onCommit","_onCancel","_getEditor","response","_getDataTypeKey","_objectToKey","object","str","_metadataMatchesIdentifier","identifierValue","metadataValue","_getMetadataBasedEditor","editorMatched","dtKey","has","TextCellEditor","NumberCellEditor","IntegerCellEditor","BooleanCellEditor","DateCellEditor","OptionCellEditor","DynamicOptionCellEditor","DataModel","emptyMetadata","freeze","context","_context","_state","State","restore","strokeStyle","lineCap","lineDashOffset","lineJoin","lineWidth","miterLimit","shadowBlur","shadowColor","shadowOffsetX","shadowOffsetY","imageSmoothingEnabled","globalAlpha","globalCompositeOperation","getLineDash","setLineDash","segments","rotate","angle","scale","transform","m11","m12","m21","m22","translate","setTransform","save","closePath","isPointInPath","fillRule","arc","radius","startAngle","endAngle","anticlockwise","arcTo","x1","y1","x2","y2","bezierCurveTo","cp1x","cp1y","cp2x","cp2y","ellipse","radiusX","radiusY","rotation","lineTo","moveTo","quadraticCurveTo","cpx","cpy","w","h","fill","stroke","clearRect","maxWidth","strokeRect","strokeText","createLinearGradient","x0","y0","createRadialGradient","r0","createPattern","image","repetition","createImageData","getImageData","sw","sh","putImageData","drawImage","drawFocusIfNeeded","element","pi","pool","state","other","fallback","_values","_fallback","err","_count","_length","_sections","_minimumSize","minimumSize","_defaultSize","defaultSize","prev","curr","count","offset","clampSize","ArrayExt","offsetCmp","section","span","offsetOf","indexCmp","extentOf","resize","insert","removed","k","move","destination","i1","k1","i2","k2","pivot","count1","count2","span1","span2","k3","reset","_scrollX","_scrollY","_viewportWidth","_viewportHeight","_mousedown","_keyHandler","_mouseHandler","_vScrollBarMinWidth","_hScrollBarMinHeight","_dpiRatio","ceil","devicePixelRatio","_dataModel","_selectionModel","_editingEnabled","_style","DataGrid","defaultStyle","_stretchLastRow","stretchLastRow","_stretchLastColumn","stretchLastColumn","_headerVisibility","headerVisibility","_cellRenderers","RendererMap","_copyConfig","copyConfig","defaultCopyConfig","_onRenderersChanged","minimumSizes","_rowSections","SectionList","_columnSections","_rowHeaderSections","rowHeaderWidth","_columnHeaderSections","columnHeaderHeight","_canvas","createCanvas","_buffer","_overlay","_canvasGC","_bufferGC","_overlayGC","_viewport","tabIndex","outline","_vScrollBar","ScrollBar","orientation","_hScrollBar","_scrollCorner","_editorController","CellEditorController","MessageLoop","hide","thumbMoved","_onThumbMoved","pageRequested","_onPageRequested","stepRequested","_onStepRequested","GridLayout","layout","rowSpacing","columnSpacing","fitPolicy","setRowStretch","setColumnStretch","addWidget","_releaseMouse","disconnect","_onDataModelChanged","_syncViewport","_onSelectionsChanged","repaintOverlay","repaintContent","controller","enabled","MutableDataModel","nr","vy1","vy2","nc","vx1","vx2","currentSel","dir","rows","columns","ScrollRequest","bh","ph","bw","pw","RowResizeRequest","ColumnResizeRequest","resetRows","resetColumns","fitColumnNames","area","padding","numCols","colsRemaining","rowColumnCount","_fitRowColumnHeaders","bodyColumnCount","_fitBodyColumnHeaders","mapToLocal","mapToVirtual","toArray","alert","br","bc","rhc","chr","separator","headers","warningThreshold","colCount","cellCount","confirm","cells","lines","map","ClipboardExt","processMessage","vsbLimits","ElementExt","hsbLimits","minWidth","minHeight","messageHook","handler","_processViewportMessage","activate","_evtKeyDown","_evtMouseMove","_evtMouseUp","_evtMouseDoubleClick","_evtMouseLeave","_evtContextMenu","_evtWheel","_refreshDPI","onActivateRequest","preventScroll","onBeforeShow","onResize","_syncScrollState","PaintRequest","repaintRegion","OverlayPaintRequest","_resizeCanvasIfNeeded","maxW","maxH","curW","curH","expW","expH","needBlit","hasVScroll","isHidden","hasHScroll","vsw","hsh","apw","aph","needVScroll","needHScroll","setHidden","page","_scrollTo","_onViewportResize","_onViewportScrollRequest","_onViewportPaintRequest","_onViewportOverlayPaintRequest","_onViewportRowResizeRequest","_onViewportColumnResizeRequest","isVisible","offsetWidth","round","oldWidth","oldHeight","paintContent","_paintOverlay","bx","by","xMax","yMax","rs","rhs","chs","_resizeRow","_resizeColumnHeader","_resizeColumn","_resizeRowHeader","_onRowsInserted","_onColumnsInserted","_onRowsRemoved","_onColumnsRemoved","_onRowsMoved","_onColumnsMoved","_onCellsChanged","_onModelReset","rowSpan","columnSpan","nrh","nch","drh","dch","dpiRatio","oldSize","newSize","vw","vh","shouldPaintEverything","pos","_blitContent","contentX","contentY","contentWidth","contentHeight","dxArea","dyArea","source","rx","ry","rw","rh","_drawVoidRegion","_drawBodyRegion","_drawRowHeaderRegion","_drawColumnHeaderRegion","drawCornerHeaderRegion","numRows","cellValue","canvasGC","_drawBodySelections","_drawRowHeaderSelections","_drawColumnHeaderSelections","_drawCursor","_drawShadows","voidColor","contentW","contentH","rowSizes","columnSizes","dh","dw","xMin","yMin","_drawBackground","_drawRowBackground","rowBackgroundColor","_drawColumnBackground","columnBackgroundColor","_drawCells","_drawHorizontalGridLines","horizontalGridLineColor","gridLineColor","_drawVerticalGridLines","verticalGridLineColor","headerBackgroundColor","headerHorizontalGridLineColor","headerGridLineColor","headerVerticalGridLineColor","colorFn","_getColumnSize","_getRowSize","intersectingColumnGroups","intersectingRowGroups","JSONExt","GraphicsContext","xOffset","yOffset","xStart","lineStarted","leftCurrent","cIndex","cellUp","cellDown","line","yStart","topCurrent","rIndex","cellLeft","cellRight","selectionFillColor","selectionBorderColor","tmp","headerSelectionFillColor","headerSelectionBorderColor","maxCol","cursorFillColor","cursorBorderColor","shadow","scrollShadow","sxMax","syMax","grad","addColorStop","color1","color2","color3","copyFormatGeneric","ConflatableMessage","colGroups","rowHeaderGroups","cornerHeaderGroups","bodyGroups","regionHasMergedCells","_region","_r1","_c1","_r2","_c2","conflate","_index","_size","splitFields","schema","_data","_bodyFields","bodyFields","_headerFields","headerFields","_missingValues","createMissingMap","field","name","title","primaryKeys","primaryKey","fields","missingValues"],"sourceRoot":""}