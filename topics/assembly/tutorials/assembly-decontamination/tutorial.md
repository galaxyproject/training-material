---
layout: tutorial_hands_on
title: Decontamination of a genome assembly
zenodo_link: https://zenodo.org/records/13367433
questions:
- How to remove contaminant sequences from your assembly?
objectives:
- Remove contaminant sequences from an assembly
- Identify contaminant species
- Remove Mitochondrial DNA from an assembly
time_estimation: 1H30M
key_points:
- Assembly decontamination is important to avoid false identification of genes, blast
  hits...
contributions:
  authorship:
  - delphine-l
recordings:
- youtube_id: TODO
  length: 29M
  galaxy_version: 24.1.2.dev0
  date: '2024-09-20'
  speakers:
  - delphine-l
  captioners:
  - delphine-l
  bot-timestamp: 1726801100


---



When sequencing a genome, it is common that contamination from a foreign organism get mixed with the genomic material of our species of interest. For instance, if you are processing a whole body sample of an insect then you will sequence not only the insect, but everything on and inside of it. When building a reference genome, it is important to separate these contaminants from the genome of our species. Foreign DNA sequences could cause false positive identification when running BLAST analyses, the misidentification of genes that don't actually belong to the species, or they can be incorporated as 'reference' sequence for that species in the public archives when those sequences did not actually belong to that species.


In this tutorial, we will learn how to separate these contaminants from a genome assembly of a vertebrate. It will also include the removal of mitogenome contigs so that the final genome assembly contains only nuclear DNA. (A separate tutorial exists for assembling the mitogenome.)



> <agenda-title></agenda-title>
>
> In this tutorial, we will cover:
>
> 1. TOC
> {:toc}
>
{: .agenda}

# Get data

For this tutorial, we are using the genome assembly of the zebra finch (*Taeniopygia guttata*) generated by the [Vertebrate Genome Project](https://vertebrategenomesproject.org/). We downsized the assembly to 50 of the largest scaffolds to keep the runtime reasonable, and added some contaminants for the sake of this tutorial.


> <comment-title>Run this analysis on a "real" assembly</comment-title>
>
> If you want to run this analysis on a real assembly generated by the [Vertebrate Genome Project](https://vertebrategenomesproject.org/), you can find the scaffolded assembly on [Genome Ark](https://www.genomeark.org/) as a remote repository and upload it to Galaxy (available on the three main Public Galaxy instances: .org, .eu, .org.au).
>
> {% snippet faqs/galaxy/datasets_import_from_remote_files.md location="Genome Ark -> species -> Taeniopygia_guttata -> bTaeGut2 -> assembly_vgp_hic_2.0 -> bTaeGut2.hic.hap1.s2.fasta" %}
>
{: .comment}


The analysis described in this tutorial will work with any assembly in FASTA format. If your initial dataset is compressed, use the tool `Convert compressed file to uncompressed.` first.


> <hands-on-title> Data Upload </hands-on-title>
>
> 1. Create a new history for this tutorial
> 2. Import the files from [Zenodo]({{ page.zenodo_link }}):
>
>    ```
>    https://zenodo.org/records/13367433/files/Contaminated_assembly.fasta
>    ```
>
>    {% snippet faqs/galaxy/datasets_import_via_link.md %}
>
> 3. Rename the dataset : `Contaminated Assembly`
>
>    {% snippet faqs/galaxy/datasets_rename.md %}
>
> 4. Check that the datatype is `fasta`
>
>
>    {% snippet faqs/galaxy/datasets_change_datatype.md datatype="fasta" %}
>
>
{: .hands_on}

# Genome Masking


Genome masking refers to hiding regions of low complexity in the genome, such as repeats. Masking a genome reduces the noise and improves the efficacy of the decontamination by emphasizing the regions that contribute the most to the classification ({% cite saini2016gene %}, {% cite maskedref-website %}).

The first step of our analysis is therefore to mask our genome assembly. There are two types of masking, depending on the requirements of the tools we are using:

- **Soft Masking** The masked regions are replaced by lower case letters. This is the prefered method of masking when the tools understand it, because it does not cause any loss of information.
- **Hard Masking** The masked regions are replaced by a wildcard letter: `N`s for nucleotide sequences, `X`s for proteins. Use this technique if you are unsure whether the tools you will be using knows to ignore lower case letters.


> <details-title> Genome masking for everyone </details-title>
>
> Repeat masking is important for a lot of analyses like sequence alignments, classification, gene annotation. Repetitive and low complexity regions cause problems for search and clustering algorithms based on patterns. For gene annotation, repeats can cause non-specific gene hits.
>
{: .details}

In this tutorial we will use `Kraken2` to classify our contaminant scaffolds, `Blastn` to identify the mitochondrial sequences, and `DustMasker` to mask our genome. `Dustmasker` generates soft masked sequences, while `Kraken2` and `Blast` needs hard masked sequences, so we will need to do some file manipulations along the way.

Before running the analysis, ensure the sequences in your assembly are uppercase. This will ensure the soft masking can be done properly. *If* your sequences are not uppercase, then run the optional step "Convert the assembly file to upper case". We will then convert the lower case letter to `N`s to hard mask the sequences for `Kraken2` and `Blast`.

> <details-title> Why do the sequences need to be in uppercase? </details-title>
>
> Because soft masking uses lowercase to denote masked base pairs, the input sequence should not have lowercase sequences because then you cannot tell afterwards whether a sequence is lowercase because it started that way or because it was soft masked.
>
{: .details}


> <details-title> Optional : Convert the assembly file to upper case </details-title>
>
> 1. {% tool [Text transformation](toolshed.g2.bx.psu.edu/repos/bgruening/text_processing/tp_sed_tool/1.1.1) %} with the following parameters:
>    - {% icon param-file %} *"File to process"*: `Contaminated assembly`
>    - *"SED Program"*: `s/^[^>].+/\U&/g` (Convert letters in the sequence to uppercase)
>
>
{: .details}


> <hands-on-title> Mask the Genome with Dustmasker </hands-on-title>
>
> 1. {% tool [NCBI BLAST+ dustmasker](toolshed.g2.bx.psu.edu/repos/devteam/ncbi_blast_plus/ncbi_dustmasker_wrapper/2.14.1+galaxy1) %} with the following parameters:
>    - *"Subject database/sequences"*: `FASTA file from your history`
>        - {% icon param-file %} *"Nucleotide FASTA subject file to use instead of a database"*: `Contaminated assembly` (or the output of **Text transformation** {% icon tool %} if you converted your sequences to upper case)
>    - *"DUST level"*: `40`
>    - *"Output format"*: `FASTA`
>
> 2. Rename your file `Soft Masked assembly`
>
{: .hands_on}

Take a peek at your genome assembly. You can see that the beginning of the first scaffold has been converted to lower case, which masks repeats corresponding to the telomeres in the sequences.

> <hands-on-title> Soft Masking to Hard Masking </hands-on-title>
>
> 1. {% tool [Text transformation](toolshed.g2.bx.psu.edu/repos/bgruening/text_processing/tp_sed_tool/1.1.1) %} with the following parameters:
>    - {% icon param-file %} *"File to process"*: `Soft Masked assembly` (output of **NCBI BLAST+ dustmasker** {% icon tool %})
>    - *"SED Program"*: `/^>/!y/atcgn/NNNNN/`: In sequence lines (not starting with ">"), replace each instance of lower case bases (a t c or g), including undefined ones (n), to `N`s).
>
> 2. Rename your file `Hard Masked assembly`
>
>    {% snippet  faqs/galaxy/analysis_regular_expressions.md %}
> 
>    > <comment-title> Unsure about your regex? </comment-title>
>    >
>    > Ask ChatGPT about it. E.g. [What is the sed command to convert a text to upper case?](https://chatgpt.com/share/de569538-0e4d-41ac-8380-2d52af62b3d7) or test with a [regex tester](https://sed.js.org/) website (Warning, some of these testers do not understand the lowercase and uppercase transformations)
>    > 
>    {: .comment}
>
> 
{: .hands_on}

Take a look at your dataset and see that the lower case bases have been converted to `N`s.

# Identify Non-Target Contaminants

[Kraken2](https://ccb.jhu.edu/software/kraken2/) is a tool for taxonomic classification. It matches the kmers found in our assemblies to the ones stored in its databases. For the purpose of decontamination, we only need to identify possible contaminants, not the sequences belonging to our sampled organisms. Therefore, we only need to use a database containing likely contaminants such as bacteria, virus, and human (always wear gloves, folks!).
The best option at the time of this tutorial's writing is the PlusPF database which contains the RefSeq Standard (archaea, bacteria, viral, plasmid, human, UniVec_Core) plus protozoa and fungi data.



> <hands-on-title> Identify the taxonomy of our sequences </hands-on-title>
>
> 1. {% tool [Kraken2](toolshed.g2.bx.psu.edu/repos/iuc/kraken2/kraken2/2.1.1+galaxy1) %} with the following parameters:
>    - *"Single or paired reads"*: `Single`
>        - {% icon param-file %} *"Input sequences"*: `Hard Masked assembly` (output of **Text transformation** {% icon tool %})
>    - *"Print scientific names instead of just taxids"*: `Yes`
>    - *"Confidence"*: `0.3`
>    - *"Split classified and unclassified outputs?"*: `Yes`
>    - *"Select a Kraken2 database"*: `PlusPF (2021-05-17)`
>
>
{: .hands_on}


Kraken provides us with three outputs:
- A table containing the classification information for each sequence
- A fasta file containing the classified sequences (our contaminants)
- A fasta file containing the unclassified sequences (our precious zebra finch)

We could decide to use the fasta file of unclassified sequences as our assembly, but remember that our genome is hard masked. That means that we lost information. Because we don't use it now doesn't mean we never will. So instead of using the masked genome, we will remove the classified sequences from our original assembly.


But first, we are naturally curious people, and we want to know what type of contaminants we had in our sample.


## Investigate our contaminants

Take a look at the classification output of Kraken2. You can see five columns containing:

1. `C` / `U`: a one letter code indicating that the sequence was either classified or unclassified.
2. The sequence ID.
3. The taxonomy ID Kraken2 used to label the sequence; this is 0 if the sequence is unclassified.
4. The length of the sequence in bp.
5. A space-delimited list indicating the LCA mapping of each k-mer in the sequence(s). For example, "562:13 561:4 A:31 0:1" would indicate that:
    - the first 13 k-mers mapped to taxonomy ID #562
    - the next 4 k-mers mapped to taxonomy ID #561
    - the next 31 k-mers contained an ambiguous nucleotide
    - the next k-mer was not in the database

To identify our contaminants, we only need the information from the first three columns, and only for the sequences that are classified. So we will start by extracting our three columns and then filtering out unclassified sequences.

> <hands-on-title> Extract classification information </hands-on-title>
>
> 1. {% tool [Cut](Cut1) %} with the following parameters:
>    - *"Cut columns"*: `c1,c2,c3`
>    - *"Delimited by"*: `Tab`
>    - {% icon param-file %} *"From"*: `Kraken2 on data X: Classification` (output of **Kraken2** {% icon tool %})
>
>
>    > <comment-title> Columns definitions </comment-title>
>    >
>    > The three columns that we extracted contain:
>    > 1. Wheter the sequence is classified `C` or unclassified `U`
>    > 2. The sequence name
>    > 3. The sequence classification
>    >
>    {: .comment}
>
>    > <comment-title> What if my organism is in the database? </comment-title>
>    >
>    > The filtering of contaminants is based on their presence in the database. Any sequence classified by Kraken2 is considered as a contaminant. If you are working on an organism that is present in the database, this filtering will not work.
>    >
>    > *If you can't find a database that include contaminants but exclude your organism, you will need to process the outputs of Kraken differently.* Instead of filtering the sequences on classified/unclassified, select the sequences that do not match the taxonomic ID of your species. That is true for the rest of the section.
>    {: .comment}
>
{: .hands_on}


> <hands-on-title> Remove unclassified sequences </hands-on-title>
>
> 1. {% tool [Filter](Filter1) %} with the following parameters:
>    - {% icon param-file %} *"Filter"*: `Cut on data X` (output of **Cut** {% icon tool %})
>    - *"With following condition"*: `c1!='U'`
>
> 2. Rename the output `Contaminants informations`
>
{: .hands_on}


> <question-title></question-title>
>
>  How many different contaminants are in our sample?
>
> > <solution-title></solution-title>
> >
> >  We found two contaminants in our sample: Salmonella and Yersinia phage phiR1-37.
> >
> {: .solution}
>
{: .question}


## Get the list of contaminants to remove from our assembly

In order to remove the contaminant sequences from our assembly, we need a list of the contaminants names, that we will get by extracting the contaminant IDs from the Kraken output.


> <hands-on-title> Get contaminant sequence names </hands-on-title>
>
> 1. {% tool [Cut](Cut1) %} with the following parameters:
>    - *"Cut columns"*: `c2`
>    - *"Delimited by"*: `Tab`
>    - {% icon param-file %} *"From"*: `Contaminants informations` (output of **Filter** {% icon tool %})
>
> 2. Rename the output `List of Contaminants`
>
{: .hands_on}


Now that we have our list of contaminants, we will go through a similar process to extract mitochondrial sequences.


# Identify mitochondrial DNA

We start with running Blastn against a database containing mitochondrial sequences.

> <hands-on-title> Blastn against RefSeq Mitochondrion </hands-on-title>
>
> 1. {% tool [NCBI BLAST+ blastn](toolshed.g2.bx.psu.edu/repos/devteam/ncbi_blast_plus/ncbi_blastn_wrapper/2.14.1+galaxy1) %} with the following parameters:
>    - {% icon param-file %} *"Nucleotide query sequence(s)"*: `Hard Masked assembly` (output of **Text transformation** {% icon tool %})
>    - *"Subject database/sequences"*: `Locally installed BLAST database`
>        - *"Nucleotide BLAST database"*: `RefSeq Mitochondrion`
>    - *"Type of BLAST"*: `blastn - Traditional BLASTN requiring an exact match of 11, for somewhat similar sequences`
>    - *"Output format"*: `Tabular (select which columns)`
>        - *"Standard columns"*: `qseqid, sseqid, length, qstart, qend, evalue`
>        - *"Extended columns"*: `qlen`
>        - *"Miscellaneous columns"*: `qcovs, qcovhsp`
>    - *"Advanced Options"*: `Hide Advanced Options`
>
>
{: .hands_on}

This step may take a little while, so you have time to make yourself a cup of coffee.

Next, we parse the result of the Blastn to extract a report on the alignements between our assemblies and the database, and a list of the scaffolds aligning with mitochondrial sequences.


> <hands-on-title> Extract alignement informations from the Blast output</hands-on-title>
>
> 1. {% tool [Parse mitochondrial blast](toolshed.g2.bx.psu.edu/repos/iuc/parse_mito_blast/parse_mito_blast/1.0.2+galaxy0) %} with the following parameters:
>    - {% icon param-file %} *"Tabular file generated by mito-blast"*: `blastn Text transformation on data X vs 'refseq_mitochondrion'` (output of **NCBI BLAST+ blastn** {% icon tool %})
>
> 2. Rename the output `List of Mitochondrial sequences`
>
{: .hands_on}



> <question-title></question-title>
>
>  How many scaffolds belonging to the mitochondria are in our sample?
>
> > <solution-title></solution-title>
> >
> >  We found two mitochondrial scaffolds in our assembly.
> >
> {: .solution}
>
{: .question}



# Remove contaminants and mitochondrial DNA from the assembly

From the previous sections, we obtain two files containing a list of sequences belonging to contaminants and one belonging to the mitochondria. We will merge these two lists to clean up our original assembly.


> <hands-on-title> Concatenate lists of scaffolds to remove </hands-on-title>
>
> 1. {% tool [Concatenate datasets](toolshed.g2.bx.psu.edu/repos/bgruening/text_processing/tp_cat/0.1.1) %} with the following parameters:
>    - {% icon param-files %} *"Datasets to concatenate"*: `List of Contaminants`, `List of Mitochondrial sequences`
>
> 2. Rename the output `Sequences to remove`
>
{: .hands_on}

Now we will use gfastats, a tool box for genome assemblies with capability for manipulations and statistics generation.

> <hands-on-title> Remove scaffolds from the original genome assembly </hands-on-title>
>
> 1. {% tool [gfastats](toolshed.g2.bx.psu.edu/repos/bgruening/gfastats/gfastats/1.3.6+galaxy0) %} with the following parameters:
>    - {% icon param-file %} *"Input file"*: `output` (Input dataset)
>    - *"Specify target sequences"*: `Enabled`
>        - {% icon param-file %} *"Exclude specific intervals"*: `Sequences to remove` (output of **Concatenate datasets** {% icon tool %}). This input can be a bed file with sequence coordinates, or, in our case, a simple list of sequence IDs to remove from the fasta file. 
>    - *"Tool mode"*: `Genome assembly manipulation`
>        - *"Output format"*: `FASTA.gz`
>
>
{: .hands_on}

# Conclusion

In this tutorial we used taxonomic classification to identified contaminants and Blast to identify mitochondrial sequences in a genome assembly. We then removed these sequences to keep only the nuclear DNA of our species of interest.

Now that we have removed the contaminants and mitochondrial DNA from our assembly, it is ready for manual curation!

